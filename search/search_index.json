{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mapper Proxy \u00b6 A mapper proxy for playing MUME, targeted towards the needs of blind players. It is entirely controlled by plain text commands, and offers some facilities such as pathfinding and room finding. It also comes with a high contrast GUI for visually impaired players, and a tiled one for sighted players. License And Credits \u00b6 Mapper Proxy is licensed under the terms of the Mozilla Public License, version 2.0. Mapper Proxy was originally created and is actively maintained by Nick Stockton. Visually Impaired GUI contributed by Katalina Durden. Sighted GUI and various additions contributed by Lindisse. The tiles of the GUI for sighted players are distributed under the CC-BY-SA 3.0 license. They are a modified version of fantasy-tileset.png originally created by Jerome. Installation \u00b6 As Part of Mud Clients \u00b6 Mapper Proxy is distributed as part of MUSHclient-MUME , and tintin-MUME , which also provide scripts to play Mume more easily. Refer to these projects for an installation guide. Running From Source \u00b6 Install the Python interpreter, and make sure it's in your path before running this package. After Python is installed, execute the following commands from the top level directory of this repository to install the module dependencies. python -m venv venv venv\\Scripts\\activate.bat pip install -Ur requirements.txt If you wish to contribute to this project, install the development dependencies with the following commands. venv\\Scripts\\activate.bat pip install -Ur requirements-dev.txt pre-commit install -t pre-commit pre-commit install -t pre-push Mapper Proxy Usage \u00b6 Manual Startup \u00b6 To start Mapper Proxy, activate the virtual environment by running venv\\Scripts\\activate.bat , and then run python start.py from the root directory of this project. It accepts the following arguments: -h , --help Show program's help and exit. -v , --version Show program's version number and exit. -e , --emulation Start in emulation mode. The mapper will not connect to MUME. -i [text|hc|sighted] , --interface [text|hc|sighted] Select an interface. Text-only mode, high contrast GUI, or sighted GUI. The high contrast GUI is a high contrast one for visually impaired players. The sighted GUI uses png tiles. Default is \" text \" mode (no GUI). -f [normal|tintin|raw] , --format [normal|tintin|raw] Select how the data from the server is transformed before being sent to the client. Normal mode filters out XML tags from the data received by the mud before sending it to the user's mud client, TinTin sends certain tags to the client in a special format for the mud client to trigger on, and raw sends the data from the mud to the mud client unmodified. Default is \" normal \". -lh address , --local_host address The local host address to bind to. Default is \" 127.0.0.1 \". -lp port , --local_port port The local port to bind to. Default is \" 4000 \". -rh address , --remote_host address The remote host address to connect to. Default is \" mume.org \". -rp port , --remote_port port The remote port to connect to. Default is \" 4242 \". -nssl , --no_ssl Disable encrypted communication between the local and remote hosts. Don't do this unless you know what you're doing. -ptlf , --prompt_terminator_lf Terminate game prompts with new line characters (IAC + GA is default). -gp , --gag_prompts gag emulated prompts. -ff text , --find_format text The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute} , {direction} , {clockPosition} , {distance} , {name} , {vnum} . Where {attribute} represents the attribute on which the search is performed. The default is \"{vnum}, {name}, {attribute}\" . Once done, connect your client to 127.0.0.1 , port 4000 . Starting From a Client \u00b6 It is possible to start Mapper Proxy directly from the client. Here is, for example, how to start it from a tintin+++ script, from the root directory of this project: #run {mapper} {python -B} from mapper.main import main #action {^MPICOMMAND:%1:MPICOMMAND$} {#mume {#system %1;#mapper continue}} #gts #mapper main(outputFormat=\"tintin\", interface=\"sighted\") Mapper Proxy Commands \u00b6 Auto Mapping Commands \u00b6 Auto mapping mode must be on for these commands to have any effect. autolink -- Toggle Auto linking on or off. If on, the mapper will attempt to link undefined exits in newly added rooms. automap -- Toggle automatic mapping mode on or off. automerge -- Toggle automatic merging of duplicate rooms on or off. autoupdate -- Toggle Automatic updating of room name/descriptions/dynamic descriptions on or off. Map Editing Commands \u00b6 doorflags [add|remove] [hidden|need_key|no_block|no_break|no_pick|delayed|callable|knockable|magic|action|no_bash] [north|east|south|west|up|down] -- Modify door flags for a given direction. exitflags [add|remove] [exit|door|road|climb|random|special|avoid|no_match] [north|east|south|west|up|down] -- Modify exit flags for a given direction. ralign [good|neutral|evil|undefined] -- Modify the alignment flag of the current room. ravoid [+|-] -- Set or clear the avoid flag for the current room. If the avoid flag is set, the mapper will try to avoid the room when path finding. rdelete [vnum] -- Delete the room with vnum. If the mapper is synced and no vnum is given, delete the current room. rlabel [add|delete|info|search] [label] [vnum] -- Manage room labels. Vnum is only used when adding a room. Leave it blank to use the current room's vnum. Use rlabel info all to get a list of all labels. rlight [lit|dark|undefined] -- Modify the light flag of the current room. rlink [add|remove] [oneway] [vnum] [north|east|south|west|up|down] -- Manually manage links from the current room to room with vnum. If oneway is given, treat the link as unidirectional. rloadflags [add|remove] [treasure|armour|weapon|water|food|herb|key|mule|horse|pack_horse|trained_horse|rohirrim|warg|boat|attention|tower|clock|mail|stable|white_word|dark_word|equipment|coach] -- Modify the load flags of the current room. rmobflags [add|remove] [rent|shop|weapon_shop|armour_shop|food_shop|pet_shop|guild|scout_guild|mage_guild|cleric_guild|warrior_guild|ranger_guild|aggressive_mob|quest_mob|passive_mob|elite_mob|super_mob] -- Modify the mob flags of the current room. rnote [-a|-r] [text] -- Modify the note for the current room. If '-a' is given, append text to the current note. If '-r' is given, remove the note. rportable [portable|notportable|undefined] -- Modify the portable flag of the current room. rridable [ridable|notridable|undefined] -- Modify the ridable flag of the current room. rterrain [death|city|shallowwater|forest|hills|road|cavern|field|water|underwater|rapids|indoors|brush|tunnel|mountains|random|undefined] -- Modify the terrain of the current room. rx [number] -- Modify the X coordinate of the current room. ry [number] -- Modify the Y coordinate of the current room. rz [number] -- Modify the Z coordinate of the current room. savemap -- Save modifications to the map to disk. secret [add|remove] [name] [north|east|south|west|up|down] -- Add or remove a secret door in the current room. Searching Commands \u00b6 fdoor [text] -- Search the map for rooms with doors matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fdynamic [text] -- Search the map for rooms with dynamic descriptions matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. flabel [text] -- Search the map for rooms with labels matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. If no text is given, will show the 20 closest labeled rooms. fname [text] -- Search the map for rooms with names matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fnote [text] -- Search the map for rooms with notes matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. Path Commands \u00b6 path [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Print speed walk directions from the current room to the room with vnum or label. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, path ingrove noroad|nobrush. run [c|t] [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Automatically walk from the current room to the room with vnum or label. If 'c' is provided instead of a vnum or label, the mapper will recalculate the path from the current room to the previously provided destination. If t (short for target) is given before the vnum or label, the mapper will store the destination, but won't start auto walking until the user enters 'run c'. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, run ingrove noroad|nobrush. step [label|vnum] -- Move 1 room towards the destination room matching label or vnum. stop -- Stop auto walking. Door Commands \u00b6 secretaction [action] [north|east|south|west|up|down] -- Perform an action on a secret door in a given direction. This command is meant to be called from an alias. For example, secretaction open east. Miscellaneous Commands \u00b6 clock [action] -- If no action is given, print the output from the mapper's clock. If the action is 'pull', send the appropriate commands to the game for opening the exit in mystical. If any other action is given, send a line with the current game time to the game, prefixed by the action. Example: clock narrate to narrate the current game time. emu [command] -- If not in emulation mode (I.E. connected to the game), execute an emulation command. getlabel [vnum] -- Returns the label or labels defined for the room with vnum. If no vnum is supplied, the current room's vnum is used. gettimer -- Returns the amount of seconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. gettimerms -- Returns the amount of milliseconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. help -- If in emulation mode, print a summery of the available emulation commands. maphelp -- Print a summery of the available mapper commands. quit -- Quit the mapper when in emulation mode. rinfo [vnum|label] -- Print info about the room with vnum or label. If no vnum or label is given, use current room. sync [vnum|label] -- Manually sync the map to the room with vnum or label. If no vnum or label is given, mapper will be placed in an unsynced state, and will try to automatically sync to the current room. tvnum [player] -- Tell the vnum of the current room to another player. vnum -- Print the vnum of the current room. wordwrap -- Toggle word wrapping of remote edited text on or off.","title":"Home"},{"location":"#mapper-proxy","text":"A mapper proxy for playing MUME, targeted towards the needs of blind players. It is entirely controlled by plain text commands, and offers some facilities such as pathfinding and room finding. It also comes with a high contrast GUI for visually impaired players, and a tiled one for sighted players.","title":"Mapper Proxy"},{"location":"#license-and-credits","text":"Mapper Proxy is licensed under the terms of the Mozilla Public License, version 2.0. Mapper Proxy was originally created and is actively maintained by Nick Stockton. Visually Impaired GUI contributed by Katalina Durden. Sighted GUI and various additions contributed by Lindisse. The tiles of the GUI for sighted players are distributed under the CC-BY-SA 3.0 license. They are a modified version of fantasy-tileset.png originally created by Jerome.","title":"License And Credits"},{"location":"#installation","text":"","title":"Installation"},{"location":"#as-part-of-mud-clients","text":"Mapper Proxy is distributed as part of MUSHclient-MUME , and tintin-MUME , which also provide scripts to play Mume more easily. Refer to these projects for an installation guide.","title":"As Part of Mud Clients"},{"location":"#running-from-source","text":"Install the Python interpreter, and make sure it's in your path before running this package. After Python is installed, execute the following commands from the top level directory of this repository to install the module dependencies. python -m venv venv venv\\Scripts\\activate.bat pip install -Ur requirements.txt If you wish to contribute to this project, install the development dependencies with the following commands. venv\\Scripts\\activate.bat pip install -Ur requirements-dev.txt pre-commit install -t pre-commit pre-commit install -t pre-push","title":"Running From Source"},{"location":"#mapper-proxy-usage","text":"","title":"Mapper Proxy Usage"},{"location":"#manual-startup","text":"To start Mapper Proxy, activate the virtual environment by running venv\\Scripts\\activate.bat , and then run python start.py from the root directory of this project. It accepts the following arguments: -h , --help Show program's help and exit. -v , --version Show program's version number and exit. -e , --emulation Start in emulation mode. The mapper will not connect to MUME. -i [text|hc|sighted] , --interface [text|hc|sighted] Select an interface. Text-only mode, high contrast GUI, or sighted GUI. The high contrast GUI is a high contrast one for visually impaired players. The sighted GUI uses png tiles. Default is \" text \" mode (no GUI). -f [normal|tintin|raw] , --format [normal|tintin|raw] Select how the data from the server is transformed before being sent to the client. Normal mode filters out XML tags from the data received by the mud before sending it to the user's mud client, TinTin sends certain tags to the client in a special format for the mud client to trigger on, and raw sends the data from the mud to the mud client unmodified. Default is \" normal \". -lh address , --local_host address The local host address to bind to. Default is \" 127.0.0.1 \". -lp port , --local_port port The local port to bind to. Default is \" 4000 \". -rh address , --remote_host address The remote host address to connect to. Default is \" mume.org \". -rp port , --remote_port port The remote port to connect to. Default is \" 4242 \". -nssl , --no_ssl Disable encrypted communication between the local and remote hosts. Don't do this unless you know what you're doing. -ptlf , --prompt_terminator_lf Terminate game prompts with new line characters (IAC + GA is default). -gp , --gag_prompts gag emulated prompts. -ff text , --find_format text The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute} , {direction} , {clockPosition} , {distance} , {name} , {vnum} . Where {attribute} represents the attribute on which the search is performed. The default is \"{vnum}, {name}, {attribute}\" . Once done, connect your client to 127.0.0.1 , port 4000 .","title":"Manual Startup"},{"location":"#starting-from-a-client","text":"It is possible to start Mapper Proxy directly from the client. Here is, for example, how to start it from a tintin+++ script, from the root directory of this project: #run {mapper} {python -B} from mapper.main import main #action {^MPICOMMAND:%1:MPICOMMAND$} {#mume {#system %1;#mapper continue}} #gts #mapper main(outputFormat=\"tintin\", interface=\"sighted\")","title":"Starting From a Client"},{"location":"#mapper-proxy-commands","text":"","title":"Mapper Proxy Commands"},{"location":"#auto-mapping-commands","text":"Auto mapping mode must be on for these commands to have any effect. autolink -- Toggle Auto linking on or off. If on, the mapper will attempt to link undefined exits in newly added rooms. automap -- Toggle automatic mapping mode on or off. automerge -- Toggle automatic merging of duplicate rooms on or off. autoupdate -- Toggle Automatic updating of room name/descriptions/dynamic descriptions on or off.","title":"Auto Mapping Commands"},{"location":"#map-editing-commands","text":"doorflags [add|remove] [hidden|need_key|no_block|no_break|no_pick|delayed|callable|knockable|magic|action|no_bash] [north|east|south|west|up|down] -- Modify door flags for a given direction. exitflags [add|remove] [exit|door|road|climb|random|special|avoid|no_match] [north|east|south|west|up|down] -- Modify exit flags for a given direction. ralign [good|neutral|evil|undefined] -- Modify the alignment flag of the current room. ravoid [+|-] -- Set or clear the avoid flag for the current room. If the avoid flag is set, the mapper will try to avoid the room when path finding. rdelete [vnum] -- Delete the room with vnum. If the mapper is synced and no vnum is given, delete the current room. rlabel [add|delete|info|search] [label] [vnum] -- Manage room labels. Vnum is only used when adding a room. Leave it blank to use the current room's vnum. Use rlabel info all to get a list of all labels. rlight [lit|dark|undefined] -- Modify the light flag of the current room. rlink [add|remove] [oneway] [vnum] [north|east|south|west|up|down] -- Manually manage links from the current room to room with vnum. If oneway is given, treat the link as unidirectional. rloadflags [add|remove] [treasure|armour|weapon|water|food|herb|key|mule|horse|pack_horse|trained_horse|rohirrim|warg|boat|attention|tower|clock|mail|stable|white_word|dark_word|equipment|coach] -- Modify the load flags of the current room. rmobflags [add|remove] [rent|shop|weapon_shop|armour_shop|food_shop|pet_shop|guild|scout_guild|mage_guild|cleric_guild|warrior_guild|ranger_guild|aggressive_mob|quest_mob|passive_mob|elite_mob|super_mob] -- Modify the mob flags of the current room. rnote [-a|-r] [text] -- Modify the note for the current room. If '-a' is given, append text to the current note. If '-r' is given, remove the note. rportable [portable|notportable|undefined] -- Modify the portable flag of the current room. rridable [ridable|notridable|undefined] -- Modify the ridable flag of the current room. rterrain [death|city|shallowwater|forest|hills|road|cavern|field|water|underwater|rapids|indoors|brush|tunnel|mountains|random|undefined] -- Modify the terrain of the current room. rx [number] -- Modify the X coordinate of the current room. ry [number] -- Modify the Y coordinate of the current room. rz [number] -- Modify the Z coordinate of the current room. savemap -- Save modifications to the map to disk. secret [add|remove] [name] [north|east|south|west|up|down] -- Add or remove a secret door in the current room.","title":"Map Editing Commands"},{"location":"#searching-commands","text":"fdoor [text] -- Search the map for rooms with doors matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fdynamic [text] -- Search the map for rooms with dynamic descriptions matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. flabel [text] -- Search the map for rooms with labels matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. If no text is given, will show the 20 closest labeled rooms. fname [text] -- Search the map for rooms with names matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fnote [text] -- Search the map for rooms with notes matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance.","title":"Searching Commands"},{"location":"#path-commands","text":"path [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Print speed walk directions from the current room to the room with vnum or label. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, path ingrove noroad|nobrush. run [c|t] [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Automatically walk from the current room to the room with vnum or label. If 'c' is provided instead of a vnum or label, the mapper will recalculate the path from the current room to the previously provided destination. If t (short for target) is given before the vnum or label, the mapper will store the destination, but won't start auto walking until the user enters 'run c'. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, run ingrove noroad|nobrush. step [label|vnum] -- Move 1 room towards the destination room matching label or vnum. stop -- Stop auto walking.","title":"Path Commands"},{"location":"#door-commands","text":"secretaction [action] [north|east|south|west|up|down] -- Perform an action on a secret door in a given direction. This command is meant to be called from an alias. For example, secretaction open east.","title":"Door Commands"},{"location":"#miscellaneous-commands","text":"clock [action] -- If no action is given, print the output from the mapper's clock. If the action is 'pull', send the appropriate commands to the game for opening the exit in mystical. If any other action is given, send a line with the current game time to the game, prefixed by the action. Example: clock narrate to narrate the current game time. emu [command] -- If not in emulation mode (I.E. connected to the game), execute an emulation command. getlabel [vnum] -- Returns the label or labels defined for the room with vnum. If no vnum is supplied, the current room's vnum is used. gettimer -- Returns the amount of seconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. gettimerms -- Returns the amount of milliseconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. help -- If in emulation mode, print a summery of the available emulation commands. maphelp -- Print a summery of the available mapper commands. quit -- Quit the mapper when in emulation mode. rinfo [vnum|label] -- Print info about the room with vnum or label. If no vnum or label is given, use current room. sync [vnum|label] -- Manually sync the map to the room with vnum or label. If no vnum or label is given, mapper will be placed in an unsynced state, and will try to automatically sync to the current room. tvnum [player] -- Tell the vnum of the current room to another player. vnum -- Print the vnum of the current room. wordwrap -- Toggle word wrapping of remote edited text on or off.","title":"Miscellaneous Commands"},{"location":"license/","text":"Mozilla Public License Version 2.0 \u00b6 1. Definitions \u00b6 1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity. 2. License Grants and Conditions \u00b6 2.1. Grants \u00b6 Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date \u00b6 The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope \u00b6 The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses \u00b6 No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation \u00b6 Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use \u00b6 This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions \u00b6 Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1. 3. Responsibilities \u00b6 3.1. Distribution of Source Form \u00b6 All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form \u00b6 If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work \u00b6 You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices \u00b6 You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms \u00b6 You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction. 4. Inability to Comply Due to Statute or Regulation \u00b6 If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it. 5. Termination \u00b6 5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. 6. Disclaimer of Warranty \u00b6 Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer. 7. Limitation of Liability \u00b6 Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You. 8. Litigation \u00b6 Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims. 9. Miscellaneous \u00b6 This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor. 10. Versions of the License \u00b6 10.1. New Versions \u00b6 Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions \u00b6 You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions \u00b6 If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses \u00b6 If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached. Exhibit A - Source Code Form License Notice \u00b6 This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership. Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice \u00b6 This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"License"},{"location":"license/#mozilla-public-license-version-20","text":"","title":"Mozilla Public License Version 2.0"},{"location":"license/#1-definitions","text":"1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.","title":"1. Definitions"},{"location":"license/#2-license-grants-and-conditions","text":"","title":"2. License Grants and Conditions"},{"location":"license/#21-grants","text":"Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.","title":"2.1. Grants"},{"location":"license/#22-effective-date","text":"The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.","title":"2.2. Effective Date"},{"location":"license/#23-limitations-on-grant-scope","text":"The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).","title":"2.3. Limitations on Grant Scope"},{"location":"license/#24-subsequent-licenses","text":"No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).","title":"2.4. Subsequent Licenses"},{"location":"license/#25-representation","text":"Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.","title":"2.5. Representation"},{"location":"license/#26-fair-use","text":"This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.","title":"2.6. Fair Use"},{"location":"license/#27-conditions","text":"Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.","title":"2.7. Conditions"},{"location":"license/#3-responsibilities","text":"","title":"3. Responsibilities"},{"location":"license/#31-distribution-of-source-form","text":"All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form.","title":"3.1. Distribution of Source Form"},{"location":"license/#32-distribution-of-executable-form","text":"If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License.","title":"3.2. Distribution of Executable Form"},{"location":"license/#33-distribution-of-a-larger-work","text":"You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).","title":"3.3. Distribution of a Larger Work"},{"location":"license/#34-notices","text":"You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.","title":"3.4. Notices"},{"location":"license/#35-application-of-additional-terms","text":"You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.","title":"3.5. Application of Additional Terms"},{"location":"license/#4-inability-to-comply-due-to-statute-or-regulation","text":"If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.","title":"4. Inability to Comply Due to Statute or Regulation"},{"location":"license/#5-termination","text":"5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.","title":"5. Termination"},{"location":"license/#6-disclaimer-of-warranty","text":"Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.","title":"6. Disclaimer of Warranty"},{"location":"license/#7-limitation-of-liability","text":"Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.","title":"7. Limitation of Liability"},{"location":"license/#8-litigation","text":"Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.","title":"8. Litigation"},{"location":"license/#9-miscellaneous","text":"This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.","title":"9. Miscellaneous"},{"location":"license/#10-versions-of-the-license","text":"","title":"10. Versions of the License"},{"location":"license/#101-new-versions","text":"Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.","title":"10.1. New Versions"},{"location":"license/#102-effect-of-new-versions","text":"You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.","title":"10.2. Effect of New Versions"},{"location":"license/#103-modified-versions","text":"If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).","title":"10.3. Modified Versions"},{"location":"license/#104-distributing-source-code-form-that-is-incompatible-with-secondary-licenses","text":"If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.","title":"10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses"},{"location":"license/#exhibit-a-source-code-form-license-notice","text":"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership.","title":"Exhibit A - Source Code Form License Notice"},{"location":"license/#exhibit-b-incompatible-with-secondary-licenses-notice","text":"This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice"},{"location":"api/","text":"Mapper Proxy API \u00b6 Automatically generated API reference. Mapper \u00b6 Clean Map Clock Config Delays Main Mapper Mud Events Utils World Room Data \u00b6 Database Room Objects Sockets \u00b6 Buffered Socket Fake Socket","title":"API Index"},{"location":"api/#mapper-proxy-api","text":"Automatically generated API reference.","title":"Mapper Proxy API"},{"location":"api/#mapper","text":"Clean Map Clock Config Delays Main Mapper Mud Events Utils World","title":"Mapper"},{"location":"api/#room-data","text":"Database Room Objects","title":"Room Data"},{"location":"api/#sockets","text":"Buffered Socket Fake Socket","title":"Sockets"},{"location":"api/cleanmap/","text":"Module mapper.cleanmap \u00b6 Class ExitsCleaner \u00b6 Implements an event handler that cleans erroneously hidden exits. This handler uses the output of the 'exits' command in MUME to Check if any visible exits are erroneously marked as hidden in the map database. Any exits which are found to be erroneously marked as hidden are then cleaned (marked as visible). Method handle ( self , text ) \u00b6 Handles the incoming text from MUME. Parameters: Name Type Description Default text str The received text from the game. required Source code in mapper\\cleanmap.py def handle ( self , text : str ) -> None : \"\"\" Handles the incoming text from MUME. Args: text: The received text from the game. \"\"\" if not self . mapper . autoUpdateRooms or text . startswith ( \"Exits:\" ): return None for line in text . splitlines (): match : Union [ Match [ str ], None ] = EXIT_REGEX . match ( line ) if match is not None : room : Room = self . mapper . currentRoom direction : str = match . group ( \"dir\" ) . lower () if ( self . mapper . isSynced and direction in room . exits and \"hidden\" in room . exits [ direction ] . doorFlags ): self . mapper . user_command_secret ( f \"remove { direction } \" )","title":"cleanmap.py"},{"location":"api/cleanmap/#mapper.cleanmap","text":"","title":"cleanmap"},{"location":"api/cleanmap/#mapper.cleanmap.ExitsCleaner","text":"Implements an event handler that cleans erroneously hidden exits. This handler uses the output of the 'exits' command in MUME to Check if any visible exits are erroneously marked as hidden in the map database. Any exits which are found to be erroneously marked as hidden are then cleaned (marked as visible).","title":"ExitsCleaner"},{"location":"api/cleanmap/#mapper.cleanmap.ExitsCleaner.handle","text":"Handles the incoming text from MUME. Parameters: Name Type Description Default text str The received text from the game. required Source code in mapper\\cleanmap.py def handle ( self , text : str ) -> None : \"\"\" Handles the incoming text from MUME. Args: text: The received text from the game. \"\"\" if not self . mapper . autoUpdateRooms or text . startswith ( \"Exits:\" ): return None for line in text . splitlines (): match : Union [ Match [ str ], None ] = EXIT_REGEX . match ( line ) if match is not None : room : Room = self . mapper . currentRoom direction : str = match . group ( \"dir\" ) . lower () if ( self . mapper . isSynced and direction in room . exits and \"hidden\" in room . exits [ direction ] . doorFlags ): self . mapper . user_command_secret ( f \"remove { direction } \" )","title":"handle()"},{"location":"api/clock/","text":"Module mapper.clock \u00b6 Class Clock \u00b6 Attribute epoch : int property writable \u00b6 The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset. Method setTime ( self , year , month , day , hour , minutes ) \u00b6 Sets the Mume epoch from the current Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Source code in mapper\\clock.py def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta Method time ( self , action = None ) \u00b6 Outputs information about the current Mume time. Parameters: Name Type Description Default action Optional[str] An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. None Returns: Type Description str The requested output. Source code in mapper\\clock.py def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info Class MumeTime \u00b6 Attribute amPm : str property readonly \u00b6 The AM - PM value. Attribute dawn : int property readonly \u00b6 The hour of dawn. Attribute dawnDuskState : Tuple [ str , str , int ] property readonly \u00b6 A tuple containing the current state name, the next state name, and the game hours until next state. Attribute day : int property readonly \u00b6 The day of the month (1 or more). Attribute dayOfYear : int property readonly \u00b6 The day of the year (1 or more). Attribute daysSinceFullMoon : int property readonly \u00b6 The days since last full moon (0 or more). Attribute daysSinceMoonCycle : int property readonly \u00b6 The days since last moon cycle (0 or more). Attribute daysUntilFullMoon : int property readonly \u00b6 The days until next full moon (1 or more). Attribute daysUntilMoonCycle : int property readonly \u00b6 The days until next moon cycle (1 or more). Attribute daysUntilSeason : int property readonly \u00b6 The days until next season (1 or more). Attribute daysUntilWinter : int property readonly \u00b6 The days until next winter (1 or more). Attribute delta : int property readonly \u00b6 The time as a delta. Attribute dusk : int property readonly \u00b6 The hour of dusk. Attribute hour : int property readonly \u00b6 The hour of the day (0 or more). Attribute hourOfMoonRise : int property readonly \u00b6 The hour of day when the moon will rise (0 or more). Attribute hourOfYear : int property readonly \u00b6 The hour of the year (0 or more). Attribute hoursSinceFullMoon : int property readonly \u00b6 The hours since last full moon (0 or more). Attribute hoursUntilFullMoon : int property readonly \u00b6 The hours Until full moon (1 or more). Attribute info : str property readonly \u00b6 A summery of information about this moment in Mume time. Attribute minutes : int property readonly \u00b6 The minutes of the hour (0 or more). Attribute month : int property readonly \u00b6 The month of the year (0 or more). Attribute monthName : str property readonly \u00b6 The name of the month. Attribute monthSindarin : str property readonly \u00b6 The name of the month in Sindarin. Attribute monthWestron : str property readonly \u00b6 The name of the month in Westron. Attribute overallDay : int property readonly \u00b6 The sum of all the elapsed years in days and the day of year (1 or more). Attribute rlHoursUntilSeason : int property readonly \u00b6 The real life hours until next season (1 or more). Attribute rlHoursUntilWinter : int property readonly \u00b6 The real life hours until next winter (0 or more). Attribute season : str property readonly \u00b6 The name of the season. Attribute weekday : str property readonly \u00b6 The name of the weekday. Attribute year : int property readonly \u00b6 The year. Function deltaToTime ( delta ) \u00b6 Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default delta int The delta. required Returns: Type Description Tuple[int, int, int, int, int] A tuple containing the Mume year, month, day, hour, and minutes. Source code in mapper\\clock.py def deltaToTime ( delta : int ) -> Tuple [ int , int , int , int , int ]: \"\"\" Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: delta: The delta. Returns: A tuple containing the Mume year, month, day, hour, and minutes. \"\"\" year = delta // MINUTES_PER_YEAR + FIRST_YEAR delta %= MINUTES_PER_YEAR month = delta // MINUTES_PER_MONTH # 0 - 11. delta %= MINUTES_PER_MONTH day = delta // MINUTES_PER_DAY + 1 # 1 - 30. delta %= MINUTES_PER_DAY hour = delta // MINUTES_PER_HOUR # 0 - 23. delta %= MINUTES_PER_HOUR minutes = delta # 0 - 59. return year , month , day , hour , minutes Function timeToDelta ( year , month , day , hour , minutes ) \u00b6 Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Returns: Type Description int The delta. Source code in mapper\\clock.py def timeToDelta ( year : int , month : int , day : int , hour : int , minutes : int ) -> int : \"\"\" Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). Returns: The delta. \"\"\" return ( ( year - FIRST_YEAR ) * MINUTES_PER_YEAR + month * MINUTES_PER_MONTH + ( day - 1 ) * MINUTES_PER_DAY + hour * MINUTES_PER_HOUR + minutes )","title":"clock.py"},{"location":"api/clock/#mapper.clock","text":"","title":"clock"},{"location":"api/clock/#mapper.clock.Clock","text":"","title":"Clock"},{"location":"api/clock/#mapper.clock.Clock.epoch","text":"The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset.","title":"epoch"},{"location":"api/clock/#mapper.clock.Clock.setTime","text":"Sets the Mume epoch from the current Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Source code in mapper\\clock.py def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta","title":"setTime()"},{"location":"api/clock/#mapper.clock.Clock.time","text":"Outputs information about the current Mume time. Parameters: Name Type Description Default action Optional[str] An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. None Returns: Type Description str The requested output. Source code in mapper\\clock.py def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info","title":"time()"},{"location":"api/clock/#mapper.clock.MumeTime","text":"","title":"MumeTime"},{"location":"api/clock/#mapper.clock.MumeTime.amPm","text":"The AM - PM value.","title":"amPm"},{"location":"api/clock/#mapper.clock.MumeTime.dawn","text":"The hour of dawn.","title":"dawn"},{"location":"api/clock/#mapper.clock.MumeTime.dawnDuskState","text":"A tuple containing the current state name, the next state name, and the game hours until next state.","title":"dawnDuskState"},{"location":"api/clock/#mapper.clock.MumeTime.day","text":"The day of the month (1 or more).","title":"day"},{"location":"api/clock/#mapper.clock.MumeTime.dayOfYear","text":"The day of the year (1 or more).","title":"dayOfYear"},{"location":"api/clock/#mapper.clock.MumeTime.daysSinceFullMoon","text":"The days since last full moon (0 or more).","title":"daysSinceFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.daysSinceMoonCycle","text":"The days since last moon cycle (0 or more).","title":"daysSinceMoonCycle"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilFullMoon","text":"The days until next full moon (1 or more).","title":"daysUntilFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilMoonCycle","text":"The days until next moon cycle (1 or more).","title":"daysUntilMoonCycle"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilSeason","text":"The days until next season (1 or more).","title":"daysUntilSeason"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilWinter","text":"The days until next winter (1 or more).","title":"daysUntilWinter"},{"location":"api/clock/#mapper.clock.MumeTime.delta","text":"The time as a delta.","title":"delta"},{"location":"api/clock/#mapper.clock.MumeTime.dusk","text":"The hour of dusk.","title":"dusk"},{"location":"api/clock/#mapper.clock.MumeTime.hour","text":"The hour of the day (0 or more).","title":"hour"},{"location":"api/clock/#mapper.clock.MumeTime.hourOfMoonRise","text":"The hour of day when the moon will rise (0 or more).","title":"hourOfMoonRise"},{"location":"api/clock/#mapper.clock.MumeTime.hourOfYear","text":"The hour of the year (0 or more).","title":"hourOfYear"},{"location":"api/clock/#mapper.clock.MumeTime.hoursSinceFullMoon","text":"The hours since last full moon (0 or more).","title":"hoursSinceFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.hoursUntilFullMoon","text":"The hours Until full moon (1 or more).","title":"hoursUntilFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.info","text":"A summery of information about this moment in Mume time.","title":"info"},{"location":"api/clock/#mapper.clock.MumeTime.minutes","text":"The minutes of the hour (0 or more).","title":"minutes"},{"location":"api/clock/#mapper.clock.MumeTime.month","text":"The month of the year (0 or more).","title":"month"},{"location":"api/clock/#mapper.clock.MumeTime.monthName","text":"The name of the month.","title":"monthName"},{"location":"api/clock/#mapper.clock.MumeTime.monthSindarin","text":"The name of the month in Sindarin.","title":"monthSindarin"},{"location":"api/clock/#mapper.clock.MumeTime.monthWestron","text":"The name of the month in Westron.","title":"monthWestron"},{"location":"api/clock/#mapper.clock.MumeTime.overallDay","text":"The sum of all the elapsed years in days and the day of year (1 or more).","title":"overallDay"},{"location":"api/clock/#mapper.clock.MumeTime.rlHoursUntilSeason","text":"The real life hours until next season (1 or more).","title":"rlHoursUntilSeason"},{"location":"api/clock/#mapper.clock.MumeTime.rlHoursUntilWinter","text":"The real life hours until next winter (0 or more).","title":"rlHoursUntilWinter"},{"location":"api/clock/#mapper.clock.MumeTime.season","text":"The name of the season.","title":"season"},{"location":"api/clock/#mapper.clock.MumeTime.weekday","text":"The name of the weekday.","title":"weekday"},{"location":"api/clock/#mapper.clock.MumeTime.year","text":"The year.","title":"year"},{"location":"api/clock/#mapper.clock.deltaToTime","text":"Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default delta int The delta. required Returns: Type Description Tuple[int, int, int, int, int] A tuple containing the Mume year, month, day, hour, and minutes. Source code in mapper\\clock.py def deltaToTime ( delta : int ) -> Tuple [ int , int , int , int , int ]: \"\"\" Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: delta: The delta. Returns: A tuple containing the Mume year, month, day, hour, and minutes. \"\"\" year = delta // MINUTES_PER_YEAR + FIRST_YEAR delta %= MINUTES_PER_YEAR month = delta // MINUTES_PER_MONTH # 0 - 11. delta %= MINUTES_PER_MONTH day = delta // MINUTES_PER_DAY + 1 # 1 - 30. delta %= MINUTES_PER_DAY hour = delta // MINUTES_PER_HOUR # 0 - 23. delta %= MINUTES_PER_HOUR minutes = delta # 0 - 59. return year , month , day , hour , minutes","title":"deltaToTime()"},{"location":"api/clock/#mapper.clock.timeToDelta","text":"Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Returns: Type Description int The delta. Source code in mapper\\clock.py def timeToDelta ( year : int , month : int , day : int , hour : int , minutes : int ) -> int : \"\"\" Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). Returns: The delta. \"\"\" return ( ( year - FIRST_YEAR ) * MINUTES_PER_YEAR + month * MINUTES_PER_MONTH + ( day - 1 ) * MINUTES_PER_DAY + hour * MINUTES_PER_HOUR + minutes )","title":"timeToDelta()"},{"location":"api/config/","text":"Module mapper.config \u00b6 Class Config \u00b6 Implements loading and saving of program configuration. Attribute name : str property readonly \u00b6 The name of the configuration. Method __init__ ( self , name = 'config' ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default name str The name of the configuration. 'config' Source code in mapper\\config.py def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . _name : str = name self . _config : Dict [ str , Any ] = dict () self . reload () Method clear ( self ) inherited \u00b6 D.clear() -> None. Remove all items from D. Source code in mapper\\config.py def clear ( self ): 'D.clear() -> None. Remove all items from D.' try : while True : self . popitem () except KeyError : pass Method get ( self , key , default = None ) inherited \u00b6 D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Source code in mapper\\config.py def get ( self , key , default = None ): 'D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.' try : return self [ key ] except KeyError : return default Method items ( self ) inherited \u00b6 D.items() -> a set-like object providing a view on D's items Source code in mapper\\config.py def items ( self ): \"D.items() -> a set-like object providing a view on D's items\" return ItemsView ( self ) Method keys ( self ) inherited \u00b6 D.keys() -> a set-like object providing a view on D's keys Source code in mapper\\config.py def keys ( self ): \"D.keys() -> a set-like object providing a view on D's keys\" return KeysView ( self ) Method pop ( self , key , default =< object object at 0x0000019811A77140 > ) inherited \u00b6 D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Source code in mapper\\config.py def pop ( self , key , default = __marker ): '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. ''' try : value = self [ key ] except KeyError : if default is self . __marker : raise return default else : del self [ key ] return value Method popitem ( self ) inherited \u00b6 D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. Source code in mapper\\config.py def popitem ( self ): '''D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. ''' try : key = next ( iter ( self )) except StopIteration : raise KeyError from None value = self [ key ] del self [ key ] return key , value Method reload ( self ) \u00b6 Reloads the configuration from disc. Source code in mapper\\config.py def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . name } .json\" )) Method save ( self ) \u00b6 Saves the configuration to disc. Source code in mapper\\config.py def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename : str = os . path . join ( DATA_DIRECTORY , f \" { self . name } .json\" ) with self . _configLock : with open ( filename , \"w\" , encoding = \"utf-8\" , newline = \" \\r\\n \" ) as fileObj : # Configuration should be stored using Windows style line endings (\\r\\n) # so the file can be viewed in Notepad. json . dump ( self . _config , fileObj , sort_keys = True , indent = 2 ) Method setdefault ( self , key , default = None ) inherited \u00b6 D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Source code in mapper\\config.py def setdefault ( self , key , default = None ): 'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D' try : return self [ key ] except KeyError : self [ key ] = default return default Method update ( * args , ** kwds ) inherited \u00b6 D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Source code in mapper\\config.py def update ( * args , ** kwds ): ''' D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v ''' if not args : raise TypeError ( \"descriptor 'update' of 'MutableMapping' object \" \"needs an argument\" ) self , * args = args if len ( args ) > 1 : raise TypeError ( 'update expected at most 1 arguments, got %d ' % len ( args )) if args : other = args [ 0 ] if isinstance ( other , Mapping ): for key in other : self [ key ] = other [ key ] elif hasattr ( other , \"keys\" ): for key in other . keys (): self [ key ] = other [ key ] else : for key , value in other : self [ key ] = value for key , value in kwds . items (): self [ key ] = value Method values ( self ) inherited \u00b6 D.values() -> an object providing a view on D's values Source code in mapper\\config.py def values ( self ): \"D.values() -> an object providing a view on D's values\" return ValuesView ( self ) Class ConfigError \u00b6 Implements the base class for Config exceptions.","title":"config.py"},{"location":"api/config/#mapper.config","text":"","title":"config"},{"location":"api/config/#mapper.config.Config","text":"Implements loading and saving of program configuration.","title":"Config"},{"location":"api/config/#mapper.config.Config.name","text":"The name of the configuration.","title":"name"},{"location":"api/config/#mapper.config.Config.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default name str The name of the configuration. 'config' Source code in mapper\\config.py def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . _name : str = name self . _config : Dict [ str , Any ] = dict () self . reload ()","title":"__init__()"},{"location":"api/config/#mapper.config.Config.clear","text":"D.clear() -> None. Remove all items from D. Source code in mapper\\config.py def clear ( self ): 'D.clear() -> None. Remove all items from D.' try : while True : self . popitem () except KeyError : pass","title":"clear()"},{"location":"api/config/#mapper.config.Config.get","text":"D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Source code in mapper\\config.py def get ( self , key , default = None ): 'D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.' try : return self [ key ] except KeyError : return default","title":"get()"},{"location":"api/config/#mapper.config.Config.items","text":"D.items() -> a set-like object providing a view on D's items Source code in mapper\\config.py def items ( self ): \"D.items() -> a set-like object providing a view on D's items\" return ItemsView ( self )","title":"items()"},{"location":"api/config/#mapper.config.Config.keys","text":"D.keys() -> a set-like object providing a view on D's keys Source code in mapper\\config.py def keys ( self ): \"D.keys() -> a set-like object providing a view on D's keys\" return KeysView ( self )","title":"keys()"},{"location":"api/config/#mapper.config.Config.pop","text":"D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Source code in mapper\\config.py def pop ( self , key , default = __marker ): '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. ''' try : value = self [ key ] except KeyError : if default is self . __marker : raise return default else : del self [ key ] return value","title":"pop()"},{"location":"api/config/#mapper.config.Config.popitem","text":"D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. Source code in mapper\\config.py def popitem ( self ): '''D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. ''' try : key = next ( iter ( self )) except StopIteration : raise KeyError from None value = self [ key ] del self [ key ] return key , value","title":"popitem()"},{"location":"api/config/#mapper.config.Config.reload","text":"Reloads the configuration from disc. Source code in mapper\\config.py def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . name } .json\" ))","title":"reload()"},{"location":"api/config/#mapper.config.Config.save","text":"Saves the configuration to disc. Source code in mapper\\config.py def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename : str = os . path . join ( DATA_DIRECTORY , f \" { self . name } .json\" ) with self . _configLock : with open ( filename , \"w\" , encoding = \"utf-8\" , newline = \" \\r\\n \" ) as fileObj : # Configuration should be stored using Windows style line endings (\\r\\n) # so the file can be viewed in Notepad. json . dump ( self . _config , fileObj , sort_keys = True , indent = 2 )","title":"save()"},{"location":"api/config/#mapper.config.Config.setdefault","text":"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Source code in mapper\\config.py def setdefault ( self , key , default = None ): 'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D' try : return self [ key ] except KeyError : self [ key ] = default return default","title":"setdefault()"},{"location":"api/config/#mapper.config.Config.update","text":"D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Source code in mapper\\config.py def update ( * args , ** kwds ): ''' D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v ''' if not args : raise TypeError ( \"descriptor 'update' of 'MutableMapping' object \" \"needs an argument\" ) self , * args = args if len ( args ) > 1 : raise TypeError ( 'update expected at most 1 arguments, got %d ' % len ( args )) if args : other = args [ 0 ] if isinstance ( other , Mapping ): for key in other : self [ key ] = other [ key ] elif hasattr ( other , \"keys\" ): for key in other . keys (): self [ key ] = other [ key ] else : for key , value in other : self [ key ] = value for key , value in kwds . items (): self [ key ] = value","title":"update()"},{"location":"api/config/#mapper.config.Config.values","text":"D.values() -> an object providing a view on D's values Source code in mapper\\config.py def values ( self ): \"D.values() -> an object providing a view on D's values\" return ValuesView ( self )","title":"values()"},{"location":"api/config/#mapper.config.ConfigError","text":"Implements the base class for Config exceptions.","title":"ConfigError"},{"location":"api/delays/","text":"Module mapper.delays \u00b6 Class BaseDelay \u00b6 Implements the base delay class. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method __init__ ( self , duration , count , function , * args , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required count Union[int, None] The number of iterations to delay, or None to repeat indefinitely. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , count : Union [ int , None ], function : Callable [ ... , Any ], * args : Any , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon : bool = True self . _duration : float = duration self . _count : Union [ int , None ] = count self . _function : Callable [ ... , Any ] = function self . _args : Tuple [ Any , ... ] = args self . _kwargs : Dict [ str , Any ] = kwargs self . _finished : threading . Event = threading . Event () Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop () Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class Delay \u00b6 Implements a delay which automatically starts upon creation. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop () Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class OneShot \u00b6 Implements a delay which is run only once. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method __init__ ( self , duration , function , * args , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay. required function Callable[..., Any] The function to be called when the delay completes. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs ) Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop () Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class Repeating \u00b6 Implements a delay which runs indefinitely. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method __init__ ( self , duration , function , * args , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs ) Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop () Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"delays.py"},{"location":"api/delays/#mapper.delays","text":"","title":"delays"},{"location":"api/delays/#mapper.delays.BaseDelay","text":"Implements the base delay class.","title":"BaseDelay"},{"location":"api/delays/#mapper.delays.BaseDelay.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.BaseDelay.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.BaseDelay.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.BaseDelay.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required count Union[int, None] The number of iterations to delay, or None to repeat indefinitely. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , count : Union [ int , None ], function : Callable [ ... , Any ], * args : Any , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon : bool = True self . _duration : float = duration self . _count : Union [ int , None ] = count self . _function : Callable [ ... , Any ] = function self . _args : Tuple [ Any , ... ] = args self . _kwargs : Dict [ str , Any ] = kwargs self . _finished : threading . Event = threading . Event ()","title":"__init__()"},{"location":"api/delays/#mapper.delays.BaseDelay.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.BaseDelay.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.BaseDelay.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.BaseDelay.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.BaseDelay.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.BaseDelay.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.Delay","text":"Implements a delay which automatically starts upon creation.","title":"Delay"},{"location":"api/delays/#mapper.delays.Delay.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.Delay.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.Delay.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.Delay.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.Delay.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.Delay.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.Delay.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.Delay.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.Delay.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.OneShot","text":"Implements a delay which is run only once.","title":"OneShot"},{"location":"api/delays/#mapper.delays.OneShot.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.OneShot.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.OneShot.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.OneShot.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay. required function Callable[..., Any] The function to be called when the delay completes. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs )","title":"__init__()"},{"location":"api/delays/#mapper.delays.OneShot.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.OneShot.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.OneShot.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.OneShot.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.OneShot.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.OneShot.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.Repeating","text":"Implements a delay which runs indefinitely.","title":"Repeating"},{"location":"api/delays/#mapper.delays.Repeating.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.Repeating.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.Repeating.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.Repeating.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs )","title":"__init__()"},{"location":"api/delays/#mapper.delays.Repeating.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.Repeating.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.Repeating.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.Repeating.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.Repeating.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.Repeating.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/main/","text":"Module mapper.main \u00b6 Class Game \u00b6 Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except FakeSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Class Player \u00b6 Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"main.py"},{"location":"api/main/#mapper.main","text":"","title":"main"},{"location":"api/main/#mapper.main.Game","text":"","title":"Game"},{"location":"api/main/#mapper.main.Game.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/main/#mapper.main.Game.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/main/#mapper.main.Game.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/main/#mapper.main.Game.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/main/#mapper.main.Game.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/main/#mapper.main.Game.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/main/#mapper.main.Game.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except FakeSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None )","title":"run()"},{"location":"api/main/#mapper.main.Game.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/main/#mapper.main.Player","text":"","title":"Player"},{"location":"api/main/#mapper.main.Player.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/main/#mapper.main.Player.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/main/#mapper.main.Player.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/main/#mapper.main.Player.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/main/#mapper.main.Player.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/main/#mapper.main.Player.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/main/#mapper.main.Player.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" )","title":"run()"},{"location":"api/main/#mapper.main.Player.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/mapper/","text":"Module mapper.mapper \u00b6 Class Mapper \u00b6 Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method createSpeedWalk ( self , directionsList ) inherited \u00b6 Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\mapper.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> List [ str ]: speedWalkDirs : List [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : List [ str ] = [] directionsBuffer : List [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" Method deregisterMudEventHandler ( self , event , handler ) \u00b6 Deregisters mud event handlers. params: same as registerMudEventHandler. Source code in mapper\\mapper.py def deregisterMudEventHandler ( self , event : str , handler : Callable [[ str ], None ]) -> None : \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) if not self . mudEventHandlers [ event ]: del self . mudEventHandlers [ event ] Method emulate_leave ( self , direction , * args ) \u00b6 emulates leaving the room into a neighbouring room Source code in mapper\\mapper.py def emulate_leave ( self , direction : str , * args : str ) -> Tuple [ str , ... ]: \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return args vnum : str = self . emulationRoom . exits [ direction ] . to if vnum == \"death\" : self . output ( \"deathtrap!\" ) elif vnum == \"undefined\" : self . output ( \"undefined\" ) else : self . emulation_command_go ( vnum , isJump = False ) return args Method emulation_command_at ( self , * args ) \u00b6 mimic the /at command that the ainur use. Syntax: at (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_at ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () command : str = \" \" . join ( args [ 1 :]) . strip () if not label : self . sendPlayer ( \"Please provide a room in which to execute commands.\" ) else : room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is None : pass # Alternative suggestions were sent by the call to `getRoomFromLabel`. elif not command : self . sendPlayer ( f \"What do you want to do at { label } ?\" ) else : # Execute command at room. oldRoom : Room = self . emulationRoom self . emulationRoom = room self . user_command_emu ( command ) self . emulationRoom = oldRoom return () Method emulation_command_brief ( self , * args ) \u00b6 toggles brief mode. Source code in mapper\\mapper.py def emulation_command_brief ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) return args Method emulation_command_dynamic ( self , * args ) \u00b6 toggles automatic speaking of dynamic descs. Source code in mapper\\mapper.py def emulation_command_dynamic ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"toggles automatic speaking of dynamic descs.\"\"\" self . isEmulatingDynamicDescs = not self . isEmulatingDynamicDescs self . sendPlayer ( f \"dynamic descs { 'on' if self . isEmulatingDynamicDescs else 'off' } \" ) return args Method emulation_command_examine ( self , * args ) \u00b6 shows the room's description. Source code in mapper\\mapper.py def emulation_command_examine ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) return args Method emulation_command_exits ( self , * args ) \u00b6 shows the exits in the room. Source code in mapper\\mapper.py def emulation_command_exits ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"shows the exits in the room.\"\"\" exits : List [ str ] = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) return args Method emulation_command_go ( self , * args , * , isJump = True ) \u00b6 mimic the /go command that the ainur use. Syntax: go (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_go ( self , * args : str , isJump : bool = True ) -> Tuple [ str , ... ]: \"\"\"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () args = args [ 1 :] room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is not None : self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room . vnum return args Method emulation_command_help ( self , * args ) \u00b6 Shows documentation for mapper's emulation commands. Source code in mapper\\mapper.py def emulation_command_help ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts : List [ Tuple [ str , str ]] = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs : List [ Tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : List [ Tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : List [ str ] = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) return args Method emulation_command_look ( self , * args ) \u00b6 looks at the room. Source code in mapper\\mapper.py def emulation_command_look ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) if self . isEmulatingDynamicDescs : self . sendPlayer ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) return args Method emulation_command_quit ( self , * args ) \u00b6 Exits the program. Source code in mapper\\mapper.py def emulation_command_quit ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) return args Method emulation_command_rename ( self , * args ) \u00b6 changes the room name. (useful for exploring places with many similar names) Source code in mapper\\mapper.py def emulation_command_rename ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"changes the room name. (useful for exploring places with many similar names)\"\"\" name : str = \" \" . join ( args ) . strip () if name : self . emulationRoom . name = name self . sendPlayer ( f \"Room name set to ' { name } '.\" ) else : self . sendPlayer ( \"Error: You must specify a new room name.\" ) return () Method emulation_command_return ( self , * args ) \u00b6 returns to the last room jumped to with the go command. Source code in mapper\\mapper.py def emulation_command_return ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump is not None : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) return args Method emulation_command_sync ( self , * args ) \u00b6 When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. Source code in mapper\\mapper.py def emulation_command_sync ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom . vnum ) return args Method getNeighborsFromCoordinates ( self , start , radius ) inherited \u00b6 A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNeighborsFromRoom ( self , start , radius ) inherited \u00b6 A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNewExit ( self , direction , to = 'undefined' , vnum = None ) inherited \u00b6 Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\mapper.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit Method GUIRefresh ( self ) inherited \u00b6 Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\mapper.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,)) Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\mapper.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\mapper.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method isBidirectional ( self , exitObj ) inherited \u00b6 Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\mapper.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\mapper.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method pathFind ( self , origin = None , destination = None , flags = None ) inherited \u00b6 Find the path Source code in mapper\\mapper.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> List [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : FrozenSet [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : FrozenSet [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc ) Method registerMudEventHandler ( self , event , handler ) \u00b6 Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. Source code in mapper\\mapper.py def registerMudEventHandler ( self , event : str , handler : Callable [[ str ], None ]) -> None : \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () if event in self . unknownMudEvents : self . unknownMudEvents . remove ( event ) self . mudEventHandlers [ event ] . add ( handler ) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\mapper.py def run ( self ) -> None : item : EVENT_CALLER_TYPE for item in iter ( self . queue . get , None ): try : event , data = item if event == \"userInput\" : self . handleUserData ( data ) else : self . handleMudEvent ( * item ) except Exception : self . output ( f \"Error in mapper thread: \\n { traceback . format_exc () . strip () } \" ) logger . exception ( \"Error in mapper thread\" ) self . sendPlayer ( \"Exiting mapper thread.\" ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\mapper.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method user_command_maphelp ( self , * args ) \u00b6 Shows documentation for mapper commands Source code in mapper\\mapper.py def user_command_maphelp ( self , * args : str ) -> None : \"\"\"Shows documentation for mapper commands\"\"\" helpTexts : List [ Tuple [ str , str ]] = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs : List [ Tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : List [ Tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : List [ str ] = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) Method user_command_tvnum ( self , * args ) \u00b6 tells a given char the vnum of your room Source code in mapper\\mapper.py def user_command_tvnum ( self , * args : str ) -> None : \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" ) Method user_command_vnum ( self , * args ) \u00b6 states the vnum of the current room Source code in mapper\\mapper.py def user_command_vnum ( self , * args : str ) -> None : \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" )","title":"mapper.py"},{"location":"api/mapper/#mapper.mapper","text":"","title":"mapper"},{"location":"api/mapper/#mapper.mapper.Mapper","text":"","title":"Mapper"},{"location":"api/mapper/#mapper.mapper.Mapper.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/mapper/#mapper.mapper.Mapper.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/mapper/#mapper.mapper.Mapper.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/mapper/#mapper.mapper.Mapper.createSpeedWalk","text":"Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\mapper.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> List [ str ]: speedWalkDirs : List [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : List [ str ] = [] directionsBuffer : List [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \"","title":"createSpeedWalk()"},{"location":"api/mapper/#mapper.mapper.Mapper.deregisterMudEventHandler","text":"Deregisters mud event handlers. params: same as registerMudEventHandler. Source code in mapper\\mapper.py def deregisterMudEventHandler ( self , event : str , handler : Callable [[ str ], None ]) -> None : \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) if not self . mudEventHandlers [ event ]: del self . mudEventHandlers [ event ]","title":"deregisterMudEventHandler()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulate_leave","text":"emulates leaving the room into a neighbouring room Source code in mapper\\mapper.py def emulate_leave ( self , direction : str , * args : str ) -> Tuple [ str , ... ]: \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return args vnum : str = self . emulationRoom . exits [ direction ] . to if vnum == \"death\" : self . output ( \"deathtrap!\" ) elif vnum == \"undefined\" : self . output ( \"undefined\" ) else : self . emulation_command_go ( vnum , isJump = False ) return args","title":"emulate_leave()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_at","text":"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_at ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () command : str = \" \" . join ( args [ 1 :]) . strip () if not label : self . sendPlayer ( \"Please provide a room in which to execute commands.\" ) else : room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is None : pass # Alternative suggestions were sent by the call to `getRoomFromLabel`. elif not command : self . sendPlayer ( f \"What do you want to do at { label } ?\" ) else : # Execute command at room. oldRoom : Room = self . emulationRoom self . emulationRoom = room self . user_command_emu ( command ) self . emulationRoom = oldRoom return ()","title":"emulation_command_at()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_brief","text":"toggles brief mode. Source code in mapper\\mapper.py def emulation_command_brief ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) return args","title":"emulation_command_brief()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_dynamic","text":"toggles automatic speaking of dynamic descs. Source code in mapper\\mapper.py def emulation_command_dynamic ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"toggles automatic speaking of dynamic descs.\"\"\" self . isEmulatingDynamicDescs = not self . isEmulatingDynamicDescs self . sendPlayer ( f \"dynamic descs { 'on' if self . isEmulatingDynamicDescs else 'off' } \" ) return args","title":"emulation_command_dynamic()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_examine","text":"shows the room's description. Source code in mapper\\mapper.py def emulation_command_examine ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) return args","title":"emulation_command_examine()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_exits","text":"shows the exits in the room. Source code in mapper\\mapper.py def emulation_command_exits ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"shows the exits in the room.\"\"\" exits : List [ str ] = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) return args","title":"emulation_command_exits()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_go","text":"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_go ( self , * args : str , isJump : bool = True ) -> Tuple [ str , ... ]: \"\"\"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () args = args [ 1 :] room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is not None : self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room . vnum return args","title":"emulation_command_go()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_help","text":"Shows documentation for mapper's emulation commands. Source code in mapper\\mapper.py def emulation_command_help ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts : List [ Tuple [ str , str ]] = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs : List [ Tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : List [ Tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : List [ str ] = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) return args","title":"emulation_command_help()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_look","text":"looks at the room. Source code in mapper\\mapper.py def emulation_command_look ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) if self . isEmulatingDynamicDescs : self . sendPlayer ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) return args","title":"emulation_command_look()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_quit","text":"Exits the program. Source code in mapper\\mapper.py def emulation_command_quit ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) return args","title":"emulation_command_quit()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_rename","text":"changes the room name. (useful for exploring places with many similar names) Source code in mapper\\mapper.py def emulation_command_rename ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"changes the room name. (useful for exploring places with many similar names)\"\"\" name : str = \" \" . join ( args ) . strip () if name : self . emulationRoom . name = name self . sendPlayer ( f \"Room name set to ' { name } '.\" ) else : self . sendPlayer ( \"Error: You must specify a new room name.\" ) return ()","title":"emulation_command_rename()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_return","text":"returns to the last room jumped to with the go command. Source code in mapper\\mapper.py def emulation_command_return ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump is not None : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) return args","title":"emulation_command_return()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_sync","text":"When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. Source code in mapper\\mapper.py def emulation_command_sync ( self , * args : str ) -> Tuple [ str , ... ]: \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom . vnum ) return args","title":"emulation_command_sync()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNeighborsFromCoordinates","text":"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromCoordinates()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNeighborsFromRoom","text":"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromRoom()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNewExit","text":"Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\mapper.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit","title":"getNewExit()"},{"location":"api/mapper/#mapper.mapper.Mapper.GUIRefresh","text":"Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\mapper.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,))","title":"GUIRefresh()"},{"location":"api/mapper/#mapper.mapper.Mapper.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\mapper.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/mapper/#mapper.mapper.Mapper.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\mapper.py def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/mapper/#mapper.mapper.Mapper.isBidirectional","text":"Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\mapper.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False","title":"isBidirectional()"},{"location":"api/mapper/#mapper.mapper.Mapper.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\mapper.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/mapper/#mapper.mapper.Mapper.pathFind","text":"Find the path Source code in mapper\\mapper.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> List [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : FrozenSet [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : FrozenSet [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"pathFind()"},{"location":"api/mapper/#mapper.mapper.Mapper.registerMudEventHandler","text":"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. Source code in mapper\\mapper.py def registerMudEventHandler ( self , event : str , handler : Callable [[ str ], None ]) -> None : \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () if event in self . unknownMudEvents : self . unknownMudEvents . remove ( event ) self . mudEventHandlers [ event ] . add ( handler )","title":"registerMudEventHandler()"},{"location":"api/mapper/#mapper.mapper.Mapper.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\mapper.py def run ( self ) -> None : item : EVENT_CALLER_TYPE for item in iter ( self . queue . get , None ): try : event , data = item if event == \"userInput\" : self . handleUserData ( data ) else : self . handleMudEvent ( * item ) except Exception : self . output ( f \"Error in mapper thread: \\n { traceback . format_exc () . strip () } \" ) logger . exception ( \"Error in mapper thread\" ) self . sendPlayer ( \"Exiting mapper thread.\" )","title":"run()"},{"location":"api/mapper/#mapper.mapper.Mapper.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\mapper.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_maphelp","text":"Shows documentation for mapper commands Source code in mapper\\mapper.py def user_command_maphelp ( self , * args : str ) -> None : \"\"\"Shows documentation for mapper commands\"\"\" helpTexts : List [ Tuple [ str , str ]] = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs : List [ Tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : List [ Tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : List [ str ] = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result ))","title":"user_command_maphelp()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_tvnum","text":"tells a given char the vnum of your room Source code in mapper\\mapper.py def user_command_tvnum ( self , * args : str ) -> None : \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" )","title":"user_command_tvnum()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_vnum","text":"states the vnum of the current room Source code in mapper\\mapper.py def user_command_vnum ( self , * args : str ) -> None : \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" )","title":"user_command_vnum()"},{"location":"api/mudevents/","text":"Module mapper.mudevents \u00b6 Class Handler \u00b6 Method __init__ ( self , mapper , event = None ) special \u00b6 Initialises a mud event handler in the given mapper instance. Parameters: Name Type Description Default mapper Mapper An instance of mapper.mapper.Mapper that dispatches events. required event Optional[str] The event name. May be omitted if the subclass defines an event attribute. None Source code in mapper\\mudevents.py def __init__ ( self , mapper : Mapper , event : Optional [ str ] = None ) -> None : \"\"\" Initialises a mud event handler in the given mapper instance. Args: mapper: An instance of mapper.mapper.Mapper that dispatches events. event: The event name. May be omitted if the subclass defines an event attribute. \"\"\" self . mapper = mapper if event : self . event = event elif not hasattr ( self , \"event\" ): raise ValueError ( \"Tried to initialise handler without an event type.\" + \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) self . mapper . registerMudEventHandler ( self . event , self . handle ) Method handle ( self , text ) \u00b6 Called when the event is dispatched. Source code in mapper\\mudevents.py @abstractmethod def handle ( self , text : str ) -> None : \"\"\"Called when the event is dispatched.\"\"\"","title":"mudevents.py"},{"location":"api/mudevents/#mapper.mudevents","text":"","title":"mudevents"},{"location":"api/mudevents/#mapper.mudevents.Handler","text":"","title":"Handler"},{"location":"api/mudevents/#mapper.mudevents.Handler.__init__","text":"Initialises a mud event handler in the given mapper instance. Parameters: Name Type Description Default mapper Mapper An instance of mapper.mapper.Mapper that dispatches events. required event Optional[str] The event name. May be omitted if the subclass defines an event attribute. None Source code in mapper\\mudevents.py def __init__ ( self , mapper : Mapper , event : Optional [ str ] = None ) -> None : \"\"\" Initialises a mud event handler in the given mapper instance. Args: mapper: An instance of mapper.mapper.Mapper that dispatches events. event: The event name. May be omitted if the subclass defines an event attribute. \"\"\" self . mapper = mapper if event : self . event = event elif not hasattr ( self , \"event\" ): raise ValueError ( \"Tried to initialise handler without an event type.\" + \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) self . mapper . registerMudEventHandler ( self . event , self . handle )","title":"__init__()"},{"location":"api/mudevents/#mapper.mudevents.Handler.handle","text":"Called when the event is dispatched. Source code in mapper\\mudevents.py @abstractmethod def handle ( self , text : str ) -> None : \"\"\"Called when the event is dispatched.\"\"\"","title":"handle()"},{"location":"api/utils/","text":"Module mapper.utils \u00b6 Function camelCase ( text , delimiter ) \u00b6 converts text to camel case. Parameters: Name Type Description Default text str The text to be converted. required delimiter str The delimiter between words. required Returns: Type Description str The text in camel case. Source code in mapper\\utils.py def camelCase ( text : str , delimiter : str ) -> str : \"\"\" converts text to camel case. Args: text: The text to be converted. delimiter: The delimiter between words. Returns: The text in camel case. \"\"\" words = text . split ( delimiter ) return \"\" . join (( * map ( str . lower , words [: 1 ]), * map ( str . title , words [ 1 :]))) Function decodeBytes ( data ) \u00b6 Decodes UTF-8 or Latin-1 bytes into a string. Parameters: Name Type Description Default data bytes The data to be decoded. required Returns: Type Description str The decoded string. Source code in mapper\\utils.py def decodeBytes ( data : bytes ) -> str : \"\"\" Decodes UTF-8 or Latin-1 bytes into a string. Args: data: The data to be decoded. Returns: The decoded string. \"\"\" if not isinstance ( data , ByteString ): raise TypeError ( \"Data must be a bytes-like object.\" ) try : return data . decode ( \"utf-8\" ) except UnicodeDecodeError : return data . decode ( \"latin-1\" ) Function formatDocString ( functionOrString , width = 79 , prefix = None ) \u00b6 Formats a docstring for displaying. Parameters: Name Type Description Default functionOrString Union[str, Callable[..., Any]] The function containing the docstring, or the docstring its self. required width int The number of characters to word wrap each line to. 79 prefix Optional[str] One or more characters to use for indention. None Returns: Type Description str The formatted docstring. Source code in mapper\\utils.py def formatDocString ( functionOrString : Union [ str , Callable [ ... , Any ]], width : int = 79 , prefix : Optional [ str ] = None ) -> str : \"\"\" Formats a docstring for displaying. Args: functionOrString: The function containing the docstring, or the docstring its self. width: The number of characters to word wrap each line to. prefix: One or more characters to use for indention. Returns: The formatted docstring. \"\"\" if callable ( functionOrString ): # It's a function. docString = getattr ( functionOrString , \"__doc__\" ) or \"\" else : # It's a string. docString = functionOrString # Remove any empty lines from the beginning, while keeping indention. docString = docString . lstrip ( \" \\r\\n \" ) match = INDENT_REGEX . search ( docString ) if match is not None and not match . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): match = INDENT_REGEX . search ( line ) if match is None : # pragma: no cover continue indent , text = match . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix if prefix is not None else \"\" ) # Indent docstring lines with the prefix. return docString Function getDirectoryPath ( * args ) \u00b6 Retrieves the path of the directory where the program is located. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the directory path. () Returns: Type Description str The path. Source code in mapper\\utils.py def getDirectoryPath ( * args : str ) -> str : \"\"\" Retrieves the path of the directory where the program is located. Args: *args: Positional arguments to be passed to os.join after the directory path. Returns: The path. \"\"\" if isFrozen (): path = os . path . dirname ( sys . executable ) else : path = os . path . join ( os . path . dirname ( __file__ ), os . path . pardir ) return os . path . realpath ( os . path . join ( path , * args )) Function getFreezer () \u00b6 Determines the name of the library used to freeze the code. Note https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: Type Description Union[str, None] The name of the library or None. Source code in mapper\\utils.py def getFreezer () -> Union [ str , None ]: \"\"\" Determines the name of the library used to freeze the code. Note: https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: The name of the library or None. \"\"\" frozen : Union [ str , bool , None ] = getattr ( sys , \"frozen\" , None ) if frozen and hasattr ( sys , \"_MEIPASS\" ): return \"pyinstaller\" elif frozen is True : return \"cx_freeze\" elif frozen in ( \"windows_exe\" , \"console_exe\" , \"dll\" ): return \"py2exe\" elif frozen == \"macosx_app\" : return \"py2app\" elif hasattr ( sys , \"importers\" ): return \"old_py2exe\" elif _imp . is_frozen ( \"__main__\" ): return \"tools/freeze\" elif isinstance ( frozen , str ): return f \"unknown { frozen } \" return None Function humanSort ( lst ) \u00b6 Sorts a list of strings, with numbers sorted according to their numeric value. Parameters: Name Type Description Default lst Sequence[str] The list of strings to be sorted. required Returns: Type Description List[str] The items of the list, with strings containing numbers sorted according to their numeric value. Source code in mapper\\utils.py def humanSort ( lst : Sequence [ str ]) -> List [ str ]: \"\"\" Sorts a list of strings, with numbers sorted according to their numeric value. Args: lst: The list of strings to be sorted. Returns: The items of the list, with strings containing numbers sorted according to their numeric value. \"\"\" return sorted ( lst , key = lambda item : [ int ( text ) if text . isdigit () else text for text in re . split ( r \"(\\d+)\" , item , re . UNICODE ) ], ) Function isFrozen () \u00b6 Determines whether the program is running from a frozen copy or from source. Returns: Type Description bool True if frozen, False otherwise. Source code in mapper\\utils.py def isFrozen () -> bool : \"\"\" Determines whether the program is running from a frozen copy or from source. Returns: True if frozen, False otherwise. \"\"\" return bool ( getFreezer ()) Function lpadList ( lst , padding , count , fixed = False ) \u00b6 Pad the left side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description List[Any] A padded copy of the list. Source code in mapper\\utils.py def lpadList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> List [ Any ]: \"\"\" Pad the left side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * [ padding ] * ( count - len ( lst )), * lst ][: count ] else : return [ * [ padding ] * ( count - len ( lst )), * lst ] Function minIndent ( text ) \u00b6 Retrieves the indention characters from the line with the least indention. Parameters: Name Type Description Default text str the text to process. required Returns: Type Description str The indention characters of the line with the least amount of indention. Source code in mapper\\utils.py def minIndent ( text : str ) -> str : \"\"\" Retrieves the indention characters from the line with the least indention. Args: text: the text to process. Returns: The indention characters of the line with the least amount of indention. \"\"\" lines = [] for line in text . splitlines (): if line . strip ( \" \\r\\n \" ): match = INDENT_REGEX . search ( line ) if match is not None : lines . append ( match . group ( \"indent\" )) return min ( lines , default = \"\" , key = len ) Function padList ( lst , padding , count , fixed = False ) \u00b6 Pad the right side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description List[Any] A padded copy of the list. Source code in mapper\\utils.py def padList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> List [ Any ]: \"\"\" Pad the right side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * lst , * [ padding ] * ( count - len ( lst ))][: count ] else : return [ * lst , * [ padding ] * ( count - len ( lst ))] Function page ( lines ) \u00b6 Displays lines using the pager if necessary. Parameters: Name Type Description Default lines Sequence[str] The lines to be displayed. required Source code in mapper\\utils.py def page ( lines : Sequence [ str ]) -> None : \"\"\" Displays lines using the pager if necessary. Args: lines: The lines to be displayed. \"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text ) Function regexFuzzy ( text ) \u00b6 Creates a regular expression matching all or part of a string or sequence. Parameters: Name Type Description Default text Union[str, Sequence[str]] The text to be converted. required Returns: Type Description str A regular expression string matching all or part of the text. Source code in mapper\\utils.py def regexFuzzy ( text : Union [ str , Sequence [ str ]]) -> str : \"\"\" Creates a regular expression matching all or part of a string or sequence. Args: text: The text to be converted. Returns: A regular expression string matching all or part of the text. \"\"\" if not isinstance ( text , ( str , Sequence )): raise TypeError ( \"Text must be either a string or sequence of strings.\" ) elif not text : return \"\" elif isinstance ( text , str ): return \"(\" . join ( list ( text )) + \")?\" * ( len ( text ) - 1 ) else : return \"|\" . join ( \"(\" . join ( list ( item )) + \")?\" * ( len ( item ) - 1 ) for item in text ) Function roundHalfAwayFromZero ( number , decimals = 0 ) \u00b6 Rounds a float away from 0 if the fractional is 5 or more. Note https://realpython.com/python-rounding Parameters: Name Type Description Default number float The number to round. required decimals int The number of fractional decimal places to round to. 0 Returns: Type Description float The number after rounding. Source code in mapper\\utils.py def roundHalfAwayFromZero ( number : float , decimals : int = 0 ) -> float : \"\"\" Rounds a float away from 0 if the fractional is 5 or more. Note: https://realpython.com/python-rounding Args: number: The number to round. decimals: The number of fractional decimal places to round to. Returns: The number after rounding. \"\"\" multiplier = 10 ** decimals return math . copysign ( math . floor ( abs ( number ) * multiplier + 0.5 ) / multiplier , number ) Function simplified ( text ) \u00b6 Replaces one or more consecutive white space characters with a single space. Parameters: Name Type Description Default text str The text to process. required Returns: Type Description str The simplified version of the text. Source code in mapper\\utils.py def simplified ( text : str ) -> str : \"\"\" Replaces one or more consecutive white space characters with a single space. Args: text: The text to process. Returns: The simplified version of the text. \"\"\" return WHITE_SPACE_REGEX . sub ( \" \" , text ) . strip () Function stripAnsi ( text ) \u00b6 Strips ANSI escape sequences from text. Parameters: Name Type Description Default text str The text to strip ANSI sequences from. required Returns: Type Description str The text with ANSI escape sequences stripped. Source code in mapper\\utils.py def stripAnsi ( text : str ) -> str : \"\"\" Strips ANSI escape sequences from text. Args: text: The text to strip ANSI sequences from. Returns: The text with ANSI escape sequences stripped. \"\"\" return ANSI_COLOR_REGEX . sub ( \"\" , text ) Function touch ( name ) \u00b6 Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Parameters: Name Type Description Default name str the file name to touch. required Source code in mapper\\utils.py def touch ( name : str ) -> None : \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Args: name: the file name to touch. \"\"\" with open ( name , \"a\" ): os . utime ( name , None )","title":"utils.py"},{"location":"api/utils/#mapper.utils","text":"","title":"utils"},{"location":"api/utils/#mapper.utils.camelCase","text":"converts text to camel case. Parameters: Name Type Description Default text str The text to be converted. required delimiter str The delimiter between words. required Returns: Type Description str The text in camel case. Source code in mapper\\utils.py def camelCase ( text : str , delimiter : str ) -> str : \"\"\" converts text to camel case. Args: text: The text to be converted. delimiter: The delimiter between words. Returns: The text in camel case. \"\"\" words = text . split ( delimiter ) return \"\" . join (( * map ( str . lower , words [: 1 ]), * map ( str . title , words [ 1 :])))","title":"camelCase()"},{"location":"api/utils/#mapper.utils.decodeBytes","text":"Decodes UTF-8 or Latin-1 bytes into a string. Parameters: Name Type Description Default data bytes The data to be decoded. required Returns: Type Description str The decoded string. Source code in mapper\\utils.py def decodeBytes ( data : bytes ) -> str : \"\"\" Decodes UTF-8 or Latin-1 bytes into a string. Args: data: The data to be decoded. Returns: The decoded string. \"\"\" if not isinstance ( data , ByteString ): raise TypeError ( \"Data must be a bytes-like object.\" ) try : return data . decode ( \"utf-8\" ) except UnicodeDecodeError : return data . decode ( \"latin-1\" )","title":"decodeBytes()"},{"location":"api/utils/#mapper.utils.formatDocString","text":"Formats a docstring for displaying. Parameters: Name Type Description Default functionOrString Union[str, Callable[..., Any]] The function containing the docstring, or the docstring its self. required width int The number of characters to word wrap each line to. 79 prefix Optional[str] One or more characters to use for indention. None Returns: Type Description str The formatted docstring. Source code in mapper\\utils.py def formatDocString ( functionOrString : Union [ str , Callable [ ... , Any ]], width : int = 79 , prefix : Optional [ str ] = None ) -> str : \"\"\" Formats a docstring for displaying. Args: functionOrString: The function containing the docstring, or the docstring its self. width: The number of characters to word wrap each line to. prefix: One or more characters to use for indention. Returns: The formatted docstring. \"\"\" if callable ( functionOrString ): # It's a function. docString = getattr ( functionOrString , \"__doc__\" ) or \"\" else : # It's a string. docString = functionOrString # Remove any empty lines from the beginning, while keeping indention. docString = docString . lstrip ( \" \\r\\n \" ) match = INDENT_REGEX . search ( docString ) if match is not None and not match . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): match = INDENT_REGEX . search ( line ) if match is None : # pragma: no cover continue indent , text = match . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix if prefix is not None else \"\" ) # Indent docstring lines with the prefix. return docString","title":"formatDocString()"},{"location":"api/utils/#mapper.utils.getDirectoryPath","text":"Retrieves the path of the directory where the program is located. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the directory path. () Returns: Type Description str The path. Source code in mapper\\utils.py def getDirectoryPath ( * args : str ) -> str : \"\"\" Retrieves the path of the directory where the program is located. Args: *args: Positional arguments to be passed to os.join after the directory path. Returns: The path. \"\"\" if isFrozen (): path = os . path . dirname ( sys . executable ) else : path = os . path . join ( os . path . dirname ( __file__ ), os . path . pardir ) return os . path . realpath ( os . path . join ( path , * args ))","title":"getDirectoryPath()"},{"location":"api/utils/#mapper.utils.getFreezer","text":"Determines the name of the library used to freeze the code. Note https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: Type Description Union[str, None] The name of the library or None. Source code in mapper\\utils.py def getFreezer () -> Union [ str , None ]: \"\"\" Determines the name of the library used to freeze the code. Note: https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: The name of the library or None. \"\"\" frozen : Union [ str , bool , None ] = getattr ( sys , \"frozen\" , None ) if frozen and hasattr ( sys , \"_MEIPASS\" ): return \"pyinstaller\" elif frozen is True : return \"cx_freeze\" elif frozen in ( \"windows_exe\" , \"console_exe\" , \"dll\" ): return \"py2exe\" elif frozen == \"macosx_app\" : return \"py2app\" elif hasattr ( sys , \"importers\" ): return \"old_py2exe\" elif _imp . is_frozen ( \"__main__\" ): return \"tools/freeze\" elif isinstance ( frozen , str ): return f \"unknown { frozen } \" return None","title":"getFreezer()"},{"location":"api/utils/#mapper.utils.humanSort","text":"Sorts a list of strings, with numbers sorted according to their numeric value. Parameters: Name Type Description Default lst Sequence[str] The list of strings to be sorted. required Returns: Type Description List[str] The items of the list, with strings containing numbers sorted according to their numeric value. Source code in mapper\\utils.py def humanSort ( lst : Sequence [ str ]) -> List [ str ]: \"\"\" Sorts a list of strings, with numbers sorted according to their numeric value. Args: lst: The list of strings to be sorted. Returns: The items of the list, with strings containing numbers sorted according to their numeric value. \"\"\" return sorted ( lst , key = lambda item : [ int ( text ) if text . isdigit () else text for text in re . split ( r \"(\\d+)\" , item , re . UNICODE ) ], )","title":"humanSort()"},{"location":"api/utils/#mapper.utils.isFrozen","text":"Determines whether the program is running from a frozen copy or from source. Returns: Type Description bool True if frozen, False otherwise. Source code in mapper\\utils.py def isFrozen () -> bool : \"\"\" Determines whether the program is running from a frozen copy or from source. Returns: True if frozen, False otherwise. \"\"\" return bool ( getFreezer ())","title":"isFrozen()"},{"location":"api/utils/#mapper.utils.lpadList","text":"Pad the left side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description List[Any] A padded copy of the list. Source code in mapper\\utils.py def lpadList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> List [ Any ]: \"\"\" Pad the left side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * [ padding ] * ( count - len ( lst )), * lst ][: count ] else : return [ * [ padding ] * ( count - len ( lst )), * lst ]","title":"lpadList()"},{"location":"api/utils/#mapper.utils.minIndent","text":"Retrieves the indention characters from the line with the least indention. Parameters: Name Type Description Default text str the text to process. required Returns: Type Description str The indention characters of the line with the least amount of indention. Source code in mapper\\utils.py def minIndent ( text : str ) -> str : \"\"\" Retrieves the indention characters from the line with the least indention. Args: text: the text to process. Returns: The indention characters of the line with the least amount of indention. \"\"\" lines = [] for line in text . splitlines (): if line . strip ( \" \\r\\n \" ): match = INDENT_REGEX . search ( line ) if match is not None : lines . append ( match . group ( \"indent\" )) return min ( lines , default = \"\" , key = len )","title":"minIndent()"},{"location":"api/utils/#mapper.utils.padList","text":"Pad the right side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description List[Any] A padded copy of the list. Source code in mapper\\utils.py def padList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> List [ Any ]: \"\"\" Pad the right side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * lst , * [ padding ] * ( count - len ( lst ))][: count ] else : return [ * lst , * [ padding ] * ( count - len ( lst ))]","title":"padList()"},{"location":"api/utils/#mapper.utils.page","text":"Displays lines using the pager if necessary. Parameters: Name Type Description Default lines Sequence[str] The lines to be displayed. required Source code in mapper\\utils.py def page ( lines : Sequence [ str ]) -> None : \"\"\" Displays lines using the pager if necessary. Args: lines: The lines to be displayed. \"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text )","title":"page()"},{"location":"api/utils/#mapper.utils.regexFuzzy","text":"Creates a regular expression matching all or part of a string or sequence. Parameters: Name Type Description Default text Union[str, Sequence[str]] The text to be converted. required Returns: Type Description str A regular expression string matching all or part of the text. Source code in mapper\\utils.py def regexFuzzy ( text : Union [ str , Sequence [ str ]]) -> str : \"\"\" Creates a regular expression matching all or part of a string or sequence. Args: text: The text to be converted. Returns: A regular expression string matching all or part of the text. \"\"\" if not isinstance ( text , ( str , Sequence )): raise TypeError ( \"Text must be either a string or sequence of strings.\" ) elif not text : return \"\" elif isinstance ( text , str ): return \"(\" . join ( list ( text )) + \")?\" * ( len ( text ) - 1 ) else : return \"|\" . join ( \"(\" . join ( list ( item )) + \")?\" * ( len ( item ) - 1 ) for item in text )","title":"regexFuzzy()"},{"location":"api/utils/#mapper.utils.roundHalfAwayFromZero","text":"Rounds a float away from 0 if the fractional is 5 or more. Note https://realpython.com/python-rounding Parameters: Name Type Description Default number float The number to round. required decimals int The number of fractional decimal places to round to. 0 Returns: Type Description float The number after rounding. Source code in mapper\\utils.py def roundHalfAwayFromZero ( number : float , decimals : int = 0 ) -> float : \"\"\" Rounds a float away from 0 if the fractional is 5 or more. Note: https://realpython.com/python-rounding Args: number: The number to round. decimals: The number of fractional decimal places to round to. Returns: The number after rounding. \"\"\" multiplier = 10 ** decimals return math . copysign ( math . floor ( abs ( number ) * multiplier + 0.5 ) / multiplier , number )","title":"roundHalfAwayFromZero()"},{"location":"api/utils/#mapper.utils.simplified","text":"Replaces one or more consecutive white space characters with a single space. Parameters: Name Type Description Default text str The text to process. required Returns: Type Description str The simplified version of the text. Source code in mapper\\utils.py def simplified ( text : str ) -> str : \"\"\" Replaces one or more consecutive white space characters with a single space. Args: text: The text to process. Returns: The simplified version of the text. \"\"\" return WHITE_SPACE_REGEX . sub ( \" \" , text ) . strip ()","title":"simplified()"},{"location":"api/utils/#mapper.utils.stripAnsi","text":"Strips ANSI escape sequences from text. Parameters: Name Type Description Default text str The text to strip ANSI sequences from. required Returns: Type Description str The text with ANSI escape sequences stripped. Source code in mapper\\utils.py def stripAnsi ( text : str ) -> str : \"\"\" Strips ANSI escape sequences from text. Args: text: The text to strip ANSI sequences from. Returns: The text with ANSI escape sequences stripped. \"\"\" return ANSI_COLOR_REGEX . sub ( \"\" , text )","title":"stripAnsi()"},{"location":"api/utils/#mapper.utils.touch","text":"Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Parameters: Name Type Description Default name str the file name to touch. required Source code in mapper\\utils.py def touch ( name : str ) -> None : \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Args: name: the file name to touch. \"\"\" with open ( name , \"a\" ): os . utime ( name , None )","title":"touch()"},{"location":"api/world/","text":"Module mapper.world \u00b6 Class World \u00b6 Method createSpeedWalk ( self , directionsList ) \u00b6 Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\world.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> List [ str ]: speedWalkDirs : List [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : List [ str ] = [] directionsBuffer : List [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" Method getNeighborsFromCoordinates ( self , start , radius ) \u00b6 A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNeighborsFromRoom ( self , start , radius ) \u00b6 A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNewExit ( self , direction , to = 'undefined' , vnum = None ) \u00b6 Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\world.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit Method GUIRefresh ( self ) \u00b6 Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\world.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,)) Method isBidirectional ( self , exitObj ) \u00b6 Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\world.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False Method pathFind ( self , origin = None , destination = None , flags = None ) \u00b6 Find the path Source code in mapper\\world.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> List [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : FrozenSet [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : FrozenSet [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"world.py"},{"location":"api/world/#mapper.world","text":"","title":"world"},{"location":"api/world/#mapper.world.World","text":"","title":"World"},{"location":"api/world/#mapper.world.World.createSpeedWalk","text":"Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\world.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> List [ str ]: speedWalkDirs : List [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : List [ str ] = [] directionsBuffer : List [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \"","title":"createSpeedWalk()"},{"location":"api/world/#mapper.world.World.getNeighborsFromCoordinates","text":"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromCoordinates()"},{"location":"api/world/#mapper.world.World.getNeighborsFromRoom","text":"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ Tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromRoom()"},{"location":"api/world/#mapper.world.World.getNewExit","text":"Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\world.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit","title":"getNewExit()"},{"location":"api/world/#mapper.world.World.GUIRefresh","text":"Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\world.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,))","title":"GUIRefresh()"},{"location":"api/world/#mapper.world.World.isBidirectional","text":"Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\world.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False","title":"isBidirectional()"},{"location":"api/world/#mapper.world.World.pathFind","text":"Find the path Source code in mapper\\world.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> List [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : FrozenSet [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : FrozenSet [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"pathFind()"},{"location":"api/roomdata/database/","text":"Module mapper.roomdata.database \u00b6 Class SchemaValidationError \u00b6 Raised if there was an error validating an object's schema. Function dumpLabels ( labels ) \u00b6 Saves the labels database to disk. Parameters: Name Type Description Default labels Mapping[str, str] The labels database to be saved. required Source code in mapper\\roomdata\\database.py def dumpLabels ( labels : Mapping [ str , str ]) -> None : \"\"\" Saves the labels database to disk. Args: labels: The labels database to be saved. \"\"\" _dump ( labels , LABELS_FILE_PATH , LABELS_SCHEMA_FILE_PATH ) Function dumpRooms ( rooms ) \u00b6 Saves the rooms database to disk. Parameters: Name Type Description Default rooms Mapping[str, Mapping[str, Any]] The rooms database to be saved. required Source code in mapper\\roomdata\\database.py def dumpRooms ( rooms : Mapping [ str , Mapping [ str , Any ]]) -> None : \"\"\" Saves the rooms database to disk. Args: rooms: The rooms database to be saved. \"\"\" _dump ( rooms , MAP_FILE_PATH , MAP_SCHEMA_FILE_PATH ) Function loadLabels () \u00b6 Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: Type Description Union[Tuple[str, None], Tuple[None, Dict[str, str]]] An error message and None, or None and the loaded labels database. Source code in mapper\\roomdata\\database.py def loadLabels () -> Union [ Tuple [ str , None ], Tuple [ None , Dict [ str , str ]]]: \"\"\" Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: An error message and None, or None and the loaded labels database. \"\"\" errorMessages : List [ str ] = [] labels : Dict [ str , str ] = {} for path in ( SAMPLE_LABELS_FILE_PATH , LABELS_FILE_PATH ): errors , result = _load ( path , LABELS_SCHEMA_FILE_PATH ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } labels: { errors } \" ) else : labels . update ( result ) if labels : return None , labels else : return \" \\n \" . join ( errorMessages ), None Function loadRooms () \u00b6 Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: Type Description Union[Tuple[str, None], Tuple[None, Dict[str, Dict[str, Any]]]] An error message and None, or None and the loaded rooms database. Source code in mapper\\roomdata\\database.py def loadRooms () -> Union [ Tuple [ str , None ], Tuple [ None , Dict [ str , Dict [ str , Any ]]]]: \"\"\" Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: An error message and None, or None and the loaded rooms database. \"\"\" errorMessages : List [ str ] = [] for path in ( MAP_FILE_PATH , SAMPLE_MAP_FILE_PATH ): errors , result = _load ( path , MAP_SCHEMA_FILE_PATH ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } map: { errors } \" ) else : return None , result return \" \\n \" . join ( errorMessages ), None","title":"database.py"},{"location":"api/roomdata/database/#mapper.roomdata.database","text":"","title":"database"},{"location":"api/roomdata/database/#mapper.roomdata.database.SchemaValidationError","text":"Raised if there was an error validating an object's schema.","title":"SchemaValidationError"},{"location":"api/roomdata/database/#mapper.roomdata.database.dumpLabels","text":"Saves the labels database to disk. Parameters: Name Type Description Default labels Mapping[str, str] The labels database to be saved. required Source code in mapper\\roomdata\\database.py def dumpLabels ( labels : Mapping [ str , str ]) -> None : \"\"\" Saves the labels database to disk. Args: labels: The labels database to be saved. \"\"\" _dump ( labels , LABELS_FILE_PATH , LABELS_SCHEMA_FILE_PATH )","title":"dumpLabels()"},{"location":"api/roomdata/database/#mapper.roomdata.database.dumpRooms","text":"Saves the rooms database to disk. Parameters: Name Type Description Default rooms Mapping[str, Mapping[str, Any]] The rooms database to be saved. required Source code in mapper\\roomdata\\database.py def dumpRooms ( rooms : Mapping [ str , Mapping [ str , Any ]]) -> None : \"\"\" Saves the rooms database to disk. Args: rooms: The rooms database to be saved. \"\"\" _dump ( rooms , MAP_FILE_PATH , MAP_SCHEMA_FILE_PATH )","title":"dumpRooms()"},{"location":"api/roomdata/database/#mapper.roomdata.database.loadLabels","text":"Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: Type Description Union[Tuple[str, None], Tuple[None, Dict[str, str]]] An error message and None, or None and the loaded labels database. Source code in mapper\\roomdata\\database.py def loadLabels () -> Union [ Tuple [ str , None ], Tuple [ None , Dict [ str , str ]]]: \"\"\" Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: An error message and None, or None and the loaded labels database. \"\"\" errorMessages : List [ str ] = [] labels : Dict [ str , str ] = {} for path in ( SAMPLE_LABELS_FILE_PATH , LABELS_FILE_PATH ): errors , result = _load ( path , LABELS_SCHEMA_FILE_PATH ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } labels: { errors } \" ) else : labels . update ( result ) if labels : return None , labels else : return \" \\n \" . join ( errorMessages ), None","title":"loadLabels()"},{"location":"api/roomdata/database/#mapper.roomdata.database.loadRooms","text":"Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: Type Description Union[Tuple[str, None], Tuple[None, Dict[str, Dict[str, Any]]]] An error message and None, or None and the loaded rooms database. Source code in mapper\\roomdata\\database.py def loadRooms () -> Union [ Tuple [ str , None ], Tuple [ None , Dict [ str , Dict [ str , Any ]]]]: \"\"\" Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: An error message and None, or None and the loaded rooms database. \"\"\" errorMessages : List [ str ] = [] for path in ( MAP_FILE_PATH , SAMPLE_MAP_FILE_PATH ): errors , result = _load ( path , MAP_SCHEMA_FILE_PATH ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } map: { errors } \" ) else : return None , result return \" \\n \" . join ( errorMessages ), None","title":"loadRooms()"},{"location":"api/roomdata/objects/","text":"Module mapper.roomdata.objects \u00b6 Class Exit \u00b6 An exit. Attribute direction : str property writable \u00b6 The direction of movement. Class Room \u00b6 A room. Attribute info : str property readonly \u00b6 A summery of the room info. Attribute sortedExits : List [ Tuple [ str , Exit ]] property readonly \u00b6 The room exits, sorted by direction. Method calculateCost ( self ) \u00b6 Calculates the movement cost for the room. Source code in mapper\\roomdata\\objects.py def calculateCost ( self ) -> None : \"\"\"Calculates the movement cost for the room.\"\"\" self . cost = TERRAIN_COSTS [ self . terrain ] if self . avoid or AVOID_DYNAMIC_DESC_REGEX . search ( self . dynamicDesc ): self . cost += 1000.0 if self . ridable == \"notridable\" : self . cost += 5.0 Method clockPositionTo ( self , other ) \u00b6 Returns the clock position of another room from this one. Note https://en.wikipedia.org/wiki/Clock_position Parameters: Name Type Description Default other Room The other room to calculate the clock position of. required Returns: Type Description str The clock position of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def clockPositionTo ( self , other : Room ) -> str : \"\"\" Returns the clock position of another room from this one. Note: https://en.wikipedia.org/wiki/Clock_position Args: other: The other room to calculate the clock position of. Returns: The clock position of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : position = int ( round (( 90 - delta . angle_degrees + 360 ) % 360 / 30 )) or 12 return f \" { position } o'clock\" Method directionTo ( self , other ) \u00b6 Returns the compass direction of another room from this one. Note https://en.wikipedia.org/wiki/Points_of_the_compass Parameters: Name Type Description Default other Room The other room to calculate the compass direction of. required Returns: Type Description str The compass direction of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def directionTo ( self , other : Room ) -> str : \"\"\" Returns the compass direction of another room from this one. Note: https://en.wikipedia.org/wiki/Points_of_the_compass Args: other: The other room to calculate the compass direction of. Returns: The compass direction of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : return COMPASS_DIRECTIONS [ round (( 90 - delta . angle_degrees + 360 ) % 360 / 45 ) % 8 ] Method manhattanDistance ( self , other ) \u00b6 Returns the Manhattan distance between this room and another. Note https://en.wikipedia.org/wiki/Taxicab_geometry Parameters: Name Type Description Default other Room The other room to calculate the Manhattan distance between. required Returns: Type Description int The Manhattan distance between this room and the other. Source code in mapper\\roomdata\\objects.py def manhattanDistance ( self , other : Room ) -> int : \"\"\" Returns the Manhattan distance between this room and another. Note: https://en.wikipedia.org/wiki/Taxicab_geometry Args: other: The other room to calculate the Manhattan distance between. Returns: The Manhattan distance between this room and the other. \"\"\" return abs ( other . x - self . x ) + abs ( other . y - self . y ) + abs ( other . z - self . z )","title":"objects.py"},{"location":"api/roomdata/objects/#mapper.roomdata.objects","text":"","title":"objects"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Exit","text":"An exit.","title":"Exit"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Exit.direction","text":"The direction of movement.","title":"direction"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room","text":"A room.","title":"Room"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.info","text":"A summery of the room info.","title":"info"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.sortedExits","text":"The room exits, sorted by direction.","title":"sortedExits"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.calculateCost","text":"Calculates the movement cost for the room. Source code in mapper\\roomdata\\objects.py def calculateCost ( self ) -> None : \"\"\"Calculates the movement cost for the room.\"\"\" self . cost = TERRAIN_COSTS [ self . terrain ] if self . avoid or AVOID_DYNAMIC_DESC_REGEX . search ( self . dynamicDesc ): self . cost += 1000.0 if self . ridable == \"notridable\" : self . cost += 5.0","title":"calculateCost()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.clockPositionTo","text":"Returns the clock position of another room from this one. Note https://en.wikipedia.org/wiki/Clock_position Parameters: Name Type Description Default other Room The other room to calculate the clock position of. required Returns: Type Description str The clock position of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def clockPositionTo ( self , other : Room ) -> str : \"\"\" Returns the clock position of another room from this one. Note: https://en.wikipedia.org/wiki/Clock_position Args: other: The other room to calculate the clock position of. Returns: The clock position of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : position = int ( round (( 90 - delta . angle_degrees + 360 ) % 360 / 30 )) or 12 return f \" { position } o'clock\"","title":"clockPositionTo()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.directionTo","text":"Returns the compass direction of another room from this one. Note https://en.wikipedia.org/wiki/Points_of_the_compass Parameters: Name Type Description Default other Room The other room to calculate the compass direction of. required Returns: Type Description str The compass direction of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def directionTo ( self , other : Room ) -> str : \"\"\" Returns the compass direction of another room from this one. Note: https://en.wikipedia.org/wiki/Points_of_the_compass Args: other: The other room to calculate the compass direction of. Returns: The compass direction of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : return COMPASS_DIRECTIONS [ round (( 90 - delta . angle_degrees + 360 ) % 360 / 45 ) % 8 ]","title":"directionTo()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.manhattanDistance","text":"Returns the Manhattan distance between this room and another. Note https://en.wikipedia.org/wiki/Taxicab_geometry Parameters: Name Type Description Default other Room The other room to calculate the Manhattan distance between. required Returns: Type Description int The Manhattan distance between this room and the other. Source code in mapper\\roomdata\\objects.py def manhattanDistance ( self , other : Room ) -> int : \"\"\" Returns the Manhattan distance between this room and another. Note: https://en.wikipedia.org/wiki/Taxicab_geometry Args: other: The other room to calculate the Manhattan distance between. Returns: The Manhattan distance between this room and the other. \"\"\" return abs ( other . x - self . x ) + abs ( other . y - self . y ) + abs ( other . z - self . z )","title":"manhattanDistance()"},{"location":"api/sockets/bufferedsocket/","text":"Module mapper.sockets.bufferedsocket \u00b6 Class BufferedSocket \u00b6 Attribute family inherited property readonly \u00b6 A passthrough to the wrapped socket's family. BufferedSocket supports all widely-used families, so this read-only attribute can be one of :data: socket.AF_INET for IP, :data: socket.AF_INET6 for IPv6, and :data: socket.AF_UNIX for UDS. Attribute proto inherited property readonly \u00b6 A passthrough to the wrapped socket's protocol. The proto attribute is very rarely used, so it's always 0, meaning \"the default\" protocol. Pretty much all the practical information is in :attr: ~BufferedSocket.type and :attr: ~BufferedSocket.family , so you can go back to never thinking about this. Attribute type inherited property readonly \u00b6 A passthrough to the wrapped socket's type. Valid usages should only ever see :data: socket.SOCK_STREAM . Method __init__ ( self , sock , timeout =< object object at 0x0000019814B26030 > , maxsize = 32768 , recvsize =< object object at 0x0000019814B26030 > , encrypt = False , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default sock Union[socket.socket, FakeSocket] The connected socket to be wrapped. required timeout Union[socketutils._UNSET, float, None] The default timeout for send and recv , in seconds. Set to None for no timeout, 0 for nonblocking. <object object at 0x0000019814B26030> maxsize int The maximum number of bytes to be received into the buffer before it raises an exception. 32768 recvsize Union[socketutils._UNSET, int] The number of bytes to receive for every lower-level socket.recv call. <object object at 0x0000019814B26030> encrypt bool True if the socket should be wrapped in an SSL context , False otherwise. False **kwargs Any Key-word only arguments to be passed to the wrapSSL method. {} Source code in mapper\\sockets\\bufferedsocket.py def __init__ ( # type: ignore[no-any-unimported] self , sock : Union [ socket . socket , FakeSocket ], timeout : Union [ socketutils . _UNSET , float , None ] = socketutils . _UNSET , maxsize : int = socketutils . DEFAULT_MAXSIZE , recvsize : Union [ socketutils . _UNSET , int ] = socketutils . _UNSET , encrypt : bool = False , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: sock: The connected socket to be wrapped. timeout: The default timeout for [send][1] and [recv][2], in seconds. Set to `None` for no timeout, `0` for nonblocking. [1]: <https://docs.python.org/library/socket.html#socket.socket.send> [2]: <https://docs.python.org/library/socket.html#socket.socket.recv> maxsize: The maximum number of bytes to be received into the buffer before it raises an exception. recvsize: The number of bytes to receive for every lower-level [`socket.recv`][1] call. [1]: <https://docs.python.org/library/socket.html#socket.socket.recv> encrypt: True if the socket should be wrapped in an [SSL context][1], False otherwise. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> **kwargs: Key-word only arguments to be passed to the [wrapSSL][mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL] method. \"\"\" self . sock : Union [ socket . socket , FakeSocket , ssl . SSLSocket ] super () . __init__ ( sock , timeout , maxsize , recvsize ) if encrypt and isinstance ( self . sock , socket . socket ): self . sock = self . wrapSSL ( self . sock , ** kwargs ) Method buffer ( self , data ) inherited \u00b6 Buffer data bytes for the next send operation. Source code in mapper\\sockets\\bufferedsocket.py def buffer ( self , data ): \"Buffer *data* bytes for the next send operation.\" with self . _send_lock : self . sbuf . append ( data ) return Method close ( self ) inherited \u00b6 Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth: ~BufferedSocket.buffer , be sure to call :meth: ~BufferedSocket.flush before calling this method. After calling this method, future socket operations will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def close ( self ): \"\"\"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth:`~BufferedSocket.buffer`, be sure to call :meth:`~BufferedSocket.flush` before calling this method. After calling this method, future socket operations will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : with self . _send_lock : self . rbuf = b '' self . rbuf_unconsumed = self . rbuf self . sbuf [:] = [] self . sock . close () return Method doSSLHandshake ( self , sock ) \u00b6 Performs an SSL handshake. Note The SSLSocket.do_handshake method is non-blocking and must be retried until it returns successfully. See here for further explanation. Parameters: Name Type Description Default sock ssl.SSLSocket The socket to perform the handshake on. required Source code in mapper\\sockets\\bufferedsocket.py def doSSLHandshake ( self , sock : ssl . SSLSocket ) -> None : \"\"\" Performs an SSL handshake. Note: The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Args: sock: The socket to perform the handshake on. \"\"\" while True : try : sock . do_handshake () break except ssl . SSLWantReadError : select . select ([ sock ], [], []) except ssl . SSLWantWriteError : select . select ([], [ sock ], []) Method fileno ( self ) inherited \u00b6 Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling recv* functions. Source code in mapper\\sockets\\bufferedsocket.py def fileno ( self ): \"\"\"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling ``recv*`` functions. \"\"\" return self . sock . fileno () Method flush ( self ) inherited \u00b6 Send the contents of the internal send buffer. Source code in mapper\\sockets\\bufferedsocket.py def flush ( self ): \"Send the contents of the internal send buffer.\" with self . _send_lock : self . send ( b '' ) return Method getpeername ( self ) inherited \u00b6 Convenience function to return the remote address to which the wrapped socket is connected. See :meth: socket.getpeername for more details. Source code in mapper\\sockets\\bufferedsocket.py def getpeername ( self ): \"\"\"Convenience function to return the remote address to which the wrapped socket is connected. See :meth:`socket.getpeername` for more details. \"\"\" return self . sock . getpeername () Method getrecvbuffer ( self ) inherited \u00b6 Returns the receive buffer bytestring (rbuf). Source code in mapper\\sockets\\bufferedsocket.py def getrecvbuffer ( self ): \"Returns the receive buffer bytestring (rbuf).\" with self . _recv_lock : return self . rbuf Method getsendbuffer ( self ) inherited \u00b6 Returns a copy of the send buffer list. Source code in mapper\\sockets\\bufferedsocket.py def getsendbuffer ( self ): \"Returns a copy of the send buffer list.\" with self . _send_lock : return b '' . join ( self . sbuf ) Method getsockname ( self ) inherited \u00b6 Convenience function to return the wrapped socket's own address. See :meth: socket.getsockname for more details. Source code in mapper\\sockets\\bufferedsocket.py def getsockname ( self ): \"\"\"Convenience function to return the wrapped socket's own address. See :meth:`socket.getsockname` for more details. \"\"\" return self . sock . getsockname () Method getsockopt ( self , level , optname , buflen = None ) inherited \u00b6 Convenience function passing through to the wrapped socket's :meth: socket.getsockopt . Source code in mapper\\sockets\\bufferedsocket.py def getsockopt ( self , level , optname , buflen = None ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.getsockopt`. \"\"\" args = ( level , optname ) if buflen is not None : args += ( buflen ,) return self . sock . getsockopt ( * args ) Method peek ( self , size , timeout =< object object at 0x0000019814B26030 > ) inherited \u00b6 Returns size bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth: getrecvbuffer . Parameters: Name Type Description Default size int The exact number of bytes to peek at required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def peek ( self , size , timeout = _UNSET ): \"\"\"Returns *size* bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth:`getrecvbuffer`. Args: size (int): The exact number of bytes to peek at timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if len ( self . rbuf ) >= size : return self . rbuf [: size ] data = self . recv_size ( size , timeout = timeout ) self . rbuf = data + self . rbuf return data Method recv ( self , size , flags = 0 , timeout =< object object at 0x0000019814B26030 > ) inherited \u00b6 Returns up to size bytes, using the internal buffer before performing a single :meth: socket.recv operation. Parameters: Name Type Description Default size int The maximum number of bytes to receive. required flags int Kept for API compatibility with sockets. Only the default, 0 , is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> If the operation does not complete in timeout seconds, a :exc: Timeout is raised. Much like the built-in :class: socket.socket , if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def recv ( self , size , flags = 0 , timeout = _UNSET ): \"\"\"Returns **up to** *size* bytes, using the internal buffer before performing a single :meth:`socket.recv` operation. Args: size (int): The maximum number of bytes to receive. flags (int): Kept for API compatibility with sockets. Only the default, ``0``, is valid. timeout (float): The timeout for this operation. Can be ``0`` for nonblocking and ``None`` for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the operation does not complete in *timeout* seconds, a :exc:`Timeout` is raised. Much like the built-in :class:`socket.socket`, if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported: %r \" % flags ) if len ( self . rbuf ) >= size : data , self . rbuf = self . rbuf [: size ], self . rbuf [ size :] return data if self . rbuf : ret , self . rbuf = self . rbuf , b '' return ret self . sock . settimeout ( timeout ) try : data = self . sock . recv ( self . _recvsize ) except socket . timeout : raise Timeout ( timeout ) # check the rbuf attr for more if len ( data ) > size : data , self . rbuf = data [: size ], data [ size :] return data Method recv_close ( self , timeout =< object object at 0x0000019814B26030 > , maxsize =< object object at 0x0000019814B26030 > ) inherited \u00b6 Receive until the connection is closed, up to maxsize bytes. If more than maxsize bytes are received, raises :exc: MessageTooLong . Source code in mapper\\sockets\\bufferedsocket.py def recv_close ( self , timeout = _UNSET , maxsize = _UNSET ): \"\"\"Receive until the connection is closed, up to *maxsize* bytes. If more than *maxsize* bytes are received, raises :exc:`MessageTooLong`. \"\"\" # recv_close works by using recv_size to request maxsize data, # and ignoring ConnectionClose, returning and clearing the # internal buffer instead. It raises an exception if # ConnectionClosed isn't raised. with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE try : recvd = self . recv_size ( maxsize + 1 , timeout ) except ConnectionClosed : ret , self . rbuf = self . rbuf , b '' else : # put extra received bytes (now in rbuf) after recvd self . rbuf = recvd + self . rbuf size_read = min ( maxsize , len ( self . rbuf )) raise MessageTooLong ( size_read ) # check receive buffer return ret Method recv_size ( self , size , timeout =< object object at 0x0000019814B26030 > ) inherited \u00b6 Read off of the internal buffer, then off the socket, until size bytes have been read. Parameters: Name Type Description Default size int number of bytes to read before returning. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def recv_size ( self , size , timeout = _UNSET ): \"\"\"Read off of the internal buffer, then off the socket, until *size* bytes have been read. Args: size (int): number of bytes to read before returning. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout chunks = [] total_bytes = 0 try : start = time . time () self . sock . settimeout ( timeout ) nxt = self . rbuf or self . sock . recv ( self . _recvsize ) while nxt : total_bytes += len ( nxt ) if total_bytes >= size : break chunks . append ( nxt ) if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) nxt = self . sock . recv ( self . _recvsize ) else : msg = ( 'connection closed after reading %s of %s requested' ' bytes' % ( total_bytes , size )) raise ConnectionClosed ( msg ) # check recv buffer except socket . timeout : self . rbuf = b '' . join ( chunks ) msg = 'read %s of %s bytes' % ( total_bytes , size ) raise Timeout ( timeout , msg ) # check recv buffer except Exception : # received data is still buffered in the case of errors self . rbuf = b '' . join ( chunks ) raise extra_bytes = total_bytes - size if extra_bytes : last , self . rbuf = nxt [: - extra_bytes ], nxt [ - extra_bytes :] else : last , self . rbuf = nxt , b '' chunks . append ( last ) return b '' . join ( chunks ) Method recv_until ( self , delimiter , timeout =< object object at 0x0000019814B26030 > , maxsize =< object object at 0x0000019814B26030 > , with_delimiter = False ) inherited \u00b6 Receive until delimiter is found, maxsize bytes have been read, or timeout is exceeded. Parameters: Name Type Description Default delimiter bytes One or more bytes to be searched for in the socket stream. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> maxsize int The maximum size for the internal buffer. Defaults to the value set in the constructor. <object object at 0x0000019814B26030> with_delimiter bool Whether or not to include the delimiter in the output. False by default, but True is useful in cases where one is simply forwarding the messages. False recv_until will raise the following exceptions: :exc: Timeout if more than timeout seconds expire. :exc: ConnectionClosed if the underlying socket is closed by the sending end. :exc: MessageTooLong if the delimiter is not found in the first maxsize bytes. :exc: socket.error if operating in nonblocking mode ( timeout equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. Source code in mapper\\sockets\\bufferedsocket.py def recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ): \"\"\"Receive until *delimiter* is found, *maxsize* bytes have been read, or *timeout* is exceeded. Args: delimiter (bytes): One or more bytes to be searched for in the socket stream. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. maxsize (int): The maximum size for the internal buffer. Defaults to the value set in the constructor. with_delimiter (bool): Whether or not to include the delimiter in the output. ``False`` by default, but ``True`` is useful in cases where one is simply forwarding the messages. ``recv_until`` will raise the following exceptions: * :exc:`Timeout` if more than *timeout* seconds expire. * :exc:`ConnectionClosed` if the underlying socket is closed by the sending end. * :exc:`MessageTooLong` if the delimiter is not found in the first *maxsize* bytes. * :exc:`socket.error` if operating in nonblocking mode (*timeout* equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. \"\"\" with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE if timeout is _UNSET : timeout = self . timeout len_delimiter = len ( delimiter ) sock = self . sock recvd = bytearray ( self . rbuf ) start = time . time () find_offset_start = 0 # becomes a negative index below if not timeout : # covers None (no timeout) and 0 (nonblocking) sock . settimeout ( timeout ) try : while 1 : offset = recvd . find ( delimiter , find_offset_start , maxsize ) if offset != - 1 : # str.find returns -1 when no match found if with_delimiter : # include delimiter in return offset += len_delimiter rbuf_offset = offset else : rbuf_offset = offset + len_delimiter break elif len ( recvd ) > maxsize : raise MessageTooLong ( maxsize , delimiter ) # see rbuf if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () sock . settimeout ( cur_timeout ) nxt = sock . recv ( self . _recvsize ) if not nxt : args = ( len ( recvd ), delimiter ) msg = ( 'connection closed after reading %s bytes' ' without finding symbol: %r ' % args ) raise ConnectionClosed ( msg ) # check the recv buffer recvd . extend ( nxt ) find_offset_start = - len ( nxt ) - len_delimiter + 1 except socket . timeout : self . rbuf = bytes ( recvd ) msg = ( 'read %s bytes without finding delimiter: %r ' % ( len ( recvd ), delimiter )) raise Timeout ( timeout , msg ) # check the recv buffer except Exception : self . rbuf = bytes ( recvd ) raise val , self . rbuf = bytes ( recvd [: offset ]), bytes ( recvd [ rbuf_offset :]) return val Method send ( self , data , flags = 0 , timeout =< object object at 0x0000019814B26030 > ) inherited \u00b6 Send the contents of the internal send buffer, as well as data , to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of data was sent and the internal send buffer is empty. Parameters: Name Type Description Default data bytes The bytes to send. required flags int Kept for API compatibility with sockets. Only the default 0 is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> Will raise :exc: Timeout if the send operation fails to complete before timeout . In the event of an exception, use :meth: BufferedSocket.getsendbuffer to see which data was unsent. Source code in mapper\\sockets\\bufferedsocket.py def send ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"Send the contents of the internal send buffer, as well as *data*, to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of *data* was sent and the internal send buffer is empty. Args: data (bytes): The bytes to send. flags (int): Kept for API compatibility with sockets. Only the default 0 is valid. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. Will raise :exc:`Timeout` if the send operation fails to complete before *timeout*. In the event of an exception, use :meth:`BufferedSocket.getsendbuffer` to see which data was unsent. \"\"\" with self . _send_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported\" ) sbuf = self . sbuf sbuf . append ( data ) if len ( sbuf ) > 1 : sbuf [:] = [ b '' . join ([ s for s in sbuf if s ])] self . sock . settimeout ( timeout ) start , total_sent = time . time (), 0 try : while sbuf [ 0 ]: sent = self . sock . send ( sbuf [ 0 ]) total_sent += sent sbuf [ 0 ] = sbuf [ 0 ][ sent :] if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) except socket . timeout : raise Timeout ( timeout , ' %s bytes unsent' % len ( sbuf [ 0 ])) return total_sent Method sendall ( self , data , flags = 0 , timeout =< object object at 0x0000019814B26030 > ) inherited \u00b6 A passthrough to :meth: ~BufferedSocket.send , retained for parallelism to the :class: socket.socket API. Source code in mapper\\sockets\\bufferedsocket.py def sendall ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"A passthrough to :meth:`~BufferedSocket.send`, retained for parallelism to the :class:`socket.socket` API. \"\"\" return self . send ( data , flags , timeout ) Method setmaxsize ( self , maxsize ) inherited \u00b6 Set the default maximum buffer size maxsize for future operations, in bytes. Does not truncate the current buffer. Source code in mapper\\sockets\\bufferedsocket.py def setmaxsize ( self , maxsize ): \"\"\"Set the default maximum buffer size *maxsize* for future operations, in bytes. Does not truncate the current buffer. \"\"\" self . maxsize = maxsize Method setsockopt ( self , level , optname , value ) inherited \u00b6 Convenience function passing through to the wrapped socket's :meth: socket.setsockopt . Source code in mapper\\sockets\\bufferedsocket.py def setsockopt ( self , level , optname , value ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.setsockopt`. \"\"\" return self . sock . setsockopt ( level , optname , value ) Method settimeout ( self , timeout ) inherited \u00b6 Set the default timeout for future operations, in seconds. Source code in mapper\\sockets\\bufferedsocket.py def settimeout ( self , timeout ): \"Set the default *timeout* for future operations, in seconds.\" self . timeout = timeout Method shutdown ( self , how ) inherited \u00b6 Convenience method which passes through to the wrapped socket's :meth: ~socket.shutdown . Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full shutdown is followed by a :meth: ~BufferedSocket.close . Developers requiring more support, please open an issue _. .. _an issue: https://github.com/mahmoud/boltons/issues Source code in mapper\\sockets\\bufferedsocket.py def shutdown ( self , how ): \"\"\"Convenience method which passes through to the wrapped socket's :meth:`~socket.shutdown`. Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full ``shutdown`` is followed by a :meth:`~BufferedSocket.close`. Developers requiring more support, please open `an issue`_. .. _an issue: https://github.com/mahmoud/boltons/issues \"\"\" with self . _recv_lock : with self . _send_lock : self . sock . shutdown ( how ) return Method wrapSSL ( self , sock , ** kwargs ) \u00b6 Wraps a socket in an SSL context. Parameters: Name Type Description Default sock socket.socket The unencrypted socket. required **kwargs Any Key-word only arguments to be passed to the SSLContext.wrap_socket method. {} Returns: Type Description ssl.SSLSocket The socket wrapped in an SSL context. Source code in mapper\\sockets\\bufferedsocket.py def wrapSSL ( self , sock : socket . socket , ** kwargs : Any ) -> ssl . SSLSocket : \"\"\" Wraps a socket in an SSL context. Args: sock: The unencrypted socket. **kwargs: Key-word only arguments to be passed to the [`SSLContext.wrap_socket`][1] method. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext.wrap_socket> Returns: The socket wrapped in an [SSL context.](https://docs.python.org/library/ssl.html#ssl.SSLContext) \"\"\" kwargs [ \"do_handshake_on_connect\" ] = False # Avoid race condition. with self . _recv_lock , self . _send_lock : originalTimeout : Union [ float , None ] = sock . gettimeout () sock . settimeout ( None ) try : context : ssl . SSLContext = ssl . SSLContext ( ssl . PROTOCOL_TLS_CLIENT ) context . load_verify_locations ( CERT_LOCATION ) sock = context . wrap_socket ( sock , ** kwargs ) self . doSSLHandshake ( sock ) finally : sock . settimeout ( originalTimeout ) return sock","title":"bufferedsocket.py"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket","text":"","title":"bufferedsocket"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket","text":"","title":"BufferedSocket"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.family","text":"A passthrough to the wrapped socket's family. BufferedSocket supports all widely-used families, so this read-only attribute can be one of :data: socket.AF_INET for IP, :data: socket.AF_INET6 for IPv6, and :data: socket.AF_UNIX for UDS.","title":"family"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.proto","text":"A passthrough to the wrapped socket's protocol. The proto attribute is very rarely used, so it's always 0, meaning \"the default\" protocol. Pretty much all the practical information is in :attr: ~BufferedSocket.type and :attr: ~BufferedSocket.family , so you can go back to never thinking about this.","title":"proto"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.type","text":"A passthrough to the wrapped socket's type. Valid usages should only ever see :data: socket.SOCK_STREAM .","title":"type"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default sock Union[socket.socket, FakeSocket] The connected socket to be wrapped. required timeout Union[socketutils._UNSET, float, None] The default timeout for send and recv , in seconds. Set to None for no timeout, 0 for nonblocking. <object object at 0x0000019814B26030> maxsize int The maximum number of bytes to be received into the buffer before it raises an exception. 32768 recvsize Union[socketutils._UNSET, int] The number of bytes to receive for every lower-level socket.recv call. <object object at 0x0000019814B26030> encrypt bool True if the socket should be wrapped in an SSL context , False otherwise. False **kwargs Any Key-word only arguments to be passed to the wrapSSL method. {} Source code in mapper\\sockets\\bufferedsocket.py def __init__ ( # type: ignore[no-any-unimported] self , sock : Union [ socket . socket , FakeSocket ], timeout : Union [ socketutils . _UNSET , float , None ] = socketutils . _UNSET , maxsize : int = socketutils . DEFAULT_MAXSIZE , recvsize : Union [ socketutils . _UNSET , int ] = socketutils . _UNSET , encrypt : bool = False , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: sock: The connected socket to be wrapped. timeout: The default timeout for [send][1] and [recv][2], in seconds. Set to `None` for no timeout, `0` for nonblocking. [1]: <https://docs.python.org/library/socket.html#socket.socket.send> [2]: <https://docs.python.org/library/socket.html#socket.socket.recv> maxsize: The maximum number of bytes to be received into the buffer before it raises an exception. recvsize: The number of bytes to receive for every lower-level [`socket.recv`][1] call. [1]: <https://docs.python.org/library/socket.html#socket.socket.recv> encrypt: True if the socket should be wrapped in an [SSL context][1], False otherwise. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> **kwargs: Key-word only arguments to be passed to the [wrapSSL][mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL] method. \"\"\" self . sock : Union [ socket . socket , FakeSocket , ssl . SSLSocket ] super () . __init__ ( sock , timeout , maxsize , recvsize ) if encrypt and isinstance ( self . sock , socket . socket ): self . sock = self . wrapSSL ( self . sock , ** kwargs )","title":"__init__()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.buffer","text":"Buffer data bytes for the next send operation. Source code in mapper\\sockets\\bufferedsocket.py def buffer ( self , data ): \"Buffer *data* bytes for the next send operation.\" with self . _send_lock : self . sbuf . append ( data ) return","title":"buffer()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.close","text":"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth: ~BufferedSocket.buffer , be sure to call :meth: ~BufferedSocket.flush before calling this method. After calling this method, future socket operations will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def close ( self ): \"\"\"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth:`~BufferedSocket.buffer`, be sure to call :meth:`~BufferedSocket.flush` before calling this method. After calling this method, future socket operations will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : with self . _send_lock : self . rbuf = b '' self . rbuf_unconsumed = self . rbuf self . sbuf [:] = [] self . sock . close () return","title":"close()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.doSSLHandshake","text":"Performs an SSL handshake. Note The SSLSocket.do_handshake method is non-blocking and must be retried until it returns successfully. See here for further explanation. Parameters: Name Type Description Default sock ssl.SSLSocket The socket to perform the handshake on. required Source code in mapper\\sockets\\bufferedsocket.py def doSSLHandshake ( self , sock : ssl . SSLSocket ) -> None : \"\"\" Performs an SSL handshake. Note: The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Args: sock: The socket to perform the handshake on. \"\"\" while True : try : sock . do_handshake () break except ssl . SSLWantReadError : select . select ([ sock ], [], []) except ssl . SSLWantWriteError : select . select ([], [ sock ], [])","title":"doSSLHandshake()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.fileno","text":"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling recv* functions. Source code in mapper\\sockets\\bufferedsocket.py def fileno ( self ): \"\"\"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling ``recv*`` functions. \"\"\" return self . sock . fileno ()","title":"fileno()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.flush","text":"Send the contents of the internal send buffer. Source code in mapper\\sockets\\bufferedsocket.py def flush ( self ): \"Send the contents of the internal send buffer.\" with self . _send_lock : self . send ( b '' ) return","title":"flush()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getpeername","text":"Convenience function to return the remote address to which the wrapped socket is connected. See :meth: socket.getpeername for more details. Source code in mapper\\sockets\\bufferedsocket.py def getpeername ( self ): \"\"\"Convenience function to return the remote address to which the wrapped socket is connected. See :meth:`socket.getpeername` for more details. \"\"\" return self . sock . getpeername ()","title":"getpeername()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getrecvbuffer","text":"Returns the receive buffer bytestring (rbuf). Source code in mapper\\sockets\\bufferedsocket.py def getrecvbuffer ( self ): \"Returns the receive buffer bytestring (rbuf).\" with self . _recv_lock : return self . rbuf","title":"getrecvbuffer()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getsendbuffer","text":"Returns a copy of the send buffer list. Source code in mapper\\sockets\\bufferedsocket.py def getsendbuffer ( self ): \"Returns a copy of the send buffer list.\" with self . _send_lock : return b '' . join ( self . sbuf )","title":"getsendbuffer()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getsockname","text":"Convenience function to return the wrapped socket's own address. See :meth: socket.getsockname for more details. Source code in mapper\\sockets\\bufferedsocket.py def getsockname ( self ): \"\"\"Convenience function to return the wrapped socket's own address. See :meth:`socket.getsockname` for more details. \"\"\" return self . sock . getsockname ()","title":"getsockname()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getsockopt","text":"Convenience function passing through to the wrapped socket's :meth: socket.getsockopt . Source code in mapper\\sockets\\bufferedsocket.py def getsockopt ( self , level , optname , buflen = None ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.getsockopt`. \"\"\" args = ( level , optname ) if buflen is not None : args += ( buflen ,) return self . sock . getsockopt ( * args )","title":"getsockopt()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.peek","text":"Returns size bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth: getrecvbuffer . Parameters: Name Type Description Default size int The exact number of bytes to peek at required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def peek ( self , size , timeout = _UNSET ): \"\"\"Returns *size* bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth:`getrecvbuffer`. Args: size (int): The exact number of bytes to peek at timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if len ( self . rbuf ) >= size : return self . rbuf [: size ] data = self . recv_size ( size , timeout = timeout ) self . rbuf = data + self . rbuf return data","title":"peek()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv","text":"Returns up to size bytes, using the internal buffer before performing a single :meth: socket.recv operation. Parameters: Name Type Description Default size int The maximum number of bytes to receive. required flags int Kept for API compatibility with sockets. Only the default, 0 , is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> If the operation does not complete in timeout seconds, a :exc: Timeout is raised. Much like the built-in :class: socket.socket , if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def recv ( self , size , flags = 0 , timeout = _UNSET ): \"\"\"Returns **up to** *size* bytes, using the internal buffer before performing a single :meth:`socket.recv` operation. Args: size (int): The maximum number of bytes to receive. flags (int): Kept for API compatibility with sockets. Only the default, ``0``, is valid. timeout (float): The timeout for this operation. Can be ``0`` for nonblocking and ``None`` for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the operation does not complete in *timeout* seconds, a :exc:`Timeout` is raised. Much like the built-in :class:`socket.socket`, if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported: %r \" % flags ) if len ( self . rbuf ) >= size : data , self . rbuf = self . rbuf [: size ], self . rbuf [ size :] return data if self . rbuf : ret , self . rbuf = self . rbuf , b '' return ret self . sock . settimeout ( timeout ) try : data = self . sock . recv ( self . _recvsize ) except socket . timeout : raise Timeout ( timeout ) # check the rbuf attr for more if len ( data ) > size : data , self . rbuf = data [: size ], data [ size :] return data","title":"recv()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv_close","text":"Receive until the connection is closed, up to maxsize bytes. If more than maxsize bytes are received, raises :exc: MessageTooLong . Source code in mapper\\sockets\\bufferedsocket.py def recv_close ( self , timeout = _UNSET , maxsize = _UNSET ): \"\"\"Receive until the connection is closed, up to *maxsize* bytes. If more than *maxsize* bytes are received, raises :exc:`MessageTooLong`. \"\"\" # recv_close works by using recv_size to request maxsize data, # and ignoring ConnectionClose, returning and clearing the # internal buffer instead. It raises an exception if # ConnectionClosed isn't raised. with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE try : recvd = self . recv_size ( maxsize + 1 , timeout ) except ConnectionClosed : ret , self . rbuf = self . rbuf , b '' else : # put extra received bytes (now in rbuf) after recvd self . rbuf = recvd + self . rbuf size_read = min ( maxsize , len ( self . rbuf )) raise MessageTooLong ( size_read ) # check receive buffer return ret","title":"recv_close()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv_size","text":"Read off of the internal buffer, then off the socket, until size bytes have been read. Parameters: Name Type Description Default size int number of bytes to read before returning. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def recv_size ( self , size , timeout = _UNSET ): \"\"\"Read off of the internal buffer, then off the socket, until *size* bytes have been read. Args: size (int): number of bytes to read before returning. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout chunks = [] total_bytes = 0 try : start = time . time () self . sock . settimeout ( timeout ) nxt = self . rbuf or self . sock . recv ( self . _recvsize ) while nxt : total_bytes += len ( nxt ) if total_bytes >= size : break chunks . append ( nxt ) if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) nxt = self . sock . recv ( self . _recvsize ) else : msg = ( 'connection closed after reading %s of %s requested' ' bytes' % ( total_bytes , size )) raise ConnectionClosed ( msg ) # check recv buffer except socket . timeout : self . rbuf = b '' . join ( chunks ) msg = 'read %s of %s bytes' % ( total_bytes , size ) raise Timeout ( timeout , msg ) # check recv buffer except Exception : # received data is still buffered in the case of errors self . rbuf = b '' . join ( chunks ) raise extra_bytes = total_bytes - size if extra_bytes : last , self . rbuf = nxt [: - extra_bytes ], nxt [ - extra_bytes :] else : last , self . rbuf = nxt , b '' chunks . append ( last ) return b '' . join ( chunks )","title":"recv_size()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv_until","text":"Receive until delimiter is found, maxsize bytes have been read, or timeout is exceeded. Parameters: Name Type Description Default delimiter bytes One or more bytes to be searched for in the socket stream. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> maxsize int The maximum size for the internal buffer. Defaults to the value set in the constructor. <object object at 0x0000019814B26030> with_delimiter bool Whether or not to include the delimiter in the output. False by default, but True is useful in cases where one is simply forwarding the messages. False recv_until will raise the following exceptions: :exc: Timeout if more than timeout seconds expire. :exc: ConnectionClosed if the underlying socket is closed by the sending end. :exc: MessageTooLong if the delimiter is not found in the first maxsize bytes. :exc: socket.error if operating in nonblocking mode ( timeout equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. Source code in mapper\\sockets\\bufferedsocket.py def recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ): \"\"\"Receive until *delimiter* is found, *maxsize* bytes have been read, or *timeout* is exceeded. Args: delimiter (bytes): One or more bytes to be searched for in the socket stream. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. maxsize (int): The maximum size for the internal buffer. Defaults to the value set in the constructor. with_delimiter (bool): Whether or not to include the delimiter in the output. ``False`` by default, but ``True`` is useful in cases where one is simply forwarding the messages. ``recv_until`` will raise the following exceptions: * :exc:`Timeout` if more than *timeout* seconds expire. * :exc:`ConnectionClosed` if the underlying socket is closed by the sending end. * :exc:`MessageTooLong` if the delimiter is not found in the first *maxsize* bytes. * :exc:`socket.error` if operating in nonblocking mode (*timeout* equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. \"\"\" with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE if timeout is _UNSET : timeout = self . timeout len_delimiter = len ( delimiter ) sock = self . sock recvd = bytearray ( self . rbuf ) start = time . time () find_offset_start = 0 # becomes a negative index below if not timeout : # covers None (no timeout) and 0 (nonblocking) sock . settimeout ( timeout ) try : while 1 : offset = recvd . find ( delimiter , find_offset_start , maxsize ) if offset != - 1 : # str.find returns -1 when no match found if with_delimiter : # include delimiter in return offset += len_delimiter rbuf_offset = offset else : rbuf_offset = offset + len_delimiter break elif len ( recvd ) > maxsize : raise MessageTooLong ( maxsize , delimiter ) # see rbuf if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () sock . settimeout ( cur_timeout ) nxt = sock . recv ( self . _recvsize ) if not nxt : args = ( len ( recvd ), delimiter ) msg = ( 'connection closed after reading %s bytes' ' without finding symbol: %r ' % args ) raise ConnectionClosed ( msg ) # check the recv buffer recvd . extend ( nxt ) find_offset_start = - len ( nxt ) - len_delimiter + 1 except socket . timeout : self . rbuf = bytes ( recvd ) msg = ( 'read %s bytes without finding delimiter: %r ' % ( len ( recvd ), delimiter )) raise Timeout ( timeout , msg ) # check the recv buffer except Exception : self . rbuf = bytes ( recvd ) raise val , self . rbuf = bytes ( recvd [: offset ]), bytes ( recvd [ rbuf_offset :]) return val","title":"recv_until()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.send","text":"Send the contents of the internal send buffer, as well as data , to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of data was sent and the internal send buffer is empty. Parameters: Name Type Description Default data bytes The bytes to send. required flags int Kept for API compatibility with sockets. Only the default 0 is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x0000019814B26030> Will raise :exc: Timeout if the send operation fails to complete before timeout . In the event of an exception, use :meth: BufferedSocket.getsendbuffer to see which data was unsent. Source code in mapper\\sockets\\bufferedsocket.py def send ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"Send the contents of the internal send buffer, as well as *data*, to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of *data* was sent and the internal send buffer is empty. Args: data (bytes): The bytes to send. flags (int): Kept for API compatibility with sockets. Only the default 0 is valid. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. Will raise :exc:`Timeout` if the send operation fails to complete before *timeout*. In the event of an exception, use :meth:`BufferedSocket.getsendbuffer` to see which data was unsent. \"\"\" with self . _send_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported\" ) sbuf = self . sbuf sbuf . append ( data ) if len ( sbuf ) > 1 : sbuf [:] = [ b '' . join ([ s for s in sbuf if s ])] self . sock . settimeout ( timeout ) start , total_sent = time . time (), 0 try : while sbuf [ 0 ]: sent = self . sock . send ( sbuf [ 0 ]) total_sent += sent sbuf [ 0 ] = sbuf [ 0 ][ sent :] if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) except socket . timeout : raise Timeout ( timeout , ' %s bytes unsent' % len ( sbuf [ 0 ])) return total_sent","title":"send()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.sendall","text":"A passthrough to :meth: ~BufferedSocket.send , retained for parallelism to the :class: socket.socket API. Source code in mapper\\sockets\\bufferedsocket.py def sendall ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"A passthrough to :meth:`~BufferedSocket.send`, retained for parallelism to the :class:`socket.socket` API. \"\"\" return self . send ( data , flags , timeout )","title":"sendall()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.setmaxsize","text":"Set the default maximum buffer size maxsize for future operations, in bytes. Does not truncate the current buffer. Source code in mapper\\sockets\\bufferedsocket.py def setmaxsize ( self , maxsize ): \"\"\"Set the default maximum buffer size *maxsize* for future operations, in bytes. Does not truncate the current buffer. \"\"\" self . maxsize = maxsize","title":"setmaxsize()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.setsockopt","text":"Convenience function passing through to the wrapped socket's :meth: socket.setsockopt . Source code in mapper\\sockets\\bufferedsocket.py def setsockopt ( self , level , optname , value ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.setsockopt`. \"\"\" return self . sock . setsockopt ( level , optname , value )","title":"setsockopt()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.settimeout","text":"Set the default timeout for future operations, in seconds. Source code in mapper\\sockets\\bufferedsocket.py def settimeout ( self , timeout ): \"Set the default *timeout* for future operations, in seconds.\" self . timeout = timeout","title":"settimeout()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.shutdown","text":"Convenience method which passes through to the wrapped socket's :meth: ~socket.shutdown . Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full shutdown is followed by a :meth: ~BufferedSocket.close . Developers requiring more support, please open an issue _. .. _an issue: https://github.com/mahmoud/boltons/issues Source code in mapper\\sockets\\bufferedsocket.py def shutdown ( self , how ): \"\"\"Convenience method which passes through to the wrapped socket's :meth:`~socket.shutdown`. Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full ``shutdown`` is followed by a :meth:`~BufferedSocket.close`. Developers requiring more support, please open `an issue`_. .. _an issue: https://github.com/mahmoud/boltons/issues \"\"\" with self . _recv_lock : with self . _send_lock : self . sock . shutdown ( how ) return","title":"shutdown()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL","text":"Wraps a socket in an SSL context. Parameters: Name Type Description Default sock socket.socket The unencrypted socket. required **kwargs Any Key-word only arguments to be passed to the SSLContext.wrap_socket method. {} Returns: Type Description ssl.SSLSocket The socket wrapped in an SSL context. Source code in mapper\\sockets\\bufferedsocket.py def wrapSSL ( self , sock : socket . socket , ** kwargs : Any ) -> ssl . SSLSocket : \"\"\" Wraps a socket in an SSL context. Args: sock: The unencrypted socket. **kwargs: Key-word only arguments to be passed to the [`SSLContext.wrap_socket`][1] method. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext.wrap_socket> Returns: The socket wrapped in an [SSL context.](https://docs.python.org/library/ssl.html#ssl.SSLContext) \"\"\" kwargs [ \"do_handshake_on_connect\" ] = False # Avoid race condition. with self . _recv_lock , self . _send_lock : originalTimeout : Union [ float , None ] = sock . gettimeout () sock . settimeout ( None ) try : context : ssl . SSLContext = ssl . SSLContext ( ssl . PROTOCOL_TLS_CLIENT ) context . load_verify_locations ( CERT_LOCATION ) sock = context . wrap_socket ( sock , ** kwargs ) self . doSSLHandshake ( sock ) finally : sock . settimeout ( originalTimeout ) return sock","title":"wrapSSL()"},{"location":"api/sockets/fakesocket/","text":"Module mapper.sockets.fakesocket \u00b6","title":"fakesocket.py"},{"location":"api/sockets/fakesocket/#mapper.sockets.fakesocket","text":"","title":"fakesocket"}]}