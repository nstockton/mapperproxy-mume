{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"Mozilla Public License Version 2.0 \u00b6 1. Definitions \u00b6 1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity. 2. License Grants and Conditions \u00b6 2.1. Grants \u00b6 Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date \u00b6 The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope \u00b6 The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses \u00b6 No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation \u00b6 Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use \u00b6 This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions \u00b6 Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1. 3. Responsibilities \u00b6 3.1. Distribution of Source Form \u00b6 All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form \u00b6 If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work \u00b6 You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices \u00b6 You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms \u00b6 You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction. 4. Inability to Comply Due to Statute or Regulation \u00b6 If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it. 5. Termination \u00b6 5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. 6. Disclaimer of Warranty \u00b6 Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer. 7. Limitation of Liability \u00b6 Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You. 8. Litigation \u00b6 Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims. 9. Miscellaneous \u00b6 This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor. 10. Versions of the License \u00b6 10.1. New Versions \u00b6 Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions \u00b6 You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions \u00b6 If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses \u00b6 If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached. Exhibit A - Source Code Form License Notice \u00b6 This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership. Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice \u00b6 This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"License"},{"location":"license/#mozilla-public-license-version-20","text":"","title":"Mozilla Public License Version 2.0"},{"location":"license/#1-definitions","text":"1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.","title":"1. Definitions"},{"location":"license/#2-license-grants-and-conditions","text":"","title":"2. License Grants and Conditions"},{"location":"license/#21-grants","text":"Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.","title":"2.1. Grants"},{"location":"license/#22-effective-date","text":"The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.","title":"2.2. Effective Date"},{"location":"license/#23-limitations-on-grant-scope","text":"The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).","title":"2.3. Limitations on Grant Scope"},{"location":"license/#24-subsequent-licenses","text":"No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).","title":"2.4. Subsequent Licenses"},{"location":"license/#25-representation","text":"Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.","title":"2.5. Representation"},{"location":"license/#26-fair-use","text":"This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.","title":"2.6. Fair Use"},{"location":"license/#27-conditions","text":"Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.","title":"2.7. Conditions"},{"location":"license/#3-responsibilities","text":"","title":"3. Responsibilities"},{"location":"license/#31-distribution-of-source-form","text":"All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form.","title":"3.1. Distribution of Source Form"},{"location":"license/#32-distribution-of-executable-form","text":"If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License.","title":"3.2. Distribution of Executable Form"},{"location":"license/#33-distribution-of-a-larger-work","text":"You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).","title":"3.3. Distribution of a Larger Work"},{"location":"license/#34-notices","text":"You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.","title":"3.4. Notices"},{"location":"license/#35-application-of-additional-terms","text":"You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.","title":"3.5. Application of Additional Terms"},{"location":"license/#4-inability-to-comply-due-to-statute-or-regulation","text":"If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.","title":"4. Inability to Comply Due to Statute or Regulation"},{"location":"license/#5-termination","text":"5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.","title":"5. Termination"},{"location":"license/#6-disclaimer-of-warranty","text":"Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.","title":"6. Disclaimer of Warranty"},{"location":"license/#7-limitation-of-liability","text":"Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.","title":"7. Limitation of Liability"},{"location":"license/#8-litigation","text":"Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.","title":"8. Litigation"},{"location":"license/#9-miscellaneous","text":"This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.","title":"9. Miscellaneous"},{"location":"license/#10-versions-of-the-license","text":"","title":"10. Versions of the License"},{"location":"license/#101-new-versions","text":"Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.","title":"10.1. New Versions"},{"location":"license/#102-effect-of-new-versions","text":"You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.","title":"10.2. Effect of New Versions"},{"location":"license/#103-modified-versions","text":"If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).","title":"10.3. Modified Versions"},{"location":"license/#104-distributing-source-code-form-that-is-incompatible-with-secondary-licenses","text":"If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.","title":"10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses"},{"location":"license/#exhibit-a-source-code-form-license-notice","text":"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership.","title":"Exhibit A - Source Code Form License Notice"},{"location":"license/#exhibit-b-incompatible-with-secondary-licenses-notice","text":"This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice"},{"location":"api/","text":"Mapper Proxy API \u00b6 Automatically generated API reference. Mapper \u00b6 Clean Map Clock Config Delays Main Mapper Mud Events Utils World Room Data \u00b6 Database Room Objects Sockets \u00b6 Buffered Socket Fake Socket","title":"API Index"},{"location":"api/#mapper-proxy-api","text":"Automatically generated API reference.","title":"Mapper Proxy API"},{"location":"api/#mapper","text":"Clean Map Clock Config Delays Main Mapper Mud Events Utils World","title":"Mapper"},{"location":"api/#room-data","text":"Database Room Objects","title":"Room Data"},{"location":"api/#sockets","text":"Buffered Socket Fake Socket","title":"Sockets"},{"location":"api/cleanmap/","text":"Module mapper.cleanmap \u00b6 Class ExitsCleaner( Handler ) \u00b6 Implements an event handler that cleans erroneously hidden exits. This handler uses the output of the 'exits' command in MUME to Check if any visible exits are erroneously marked as hidden in the map database. Any exits which are found to be erroneously marked as hidden are then cleaned (marked as visible). Source code in mapper\\cleanmap.py class ExitsCleaner ( Handler ): \"\"\" Implements an event handler that cleans erroneously hidden exits. This handler uses the output of the 'exits' command in MUME to Check if any visible exits are erroneously marked as hidden in the map database. Any exits which are found to be erroneously marked as hidden are then cleaned (marked as visible). \"\"\" event : str = \"exits\" def handle ( self , text : str ) -> None : \"\"\" Handles the incoming text from MUME. Args: text: The received text from the game. \"\"\" if not self . mapper . autoUpdateRooms or text . startswith ( \"Exits:\" ): return None for line in text . splitlines (): match : REGEX_MATCH = EXIT_REGEX . match ( line ) if match is not None : room : Room = self . mapper . currentRoom direction : str = match . group ( \"dir\" ) . lower () if ( self . mapper . isSynced and direction in room . exits and \"hidden\" in room . exits [ direction ] . doorFlags ): self . mapper . user_command_secret ( f \"remove { direction } \" ) Method handle ( self , text ) \u00b6 Handles the incoming text from MUME. Parameters: Name Type Description Default text str The received text from the game. required Source code in mapper\\cleanmap.py def handle ( self , text : str ) -> None : \"\"\" Handles the incoming text from MUME. Args: text: The received text from the game. \"\"\" if not self . mapper . autoUpdateRooms or text . startswith ( \"Exits:\" ): return None for line in text . splitlines (): match : REGEX_MATCH = EXIT_REGEX . match ( line ) if match is not None : room : Room = self . mapper . currentRoom direction : str = match . group ( \"dir\" ) . lower () if ( self . mapper . isSynced and direction in room . exits and \"hidden\" in room . exits [ direction ] . doorFlags ): self . mapper . user_command_secret ( f \"remove { direction } \" )","title":"cleanmap.py"},{"location":"api/cleanmap/#mapper.cleanmap","text":"","title":"cleanmap"},{"location":"api/cleanmap/#mapper.cleanmap.ExitsCleaner","text":"Implements an event handler that cleans erroneously hidden exits. This handler uses the output of the 'exits' command in MUME to Check if any visible exits are erroneously marked as hidden in the map database. Any exits which are found to be erroneously marked as hidden are then cleaned (marked as visible). Source code in mapper\\cleanmap.py class ExitsCleaner ( Handler ): \"\"\" Implements an event handler that cleans erroneously hidden exits. This handler uses the output of the 'exits' command in MUME to Check if any visible exits are erroneously marked as hidden in the map database. Any exits which are found to be erroneously marked as hidden are then cleaned (marked as visible). \"\"\" event : str = \"exits\" def handle ( self , text : str ) -> None : \"\"\" Handles the incoming text from MUME. Args: text: The received text from the game. \"\"\" if not self . mapper . autoUpdateRooms or text . startswith ( \"Exits:\" ): return None for line in text . splitlines (): match : REGEX_MATCH = EXIT_REGEX . match ( line ) if match is not None : room : Room = self . mapper . currentRoom direction : str = match . group ( \"dir\" ) . lower () if ( self . mapper . isSynced and direction in room . exits and \"hidden\" in room . exits [ direction ] . doorFlags ): self . mapper . user_command_secret ( f \"remove { direction } \" )","title":"ExitsCleaner"},{"location":"api/cleanmap/#mapper.cleanmap.ExitsCleaner.handle","text":"Handles the incoming text from MUME. Parameters: Name Type Description Default text str The received text from the game. required Source code in mapper\\cleanmap.py def handle ( self , text : str ) -> None : \"\"\" Handles the incoming text from MUME. Args: text: The received text from the game. \"\"\" if not self . mapper . autoUpdateRooms or text . startswith ( \"Exits:\" ): return None for line in text . splitlines (): match : REGEX_MATCH = EXIT_REGEX . match ( line ) if match is not None : room : Room = self . mapper . currentRoom direction : str = match . group ( \"dir\" ) . lower () if ( self . mapper . isSynced and direction in room . exits and \"hidden\" in room . exits [ direction ] . doorFlags ): self . mapper . user_command_secret ( f \"remove { direction } \" )","title":"handle()"},{"location":"api/clock/","text":"Module mapper.clock \u00b6 Class Clock \u00b6 Source code in mapper\\clock.py class Clock ( object ): def __init__ ( self ) -> None : self . _epoch : Optional [ int ] = None @property def epoch ( self ) -> int : # pragma: no cover \"\"\" The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset. \"\"\" if self . _epoch is None : cfg = Config () self . _epoch = int ( cfg . get ( \"mume_epoch\" , 1517486451 )) del cfg return self . _epoch @epoch . setter def epoch ( self , value : int ) -> None : # pragma: no cover self . _epoch = value cfg = Config () cfg [ \"mume_epoch\" ] = int ( value ) cfg . save () del cfg def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info Attribute epoch : int property writable \u00b6 The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset. Method setTime ( self , year , month , day , hour , minutes ) \u00b6 Sets the Mume epoch from the current Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Source code in mapper\\clock.py def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta Method time ( self , action = None ) \u00b6 Outputs information about the current Mume time. Parameters: Name Type Description Default action Optional[str] An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. None Returns: Type Description str The requested output. Source code in mapper\\clock.py def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info Class MumeTime \u00b6 Source code in mapper\\clock.py class MumeTime ( object ): def __init__ ( self , delta : int ) -> None : self . _year , self . _month , self . _day , self . _hour , self . _minutes = deltaToTime ( delta ) @property def year ( self ) -> int : \"\"\"The year.\"\"\" return self . _year @property def month ( self ) -> int : \"\"\"The month of the year (0 or more).\"\"\" return self . _month @property def day ( self ) -> int : \"\"\"The day of the month (1 or more).\"\"\" return self . _day @property def hour ( self ) -> int : \"\"\"The hour of the day (0 or more).\"\"\" return self . _hour @property def minutes ( self ) -> int : \"\"\"The minutes of the hour (0 or more).\"\"\" return self . _minutes @property def delta ( self ) -> int : \"\"\"The time as a delta.\"\"\" return timeToDelta ( self . year , self . month , self . day , self . hour , self . minutes ) @property def amPm ( self ) -> str : \"\"\"The AM - PM value.\"\"\" return \"am\" if self . hour < 12 else \"pm\" @property def dayOfYear ( self ) -> int : \"\"\"The day of the year (1 or more).\"\"\" return self . month * DAYS_PER_MONTH + self . day @property def hourOfYear ( self ) -> int : \"\"\"The hour of the year (0 or more).\"\"\" return ( self . dayOfYear - 1 ) * HOURS_PER_DAY + self . hour @property def overallDay ( self ) -> int : \"\"\"The sum of all the elapsed years in days and the day of year (1 or more).\"\"\" return ( self . year - FIRST_YEAR ) * DAYS_PER_YEAR + self . dayOfYear @property def weekday ( self ) -> str : \"\"\"The name of the weekday.\"\"\" return WEEKDAYS [ self . overallDay % DAYS_PER_WEEK ][ \"name\" ] @property def dawn ( self ) -> int : \"\"\"The hour of dawn.\"\"\" return int ( MONTHS [ self . month ][ \"dawn\" ]) @property def dusk ( self ) -> int : \"\"\"The hour of dusk.\"\"\" return int ( MONTHS [ self . month ][ \"dusk\" ]) @property def season ( self ) -> str : \"\"\"The name of the season.\"\"\" return str ( MONTHS [ self . month ][ \"season\" ]) @property def monthName ( self ) -> str : \"\"\"The name of the month.\"\"\" return str ( MONTHS [ self . month ][ \"name\" ]) @property def monthWestron ( self ) -> str : \"\"\"The name of the month in Westron.\"\"\" return str ( MONTHS [ self . month ][ \"westron\" ]) @property def monthSindarin ( self ) -> str : \"\"\"The name of the month in Sindarin.\"\"\" return str ( MONTHS [ self . month ][ \"sindarin\" ]) @property def dawnDuskState ( self ) -> tuple [ str , str , int ]: \"\"\"A tuple containing the current state name, the next state name, and the game hours until next state.\"\"\" if self . hour < self . dawn : state = \"NIGHT\" nextState = \"DAY\" untilNextState = self . dawn - self . hour + 1 elif self . hour >= self . dusk : state = \"NIGHT\" nextState = \"DAY\" untilNextState = HOURS_PER_DAY + self . dawn - self . hour + 1 elif self . hour > self . dawn and self . hour < self . dusk : state = \"DAY\" nextState = \"NIGHT\" untilNextState = self . dusk - self . hour elif self . hour == self . dawn : state = \"DAWN\" nextState = \"DAY\" untilNextState = 1 return state , nextState , untilNextState @property def daysUntilSeason ( self ) -> int : \"\"\"The days until next season (1 or more).\"\"\" monthsSinceLastSeason = ( self . month + 1 ) % MONTHS_PER_SEASON daysSinceLastSeason = monthsSinceLastSeason * DAYS_PER_MONTH + ( self . day - 1 ) return DAYS_PER_SEASON - daysSinceLastSeason @property def rlHoursUntilSeason ( self ) -> int : \"\"\"The real life hours until next season (1 or more).\"\"\" return self . daysUntilSeason * HOURS_PER_DAY // MINUTES_PER_HOUR @property def daysUntilWinter ( self ) -> int : \"\"\"The days until next winter (1 or more).\"\"\" monthsSinceLastWinter = ( self . month + 1 ) % MONTHS_PER_YEAR daysSinceLastWinter = monthsSinceLastWinter * DAYS_PER_MONTH + ( self . day - 1 ) return DAYS_PER_YEAR - daysSinceLastWinter @property def rlHoursUntilWinter ( self ) -> int : \"\"\"The real life hours until next winter (0 or more).\"\"\" return self . daysUntilWinter * HOURS_PER_DAY // MINUTES_PER_HOUR @property def daysSinceMoonCycle ( self ) -> int : \"\"\"The days since last moon cycle (0 or more).\"\"\" return ( self . dayOfYear - FIRST_MOON_CYCLE_DAY ) % DAYS_PER_MOON_CYCLE @property def daysUntilMoonCycle ( self ) -> int : \"\"\"The days until next moon cycle (1 or more).\"\"\" return DAYS_PER_MOON_CYCLE - self . daysSinceMoonCycle @property def hourOfMoonRise ( self ) -> int : \"\"\"The hour of day when the moon will rise (0 or more).\"\"\" return ( FIRST_MOON_CYCLE_HOUR + self . daysSinceMoonCycle ) % HOURS_PER_DAY @property def daysSinceFullMoon ( self ) -> int : \"\"\"The days since last full moon (0 or more).\"\"\" return ( self . dayOfYear - FIRST_FULL_MOON_DAY ) % DAYS_PER_MOON_CYCLE @property def daysUntilFullMoon ( self ) -> int : \"\"\"The days until next full moon (1 or more).\"\"\" return DAYS_PER_MOON_CYCLE - self . daysSinceFullMoon @property def hoursSinceFullMoon ( self ) -> int : \"\"\"The hours since last full moon (0 or more).\"\"\" return ( self . daysSinceFullMoon * HOURS_PER_DAY + self . hour - FULL_MOON_HOUR ) % HOURS_PER_MOON_CYCLE @property def hoursUntilFullMoon ( self ) -> int : \"\"\"The hours Until full moon (1 or more).\"\"\" return HOURS_PER_MOON_CYCLE - self . hoursSinceFullMoon @property def info ( self ) -> str : # pragma: no cover \"\"\"A summery of information about this moment in Mume time.\"\"\" output = [] output . append ( f \"Game time { self . hour % 12 or 12 } : { self . minutes : 02d } { self . amPm } : \" + f \"Dawn: { self . dawn } am, Dusk: { self . dusk - 12 } pm.\" ) state , nextState , untilNextState = self . dawnDuskState output . append ( f \"It is currently { state } , on { self . weekday } , { self . monthName } { self . day } \" + f \"( { self . monthWestron } / { self . monthSindarin } ), ( { self . season } ), year { self . year } of the third age.\" ) output . append ( f \"Time left until { nextState } is less than { untilNextState } tick { 's' if untilNextState != 1 else '!' } \" ) output . append ( f \" { self . season [ - 6 :] } ends in \" + f \" { self . daysUntilSeason } mume day { 's' if self . daysUntilSeason != 1 else '' } or \" + f \" { self . rlHoursUntilSeason } real-life hour { 's' if self . rlHoursUntilSeason != 1 else '' } .\" ) rlDaysUntilWinter = self . rlHoursUntilWinter // HOURS_PER_DAY rlHoursUntilWinter = self . rlHoursUntilWinter % HOURS_PER_DAY output . append ( f \"Next winter starts in { rlDaysUntilWinter } real-life day { 's' if rlDaysUntilWinter != 1 else '' } \" + f \"and { rlHoursUntilWinter } hour { 's' if rlHoursUntilWinter != 1 else '' } .\" ) hourOfMoonRise = self . hourOfMoonRise if self . hour == hourOfMoonRise : output . append ( \"Moon is up now!\" ) else : if self . hour > hourOfMoonRise : hourOfMoonRise = ( hourOfMoonRise + 1 ) % HOURS_PER_DAY dayOfMoonRise = \"tomorrow\" else : dayOfMoonRise = \"today\" output . append ( f \"Next moon rise { dayOfMoonRise } at { hourOfMoonRise % 12 or 12 } :00 \" + f \" { 'am' if hourOfMoonRise < 12 else 'pm' } (game time).\" ) nextFullMoonRlHours = self . hoursUntilFullMoon // MINUTES_PER_HOUR nextFullMoonRlMinutes = self . hoursUntilFullMoon % MINUTES_PER_HOUR if self . hoursSinceFullMoon < 13 : output . append ( \"Full moon is up now!\" ) else : output . append ( \"Next full moon rises in \" + f \" { nextFullMoonRlHours } real-life hour { 's' if nextFullMoonRlHours != 1 else '' } \" + f \"and { nextFullMoonRlMinutes } minute { 's' if nextFullMoonRlMinutes != 1 else '' } .\" ) if ( self . hoursUntilFullMoon > HOURS_PER_MOON_RISE - DK_OPEN_DURATION and self . hoursSinceFullMoon >= HOURS_PER_MOON_RISE + DK_OPEN_DURATION ): nextDkDay = 1 ticksUntilDk = ( self . hoursUntilFullMoon - HOURS_PER_MOON_RISE if self . hoursUntilFullMoon > HOURS_PER_MOON_RISE else 0 ) elif ( self . hoursUntilFullMoon <= HOURS_PER_MOON_RISE - DK_OPEN_DURATION or self . hoursSinceFullMoon < DK_OPEN_DURATION ): nextDkDay = 2 ticksUntilDk = 0 if self . hoursSinceFullMoon < DK_OPEN_DURATION else self . hoursUntilFullMoon else : nextDkDay = 3 ticksUntilDk = ( HOURS_PER_MOON_RISE - self . hoursSinceFullMoon if self . hoursSinceFullMoon < HOURS_PER_MOON_RISE else 0 ) nextDkInRlHours = ticksUntilDk // MINUTES_PER_HOUR nextDkInRlMinutes = ticksUntilDk % MINUTES_PER_HOUR if not ticksUntilDk : output . append ( \"DK is open now!\" ) else : output . append ( f \"DK opens in { nextDkInRlHours } real-life hour { 's' if nextDkInRlHours != 1 else '' } and \" + f \" { nextDkInRlMinutes } minute { 's' if nextDkInRlMinutes != 1 else '' } (day { nextDkDay } of 3).\" ) return \" \\n \" . join ( output ) Attribute amPm : str property readonly \u00b6 The AM - PM value. Attribute dawn : int property readonly \u00b6 The hour of dawn. Attribute dawnDuskState : tuple [ str , str , int ] property readonly \u00b6 A tuple containing the current state name, the next state name, and the game hours until next state. Attribute day : int property readonly \u00b6 The day of the month (1 or more). Attribute dayOfYear : int property readonly \u00b6 The day of the year (1 or more). Attribute daysSinceFullMoon : int property readonly \u00b6 The days since last full moon (0 or more). Attribute daysSinceMoonCycle : int property readonly \u00b6 The days since last moon cycle (0 or more). Attribute daysUntilFullMoon : int property readonly \u00b6 The days until next full moon (1 or more). Attribute daysUntilMoonCycle : int property readonly \u00b6 The days until next moon cycle (1 or more). Attribute daysUntilSeason : int property readonly \u00b6 The days until next season (1 or more). Attribute daysUntilWinter : int property readonly \u00b6 The days until next winter (1 or more). Attribute delta : int property readonly \u00b6 The time as a delta. Attribute dusk : int property readonly \u00b6 The hour of dusk. Attribute hour : int property readonly \u00b6 The hour of the day (0 or more). Attribute hourOfMoonRise : int property readonly \u00b6 The hour of day when the moon will rise (0 or more). Attribute hourOfYear : int property readonly \u00b6 The hour of the year (0 or more). Attribute hoursSinceFullMoon : int property readonly \u00b6 The hours since last full moon (0 or more). Attribute hoursUntilFullMoon : int property readonly \u00b6 The hours Until full moon (1 or more). Attribute info : str property readonly \u00b6 A summery of information about this moment in Mume time. Attribute minutes : int property readonly \u00b6 The minutes of the hour (0 or more). Attribute month : int property readonly \u00b6 The month of the year (0 or more). Attribute monthName : str property readonly \u00b6 The name of the month. Attribute monthSindarin : str property readonly \u00b6 The name of the month in Sindarin. Attribute monthWestron : str property readonly \u00b6 The name of the month in Westron. Attribute overallDay : int property readonly \u00b6 The sum of all the elapsed years in days and the day of year (1 or more). Attribute rlHoursUntilSeason : int property readonly \u00b6 The real life hours until next season (1 or more). Attribute rlHoursUntilWinter : int property readonly \u00b6 The real life hours until next winter (0 or more). Attribute season : str property readonly \u00b6 The name of the season. Attribute weekday : str property readonly \u00b6 The name of the weekday. Attribute year : int property readonly \u00b6 The year. Function deltaToTime ( delta ) \u00b6 Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default delta int The delta. required Returns: Type Description tuple[int, int, int, int, int] A tuple containing the Mume year, month, day, hour, and minutes. Source code in mapper\\clock.py def deltaToTime ( delta : int ) -> tuple [ int , int , int , int , int ]: \"\"\" Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: delta: The delta. Returns: A tuple containing the Mume year, month, day, hour, and minutes. \"\"\" year = delta // MINUTES_PER_YEAR + FIRST_YEAR delta %= MINUTES_PER_YEAR month = delta // MINUTES_PER_MONTH # 0 - 11. delta %= MINUTES_PER_MONTH day = delta // MINUTES_PER_DAY + 1 # 1 - 30. delta %= MINUTES_PER_DAY hour = delta // MINUTES_PER_HOUR # 0 - 23. delta %= MINUTES_PER_HOUR minutes = delta # 0 - 59. return year , month , day , hour , minutes Function timeToDelta ( year , month , day , hour , minutes ) \u00b6 Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Returns: Type Description int The delta. Source code in mapper\\clock.py def timeToDelta ( year : int , month : int , day : int , hour : int , minutes : int ) -> int : \"\"\" Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). Returns: The delta. \"\"\" return ( ( year - FIRST_YEAR ) * MINUTES_PER_YEAR + month * MINUTES_PER_MONTH + ( day - 1 ) * MINUTES_PER_DAY + hour * MINUTES_PER_HOUR + minutes )","title":"clock.py"},{"location":"api/clock/#mapper.clock","text":"","title":"clock"},{"location":"api/clock/#mapper.clock.Clock","text":"Source code in mapper\\clock.py class Clock ( object ): def __init__ ( self ) -> None : self . _epoch : Optional [ int ] = None @property def epoch ( self ) -> int : # pragma: no cover \"\"\" The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset. \"\"\" if self . _epoch is None : cfg = Config () self . _epoch = int ( cfg . get ( \"mume_epoch\" , 1517486451 )) del cfg return self . _epoch @epoch . setter def epoch ( self , value : int ) -> None : # pragma: no cover self . _epoch = value cfg = Config () cfg [ \"mume_epoch\" ] = int ( value ) cfg . save () del cfg def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info","title":"Clock"},{"location":"api/clock/#mapper.clock.Clock.epoch","text":"The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset.","title":"epoch"},{"location":"api/clock/#mapper.clock.Clock.setTime","text":"Sets the Mume epoch from the current Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Source code in mapper\\clock.py def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta","title":"setTime()"},{"location":"api/clock/#mapper.clock.Clock.time","text":"Outputs information about the current Mume time. Parameters: Name Type Description Default action Optional[str] An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. None Returns: Type Description str The requested output. Source code in mapper\\clock.py def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info","title":"time()"},{"location":"api/clock/#mapper.clock.MumeTime","text":"Source code in mapper\\clock.py class MumeTime ( object ): def __init__ ( self , delta : int ) -> None : self . _year , self . _month , self . _day , self . _hour , self . _minutes = deltaToTime ( delta ) @property def year ( self ) -> int : \"\"\"The year.\"\"\" return self . _year @property def month ( self ) -> int : \"\"\"The month of the year (0 or more).\"\"\" return self . _month @property def day ( self ) -> int : \"\"\"The day of the month (1 or more).\"\"\" return self . _day @property def hour ( self ) -> int : \"\"\"The hour of the day (0 or more).\"\"\" return self . _hour @property def minutes ( self ) -> int : \"\"\"The minutes of the hour (0 or more).\"\"\" return self . _minutes @property def delta ( self ) -> int : \"\"\"The time as a delta.\"\"\" return timeToDelta ( self . year , self . month , self . day , self . hour , self . minutes ) @property def amPm ( self ) -> str : \"\"\"The AM - PM value.\"\"\" return \"am\" if self . hour < 12 else \"pm\" @property def dayOfYear ( self ) -> int : \"\"\"The day of the year (1 or more).\"\"\" return self . month * DAYS_PER_MONTH + self . day @property def hourOfYear ( self ) -> int : \"\"\"The hour of the year (0 or more).\"\"\" return ( self . dayOfYear - 1 ) * HOURS_PER_DAY + self . hour @property def overallDay ( self ) -> int : \"\"\"The sum of all the elapsed years in days and the day of year (1 or more).\"\"\" return ( self . year - FIRST_YEAR ) * DAYS_PER_YEAR + self . dayOfYear @property def weekday ( self ) -> str : \"\"\"The name of the weekday.\"\"\" return WEEKDAYS [ self . overallDay % DAYS_PER_WEEK ][ \"name\" ] @property def dawn ( self ) -> int : \"\"\"The hour of dawn.\"\"\" return int ( MONTHS [ self . month ][ \"dawn\" ]) @property def dusk ( self ) -> int : \"\"\"The hour of dusk.\"\"\" return int ( MONTHS [ self . month ][ \"dusk\" ]) @property def season ( self ) -> str : \"\"\"The name of the season.\"\"\" return str ( MONTHS [ self . month ][ \"season\" ]) @property def monthName ( self ) -> str : \"\"\"The name of the month.\"\"\" return str ( MONTHS [ self . month ][ \"name\" ]) @property def monthWestron ( self ) -> str : \"\"\"The name of the month in Westron.\"\"\" return str ( MONTHS [ self . month ][ \"westron\" ]) @property def monthSindarin ( self ) -> str : \"\"\"The name of the month in Sindarin.\"\"\" return str ( MONTHS [ self . month ][ \"sindarin\" ]) @property def dawnDuskState ( self ) -> tuple [ str , str , int ]: \"\"\"A tuple containing the current state name, the next state name, and the game hours until next state.\"\"\" if self . hour < self . dawn : state = \"NIGHT\" nextState = \"DAY\" untilNextState = self . dawn - self . hour + 1 elif self . hour >= self . dusk : state = \"NIGHT\" nextState = \"DAY\" untilNextState = HOURS_PER_DAY + self . dawn - self . hour + 1 elif self . hour > self . dawn and self . hour < self . dusk : state = \"DAY\" nextState = \"NIGHT\" untilNextState = self . dusk - self . hour elif self . hour == self . dawn : state = \"DAWN\" nextState = \"DAY\" untilNextState = 1 return state , nextState , untilNextState @property def daysUntilSeason ( self ) -> int : \"\"\"The days until next season (1 or more).\"\"\" monthsSinceLastSeason = ( self . month + 1 ) % MONTHS_PER_SEASON daysSinceLastSeason = monthsSinceLastSeason * DAYS_PER_MONTH + ( self . day - 1 ) return DAYS_PER_SEASON - daysSinceLastSeason @property def rlHoursUntilSeason ( self ) -> int : \"\"\"The real life hours until next season (1 or more).\"\"\" return self . daysUntilSeason * HOURS_PER_DAY // MINUTES_PER_HOUR @property def daysUntilWinter ( self ) -> int : \"\"\"The days until next winter (1 or more).\"\"\" monthsSinceLastWinter = ( self . month + 1 ) % MONTHS_PER_YEAR daysSinceLastWinter = monthsSinceLastWinter * DAYS_PER_MONTH + ( self . day - 1 ) return DAYS_PER_YEAR - daysSinceLastWinter @property def rlHoursUntilWinter ( self ) -> int : \"\"\"The real life hours until next winter (0 or more).\"\"\" return self . daysUntilWinter * HOURS_PER_DAY // MINUTES_PER_HOUR @property def daysSinceMoonCycle ( self ) -> int : \"\"\"The days since last moon cycle (0 or more).\"\"\" return ( self . dayOfYear - FIRST_MOON_CYCLE_DAY ) % DAYS_PER_MOON_CYCLE @property def daysUntilMoonCycle ( self ) -> int : \"\"\"The days until next moon cycle (1 or more).\"\"\" return DAYS_PER_MOON_CYCLE - self . daysSinceMoonCycle @property def hourOfMoonRise ( self ) -> int : \"\"\"The hour of day when the moon will rise (0 or more).\"\"\" return ( FIRST_MOON_CYCLE_HOUR + self . daysSinceMoonCycle ) % HOURS_PER_DAY @property def daysSinceFullMoon ( self ) -> int : \"\"\"The days since last full moon (0 or more).\"\"\" return ( self . dayOfYear - FIRST_FULL_MOON_DAY ) % DAYS_PER_MOON_CYCLE @property def daysUntilFullMoon ( self ) -> int : \"\"\"The days until next full moon (1 or more).\"\"\" return DAYS_PER_MOON_CYCLE - self . daysSinceFullMoon @property def hoursSinceFullMoon ( self ) -> int : \"\"\"The hours since last full moon (0 or more).\"\"\" return ( self . daysSinceFullMoon * HOURS_PER_DAY + self . hour - FULL_MOON_HOUR ) % HOURS_PER_MOON_CYCLE @property def hoursUntilFullMoon ( self ) -> int : \"\"\"The hours Until full moon (1 or more).\"\"\" return HOURS_PER_MOON_CYCLE - self . hoursSinceFullMoon @property def info ( self ) -> str : # pragma: no cover \"\"\"A summery of information about this moment in Mume time.\"\"\" output = [] output . append ( f \"Game time { self . hour % 12 or 12 } : { self . minutes : 02d } { self . amPm } : \" + f \"Dawn: { self . dawn } am, Dusk: { self . dusk - 12 } pm.\" ) state , nextState , untilNextState = self . dawnDuskState output . append ( f \"It is currently { state } , on { self . weekday } , { self . monthName } { self . day } \" + f \"( { self . monthWestron } / { self . monthSindarin } ), ( { self . season } ), year { self . year } of the third age.\" ) output . append ( f \"Time left until { nextState } is less than { untilNextState } tick { 's' if untilNextState != 1 else '!' } \" ) output . append ( f \" { self . season [ - 6 :] } ends in \" + f \" { self . daysUntilSeason } mume day { 's' if self . daysUntilSeason != 1 else '' } or \" + f \" { self . rlHoursUntilSeason } real-life hour { 's' if self . rlHoursUntilSeason != 1 else '' } .\" ) rlDaysUntilWinter = self . rlHoursUntilWinter // HOURS_PER_DAY rlHoursUntilWinter = self . rlHoursUntilWinter % HOURS_PER_DAY output . append ( f \"Next winter starts in { rlDaysUntilWinter } real-life day { 's' if rlDaysUntilWinter != 1 else '' } \" + f \"and { rlHoursUntilWinter } hour { 's' if rlHoursUntilWinter != 1 else '' } .\" ) hourOfMoonRise = self . hourOfMoonRise if self . hour == hourOfMoonRise : output . append ( \"Moon is up now!\" ) else : if self . hour > hourOfMoonRise : hourOfMoonRise = ( hourOfMoonRise + 1 ) % HOURS_PER_DAY dayOfMoonRise = \"tomorrow\" else : dayOfMoonRise = \"today\" output . append ( f \"Next moon rise { dayOfMoonRise } at { hourOfMoonRise % 12 or 12 } :00 \" + f \" { 'am' if hourOfMoonRise < 12 else 'pm' } (game time).\" ) nextFullMoonRlHours = self . hoursUntilFullMoon // MINUTES_PER_HOUR nextFullMoonRlMinutes = self . hoursUntilFullMoon % MINUTES_PER_HOUR if self . hoursSinceFullMoon < 13 : output . append ( \"Full moon is up now!\" ) else : output . append ( \"Next full moon rises in \" + f \" { nextFullMoonRlHours } real-life hour { 's' if nextFullMoonRlHours != 1 else '' } \" + f \"and { nextFullMoonRlMinutes } minute { 's' if nextFullMoonRlMinutes != 1 else '' } .\" ) if ( self . hoursUntilFullMoon > HOURS_PER_MOON_RISE - DK_OPEN_DURATION and self . hoursSinceFullMoon >= HOURS_PER_MOON_RISE + DK_OPEN_DURATION ): nextDkDay = 1 ticksUntilDk = ( self . hoursUntilFullMoon - HOURS_PER_MOON_RISE if self . hoursUntilFullMoon > HOURS_PER_MOON_RISE else 0 ) elif ( self . hoursUntilFullMoon <= HOURS_PER_MOON_RISE - DK_OPEN_DURATION or self . hoursSinceFullMoon < DK_OPEN_DURATION ): nextDkDay = 2 ticksUntilDk = 0 if self . hoursSinceFullMoon < DK_OPEN_DURATION else self . hoursUntilFullMoon else : nextDkDay = 3 ticksUntilDk = ( HOURS_PER_MOON_RISE - self . hoursSinceFullMoon if self . hoursSinceFullMoon < HOURS_PER_MOON_RISE else 0 ) nextDkInRlHours = ticksUntilDk // MINUTES_PER_HOUR nextDkInRlMinutes = ticksUntilDk % MINUTES_PER_HOUR if not ticksUntilDk : output . append ( \"DK is open now!\" ) else : output . append ( f \"DK opens in { nextDkInRlHours } real-life hour { 's' if nextDkInRlHours != 1 else '' } and \" + f \" { nextDkInRlMinutes } minute { 's' if nextDkInRlMinutes != 1 else '' } (day { nextDkDay } of 3).\" ) return \" \\n \" . join ( output )","title":"MumeTime"},{"location":"api/clock/#mapper.clock.MumeTime.amPm","text":"The AM - PM value.","title":"amPm"},{"location":"api/clock/#mapper.clock.MumeTime.dawn","text":"The hour of dawn.","title":"dawn"},{"location":"api/clock/#mapper.clock.MumeTime.dawnDuskState","text":"A tuple containing the current state name, the next state name, and the game hours until next state.","title":"dawnDuskState"},{"location":"api/clock/#mapper.clock.MumeTime.day","text":"The day of the month (1 or more).","title":"day"},{"location":"api/clock/#mapper.clock.MumeTime.dayOfYear","text":"The day of the year (1 or more).","title":"dayOfYear"},{"location":"api/clock/#mapper.clock.MumeTime.daysSinceFullMoon","text":"The days since last full moon (0 or more).","title":"daysSinceFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.daysSinceMoonCycle","text":"The days since last moon cycle (0 or more).","title":"daysSinceMoonCycle"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilFullMoon","text":"The days until next full moon (1 or more).","title":"daysUntilFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilMoonCycle","text":"The days until next moon cycle (1 or more).","title":"daysUntilMoonCycle"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilSeason","text":"The days until next season (1 or more).","title":"daysUntilSeason"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilWinter","text":"The days until next winter (1 or more).","title":"daysUntilWinter"},{"location":"api/clock/#mapper.clock.MumeTime.delta","text":"The time as a delta.","title":"delta"},{"location":"api/clock/#mapper.clock.MumeTime.dusk","text":"The hour of dusk.","title":"dusk"},{"location":"api/clock/#mapper.clock.MumeTime.hour","text":"The hour of the day (0 or more).","title":"hour"},{"location":"api/clock/#mapper.clock.MumeTime.hourOfMoonRise","text":"The hour of day when the moon will rise (0 or more).","title":"hourOfMoonRise"},{"location":"api/clock/#mapper.clock.MumeTime.hourOfYear","text":"The hour of the year (0 or more).","title":"hourOfYear"},{"location":"api/clock/#mapper.clock.MumeTime.hoursSinceFullMoon","text":"The hours since last full moon (0 or more).","title":"hoursSinceFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.hoursUntilFullMoon","text":"The hours Until full moon (1 or more).","title":"hoursUntilFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.info","text":"A summery of information about this moment in Mume time.","title":"info"},{"location":"api/clock/#mapper.clock.MumeTime.minutes","text":"The minutes of the hour (0 or more).","title":"minutes"},{"location":"api/clock/#mapper.clock.MumeTime.month","text":"The month of the year (0 or more).","title":"month"},{"location":"api/clock/#mapper.clock.MumeTime.monthName","text":"The name of the month.","title":"monthName"},{"location":"api/clock/#mapper.clock.MumeTime.monthSindarin","text":"The name of the month in Sindarin.","title":"monthSindarin"},{"location":"api/clock/#mapper.clock.MumeTime.monthWestron","text":"The name of the month in Westron.","title":"monthWestron"},{"location":"api/clock/#mapper.clock.MumeTime.overallDay","text":"The sum of all the elapsed years in days and the day of year (1 or more).","title":"overallDay"},{"location":"api/clock/#mapper.clock.MumeTime.rlHoursUntilSeason","text":"The real life hours until next season (1 or more).","title":"rlHoursUntilSeason"},{"location":"api/clock/#mapper.clock.MumeTime.rlHoursUntilWinter","text":"The real life hours until next winter (0 or more).","title":"rlHoursUntilWinter"},{"location":"api/clock/#mapper.clock.MumeTime.season","text":"The name of the season.","title":"season"},{"location":"api/clock/#mapper.clock.MumeTime.weekday","text":"The name of the weekday.","title":"weekday"},{"location":"api/clock/#mapper.clock.MumeTime.year","text":"The year.","title":"year"},{"location":"api/clock/#mapper.clock.deltaToTime","text":"Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default delta int The delta. required Returns: Type Description tuple[int, int, int, int, int] A tuple containing the Mume year, month, day, hour, and minutes. Source code in mapper\\clock.py def deltaToTime ( delta : int ) -> tuple [ int , int , int , int , int ]: \"\"\" Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: delta: The delta. Returns: A tuple containing the Mume year, month, day, hour, and minutes. \"\"\" year = delta // MINUTES_PER_YEAR + FIRST_YEAR delta %= MINUTES_PER_YEAR month = delta // MINUTES_PER_MONTH # 0 - 11. delta %= MINUTES_PER_MONTH day = delta // MINUTES_PER_DAY + 1 # 1 - 30. delta %= MINUTES_PER_DAY hour = delta // MINUTES_PER_HOUR # 0 - 23. delta %= MINUTES_PER_HOUR minutes = delta # 0 - 59. return year , month , day , hour , minutes","title":"deltaToTime()"},{"location":"api/clock/#mapper.clock.timeToDelta","text":"Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Returns: Type Description int The delta. Source code in mapper\\clock.py def timeToDelta ( year : int , month : int , day : int , hour : int , minutes : int ) -> int : \"\"\" Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). Returns: The delta. \"\"\" return ( ( year - FIRST_YEAR ) * MINUTES_PER_YEAR + month * MINUTES_PER_MONTH + ( day - 1 ) * MINUTES_PER_DAY + hour * MINUTES_PER_HOUR + minutes )","title":"timeToDelta()"},{"location":"api/config/","text":"Module mapper.config \u00b6 Class Config( MutableMapping , Generic ) \u00b6 Implements loading and saving of program configuration. Source code in mapper\\config.py class Config ( MutableMapping [ str , Any ]): \"\"\" Implements loading and saving of program configuration. \"\"\" _configLock : threading . RLock = threading . RLock () def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . _name : str = name self . _config : dict [ str , Any ] = {} self . reload () @property def name ( self ) -> str : \"\"\"The name of the configuration.\"\"\" return self . _name def _parse ( self , filename : str ) -> dict [ str , Any ]: filename = os . path . join ( DATA_DIRECTORY , filename ) if not os . path . exists ( filename ): return {} elif os . path . isdir ( filename ): raise ConfigError ( f \"' { filename } ' is a directory, not a file.\" ) with self . _configLock : try : with open ( filename , \"r\" , encoding = \"utf-8\" ) as fileObj : return dict ( json . load ( fileObj )) except IOError as e : # pragma: no cover raise ConfigError ( f \" { e . strerror } : ' { e . filename } '\" ) except ValueError : raise ConfigError ( f \"Corrupted json file: { filename } \" ) def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . name } .json\" )) def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename : str = os . path . join ( DATA_DIRECTORY , f \" { self . name } .json\" ) with self . _configLock : newline : str = \" \\n \" with open ( filename , \"w\" , encoding = \"utf-8\" , newline = newline ) as fileObj : json . dump ( self . _config , fileObj , sort_keys = True , indent = 2 ) fileObj . write ( newline ) def __getitem__ ( self , key : str ) -> Any : return self . _config [ key ] def __setitem__ ( self , key : str , value : Any ) -> None : self . _config [ key ] = value def __delitem__ ( self , key : str ) -> None : del self . _config [ key ] def __iter__ ( self ) -> Iterator [ str ]: return iter ( self . _config ) def __len__ ( self ) -> int : return len ( self . _config ) Attribute name : str property readonly \u00b6 The name of the configuration. Method __init__ ( self , name = 'config' ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default name str The name of the configuration. 'config' Source code in mapper\\config.py def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . _name : str = name self . _config : dict [ str , Any ] = {} self . reload () Method clear ( self ) inherited \u00b6 D.clear() -> None. Remove all items from D. Method get ( self , key , default = None ) inherited \u00b6 D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Method items ( self ) inherited \u00b6 D.items() -> a set-like object providing a view on D's items Method keys ( self ) inherited \u00b6 D.keys() -> a set-like object providing a view on D's keys Method pop ( self , key , default =< object object at 0x000002DB8A568200 > ) inherited \u00b6 D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Method popitem ( self ) inherited \u00b6 D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. Method reload ( self ) \u00b6 Reloads the configuration from disc. Source code in mapper\\config.py def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . name } .json\" )) Method save ( self ) \u00b6 Saves the configuration to disc. Source code in mapper\\config.py def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename : str = os . path . join ( DATA_DIRECTORY , f \" { self . name } .json\" ) with self . _configLock : newline : str = \" \\n \" with open ( filename , \"w\" , encoding = \"utf-8\" , newline = newline ) as fileObj : json . dump ( self . _config , fileObj , sort_keys = True , indent = 2 ) fileObj . write ( newline ) Method setdefault ( self , key , default = None ) inherited \u00b6 D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Method update ( / , self , other = (), ** kwds ) inherited \u00b6 D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Method values ( self ) inherited \u00b6 D.values() -> an object providing a view on D's values Class ConfigError( Exception ) \u00b6 Implements the base class for Config exceptions. Source code in mapper\\config.py class ConfigError ( Exception ): \"\"\"Implements the base class for Config exceptions.\"\"\"","title":"config.py"},{"location":"api/config/#mapper.config","text":"","title":"config"},{"location":"api/config/#mapper.config.Config","text":"Implements loading and saving of program configuration. Source code in mapper\\config.py class Config ( MutableMapping [ str , Any ]): \"\"\" Implements loading and saving of program configuration. \"\"\" _configLock : threading . RLock = threading . RLock () def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . _name : str = name self . _config : dict [ str , Any ] = {} self . reload () @property def name ( self ) -> str : \"\"\"The name of the configuration.\"\"\" return self . _name def _parse ( self , filename : str ) -> dict [ str , Any ]: filename = os . path . join ( DATA_DIRECTORY , filename ) if not os . path . exists ( filename ): return {} elif os . path . isdir ( filename ): raise ConfigError ( f \"' { filename } ' is a directory, not a file.\" ) with self . _configLock : try : with open ( filename , \"r\" , encoding = \"utf-8\" ) as fileObj : return dict ( json . load ( fileObj )) except IOError as e : # pragma: no cover raise ConfigError ( f \" { e . strerror } : ' { e . filename } '\" ) except ValueError : raise ConfigError ( f \"Corrupted json file: { filename } \" ) def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . name } .json\" )) def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename : str = os . path . join ( DATA_DIRECTORY , f \" { self . name } .json\" ) with self . _configLock : newline : str = \" \\n \" with open ( filename , \"w\" , encoding = \"utf-8\" , newline = newline ) as fileObj : json . dump ( self . _config , fileObj , sort_keys = True , indent = 2 ) fileObj . write ( newline ) def __getitem__ ( self , key : str ) -> Any : return self . _config [ key ] def __setitem__ ( self , key : str , value : Any ) -> None : self . _config [ key ] = value def __delitem__ ( self , key : str ) -> None : del self . _config [ key ] def __iter__ ( self ) -> Iterator [ str ]: return iter ( self . _config ) def __len__ ( self ) -> int : return len ( self . _config )","title":"Config"},{"location":"api/config/#mapper.config.Config.name","text":"The name of the configuration.","title":"name"},{"location":"api/config/#mapper.config.Config.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default name str The name of the configuration. 'config' Source code in mapper\\config.py def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . _name : str = name self . _config : dict [ str , Any ] = {} self . reload ()","title":"__init__()"},{"location":"api/config/#mapper.config.Config.clear","text":"D.clear() -> None. Remove all items from D.","title":"clear()"},{"location":"api/config/#mapper.config.Config.get","text":"D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.","title":"get()"},{"location":"api/config/#mapper.config.Config.items","text":"D.items() -> a set-like object providing a view on D's items","title":"items()"},{"location":"api/config/#mapper.config.Config.keys","text":"D.keys() -> a set-like object providing a view on D's keys","title":"keys()"},{"location":"api/config/#mapper.config.Config.pop","text":"D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.","title":"pop()"},{"location":"api/config/#mapper.config.Config.popitem","text":"D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.","title":"popitem()"},{"location":"api/config/#mapper.config.Config.reload","text":"Reloads the configuration from disc. Source code in mapper\\config.py def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . name } .json\" ))","title":"reload()"},{"location":"api/config/#mapper.config.Config.save","text":"Saves the configuration to disc. Source code in mapper\\config.py def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename : str = os . path . join ( DATA_DIRECTORY , f \" { self . name } .json\" ) with self . _configLock : newline : str = \" \\n \" with open ( filename , \"w\" , encoding = \"utf-8\" , newline = newline ) as fileObj : json . dump ( self . _config , fileObj , sort_keys = True , indent = 2 ) fileObj . write ( newline )","title":"save()"},{"location":"api/config/#mapper.config.Config.setdefault","text":"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D","title":"setdefault()"},{"location":"api/config/#mapper.config.Config.update","text":"D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v","title":"update()"},{"location":"api/config/#mapper.config.Config.values","text":"D.values() -> an object providing a view on D's values","title":"values()"},{"location":"api/config/#mapper.config.ConfigError","text":"Implements the base class for Config exceptions. Source code in mapper\\config.py class ConfigError ( Exception ): \"\"\"Implements the base class for Config exceptions.\"\"\"","title":"ConfigError"},{"location":"api/delays/","text":"Module mapper.delays \u00b6 Class BaseDelay( Thread ) \u00b6 Implements the base delay class. Source code in mapper\\delays.py class BaseDelay ( threading . Thread ): \"\"\" Implements the base delay class. \"\"\" def __init__ ( self , duration : float , count : Union [ int , None ], function : Callable [ ... , Any ], * args : Any , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon : bool = True self . _duration : float = duration self . _count : Union [ int , None ] = count self . _function : Callable [ ... , Any ] = function self . _args : tuple [ Any , ... ] = args self . _kwargs : dict [ str , Any ] = kwargs self . _finished : threading . Event = threading . Event () def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop () Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method __init__ ( self , duration , count , function , * args , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required count Union[int, None] The number of iterations to delay, or None to repeat indefinitely. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , count : Union [ int , None ], function : Callable [ ... , Any ], * args : Any , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon : bool = True self . _duration : float = duration self . _count : Union [ int , None ] = count self . _function : Callable [ ... , Any ] = function self . _args : tuple [ Any , ... ] = args self . _kwargs : dict [ str , Any ] = kwargs self . _finished : threading . Event = threading . Event () Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop () Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class Delay( BaseDelay ) \u00b6 Implements a delay which automatically starts upon creation. Source code in mapper\\delays.py class Delay ( BaseDelay ): \"\"\" Implements a delay which automatically starts upon creation. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . start () Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop () Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class OneShot( Delay ) \u00b6 Implements a delay which is run only once. Source code in mapper\\delays.py class OneShot ( Delay ): \"\"\" Implements a delay which is run only once. \"\"\" def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs ) Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method __init__ ( self , duration , function , * args , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay. required function Callable[..., Any] The function to be called when the delay completes. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs ) Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop () Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class Repeating( Delay ) \u00b6 Implements a delay which runs indefinitely. Source code in mapper\\delays.py class Repeating ( Delay ): \"\"\" Implements a delay which runs indefinitely. \"\"\" def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs ) Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method __init__ ( self , duration , function , * args , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs ) Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop () Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"delays.py"},{"location":"api/delays/#mapper.delays","text":"","title":"delays"},{"location":"api/delays/#mapper.delays.BaseDelay","text":"Implements the base delay class. Source code in mapper\\delays.py class BaseDelay ( threading . Thread ): \"\"\" Implements the base delay class. \"\"\" def __init__ ( self , duration : float , count : Union [ int , None ], function : Callable [ ... , Any ], * args : Any , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon : bool = True self . _duration : float = duration self . _count : Union [ int , None ] = count self . _function : Callable [ ... , Any ] = function self . _args : tuple [ Any , ... ] = args self . _kwargs : dict [ str , Any ] = kwargs self . _finished : threading . Event = threading . Event () def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop ()","title":"BaseDelay"},{"location":"api/delays/#mapper.delays.BaseDelay.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.BaseDelay.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.BaseDelay.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.BaseDelay.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/delays/#mapper.delays.BaseDelay.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required count Union[int, None] The number of iterations to delay, or None to repeat indefinitely. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , count : Union [ int , None ], function : Callable [ ... , Any ], * args : Any , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon : bool = True self . _duration : float = duration self . _count : Union [ int , None ] = count self . _function : Callable [ ... , Any ] = function self . _args : tuple [ Any , ... ] = args self . _kwargs : dict [ str , Any ] = kwargs self . _finished : threading . Event = threading . Event ()","title":"__init__()"},{"location":"api/delays/#mapper.delays.BaseDelay.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/delays/#mapper.delays.BaseDelay.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/delays/#mapper.delays.BaseDelay.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.BaseDelay.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.BaseDelay.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.BaseDelay.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/delays/#mapper.delays.BaseDelay.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/delays/#mapper.delays.BaseDelay.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.BaseDelay.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.Delay","text":"Implements a delay which automatically starts upon creation. Source code in mapper\\delays.py class Delay ( BaseDelay ): \"\"\" Implements a delay which automatically starts upon creation. \"\"\" def __init__ ( self , * args : Any , ** kwargs : Any ) -> None : super () . __init__ ( * args , ** kwargs ) self . start ()","title":"Delay"},{"location":"api/delays/#mapper.delays.Delay.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.Delay.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.Delay.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.Delay.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/delays/#mapper.delays.Delay.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/delays/#mapper.delays.Delay.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/delays/#mapper.delays.Delay.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.Delay.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.Delay.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.Delay.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/delays/#mapper.delays.Delay.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/delays/#mapper.delays.Delay.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.Delay.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.OneShot","text":"Implements a delay which is run only once. Source code in mapper\\delays.py class OneShot ( Delay ): \"\"\" Implements a delay which is run only once. \"\"\" def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs )","title":"OneShot"},{"location":"api/delays/#mapper.delays.OneShot.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.OneShot.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.OneShot.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.OneShot.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/delays/#mapper.delays.OneShot.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay. required function Callable[..., Any] The function to be called when the delay completes. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs )","title":"__init__()"},{"location":"api/delays/#mapper.delays.OneShot.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/delays/#mapper.delays.OneShot.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/delays/#mapper.delays.OneShot.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.OneShot.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.OneShot.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.OneShot.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/delays/#mapper.delays.OneShot.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/delays/#mapper.delays.OneShot.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.OneShot.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.Repeating","text":"Implements a delay which runs indefinitely. Source code in mapper\\delays.py class Repeating ( Delay ): \"\"\" Implements a delay which runs indefinitely. \"\"\" def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs )","title":"Repeating"},{"location":"api/delays/#mapper.delays.Repeating.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.Repeating.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.Repeating.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.Repeating.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/delays/#mapper.delays.Repeating.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default duration float The amount of time (in seconds) to delay between iterations. required function Callable[..., Any] The function to be called at each iteration. required *args Any Positional arguments to be passed to the called function. () **kwargs Any Key-word only arguments to be passed to the called function. {} Source code in mapper\\delays.py def __init__ ( self , duration : float , function : Callable [ ... , Any ], * args : Any , ** kwargs : Any ) -> None : \"\"\" Defines the constructor for the object. Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. *args: Positional arguments to be passed to the called function. **kwargs: Key-word only arguments to be passed to the called function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs )","title":"__init__()"},{"location":"api/delays/#mapper.delays.Repeating.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/delays/#mapper.delays.Repeating.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\delays.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/delays/#mapper.delays.Repeating.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\delays.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.Repeating.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.Repeating.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py def run ( self ) -> None : try : while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs if not self . _finished . is_set (): self . stop ()","title":"run()"},{"location":"api/delays/#mapper.delays.Repeating.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\delays.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/delays/#mapper.delays.Repeating.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\delays.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/delays/#mapper.delays.Repeating.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.Repeating.stop","text":"Stops an active delay. Source code in mapper\\delays.py def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/main/","text":"Module mapper.main \u00b6 Class ArgumentParser( Tap ) \u00b6 Source code in mapper\\main.py class ArgumentParser ( Tap ): emulation : bool = False \"\"\"Start in emulation mode.\"\"\" interface : LITERAL_INTERFACES = INTERFACES [ 0 ] \"\"\"Select a user interface.\"\"\" format : LITERAL_OUTPUT_FORMATS = OUTPUT_FORMATS [ 0 ] \"\"\"Select how data from the server is transformed before being sent to the client.\"\"\" local_host : str = \"127.0.0.1\" \"\"\"The local host address to bind to.\"\"\" local_port : int = 4000 \"\"\"The local port to bind to.\"\"\" remote_host : str = \"mume.org\" \"\"\"The remote host address to connect to.\"\"\" remote_port : int = 4242 \"\"\"The remote port to connect to.\"\"\" no_ssl : bool = False \"\"\"Disable encrypted communication between the local and remote hosts.\"\"\" prompt_terminator_lf : bool = False \"\"\"Terminate game prompts with return-linefeed characters (IAC + GA is default).\"\"\" gag_prompts : bool = False \"\"\"Gag emulated prompts.\"\"\" find_format : str = \" {vnum} , {name} , {attribute} \" \"\"\" The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute}, {direction}, {clockPosition}, {distance}, {name}, {vnum}. Where {attribute} represents the attribute on which the search is performed. \"\"\" def configure ( self ) -> None : version : str = ( f \"%(prog)s v { __version__ } \" + f \"(Python { '.' . join ( str ( i ) for i in sys . version_info [: 3 ]) } { sys . version_info . releaselevel } )\" ) self . add_argument ( \"-v\" , \"--version\" , help = \"Print the program version as well as the Python version.\" , action = \"version\" , version = version , ) self . add_argument ( \"-e\" , \"--emulation\" ) self . add_argument ( \"-i\" , \"--interface\" ) self . add_argument ( \"-f\" , \"--format\" ) self . add_argument ( \"-lh\" , \"--local_host\" , metavar = \"address\" ) self . add_argument ( \"-lp\" , \"--local_port\" , metavar = \"port\" ) self . add_argument ( \"-rh\" , \"--remote_host\" , metavar = \"address\" ) self . add_argument ( \"-rp\" , \"--remote_port\" , metavar = \"port\" ) self . add_argument ( \"-nssl\" , \"--no_ssl\" ) self . add_argument ( \"-ptlf\" , \"--prompt_terminator_lf\" ) self . add_argument ( \"-gp\" , \"--gag_prompts\" ) self . add_argument ( \"-ff\" , \"--find_format\" , metavar = \"text\" ) Attribute emulation : bool \u00b6 Start in emulation mode. Attribute find_format : str \u00b6 The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute}, {direction}, {clockPosition}, {distance}, {name}, {vnum}. Where {attribute} represents the attribute on which the search is performed. Attribute format : Literal [ 'normal' , 'raw' , 'tintin' ] \u00b6 Select how data from the server is transformed before being sent to the client. Attribute gag_prompts : bool \u00b6 Gag emulated prompts. Attribute interface : Literal [ 'text' , 'hc' , 'sighted' ] \u00b6 Select a user interface. Attribute local_host : str \u00b6 The local host address to bind to. Attribute local_port : int \u00b6 The local port to bind to. Attribute no_ssl : bool \u00b6 Disable encrypted communication between the local and remote hosts. Attribute prompt_terminator_lf : bool \u00b6 Terminate game prompts with return-linefeed characters (IAC + GA is default). Attribute remote_host : str \u00b6 The remote host address to connect to. Attribute remote_port : int \u00b6 The remote port to connect to. Method add_argument ( self , * name_or_flags , ** kwargs ) inherited \u00b6 Adds an argument to the argument buffer, which will later be passed to _add_argument. Source code in mapper\\main.py def add_argument ( self , * name_or_flags , ** kwargs ) -> None : \"\"\"Adds an argument to the argument buffer, which will later be passed to _add_argument.\"\"\" if self . _initialized : raise ValueError ( \"add_argument cannot be called after initialization. \" \"Arguments must be added either as class variables or by overriding \" \"configure and including a self.add_argument call there.\" ) variable = get_argument_name ( * name_or_flags ) . replace ( \"-\" , \"_\" ) self . argument_buffer [ variable ] = ( name_or_flags , kwargs ) Method add_subparser ( self , flag , subparser_type , ** kwargs ) inherited \u00b6 Add a subparser to the collection of subparsers Source code in mapper\\main.py def add_subparser ( self , flag : str , subparser_type : type , ** kwargs ) -> None : \"\"\"Add a subparser to the collection of subparsers\"\"\" help_desc = kwargs . get ( \"help\" , subparser_type . __doc__ ) kwargs [ \"help\" ] = help_desc self . _subparser_buffer . append (( flag , subparser_type , kwargs )) Method as_dict ( self ) inherited \u00b6 Returns the member variables corresponding to the parsed arguments. Note: This does not include attributes set directly on an instance (e.g. arg is not included in MyTap().arg = \"hi\") :return: A dictionary mapping each argument's name to its value. Source code in mapper\\main.py def as_dict ( self ) -> Dict [ str , Any ]: \"\"\"Returns the member variables corresponding to the parsed arguments. Note: This does not include attributes set directly on an instance (e.g. arg is not included in MyTap().arg = \"hi\") :return: A dictionary mapping each argument's name to its value. \"\"\" if not self . _parsed : raise ValueError ( \"You should call `parse_args` before retrieving arguments.\" ) self_dict = self . __dict__ class_dict = self . _get_from_self_and_super ( extract_func = lambda super_class : dict ( getattr ( super_class , \"__dict__\" , dict ())) ) class_dict = { key : val for key , val in class_dict . items () if key not in self_dict } stored_dict = { ** self_dict , ** class_dict } stored_dict = { var : getattr ( self , var ) for var , val in stored_dict . items () if not ( var . startswith ( \"_\" ) or isinstance ( val , MethodType ) or isinstance ( val , staticmethod )) } tap_class_dict_keys = Tap () . __dict__ . keys () | Tap . __dict__ . keys () stored_dict = { key : stored_dict [ key ] for key in stored_dict . keys () - tap_class_dict_keys } return stored_dict Method configure ( self ) \u00b6 Overwrite this method to configure the parser during initialization. For example, self.add_argument('--sum', dest='accumulate', action='store_const', const=sum, default=max) self.add_subparsers(help='sub-command help') self.add_subparser('a', SubparserA, help='a help') Source code in mapper\\main.py def configure ( self ) -> None : version : str = ( f \"%(prog)s v { __version__ } \" + f \"(Python { '.' . join ( str ( i ) for i in sys . version_info [: 3 ]) } { sys . version_info . releaselevel } )\" ) self . add_argument ( \"-v\" , \"--version\" , help = \"Print the program version as well as the Python version.\" , action = \"version\" , version = version , ) self . add_argument ( \"-e\" , \"--emulation\" ) self . add_argument ( \"-i\" , \"--interface\" ) self . add_argument ( \"-f\" , \"--format\" ) self . add_argument ( \"-lh\" , \"--local_host\" , metavar = \"address\" ) self . add_argument ( \"-lp\" , \"--local_port\" , metavar = \"port\" ) self . add_argument ( \"-rh\" , \"--remote_host\" , metavar = \"address\" ) self . add_argument ( \"-rp\" , \"--remote_port\" , metavar = \"port\" ) self . add_argument ( \"-nssl\" , \"--no_ssl\" ) self . add_argument ( \"-ptlf\" , \"--prompt_terminator_lf\" ) self . add_argument ( \"-gp\" , \"--gag_prompts\" ) self . add_argument ( \"-ff\" , \"--find_format\" , metavar = \"text\" ) Method error ( self , message ) inherited \u00b6 error(message: string) Prints a usage message incorporating the message to stderr and exits. If you override this in a subclass, it should not return -- it should either exit or raise an exception. Source code in mapper\\main.py def error ( self , message ): \"\"\"error(message: string) Prints a usage message incorporating the message to stderr and exits. If you override this in a subclass, it should not return -- it should either exit or raise an exception. \"\"\" self . print_usage ( _sys . stderr ) args = { 'prog' : self . prog , 'message' : message } self . exit ( 2 , _ ( ' %(prog)s : error: %(message)s \\n ' ) % args ) Method from_dict ( self , args_dict , skip_unsettable = False ) inherited \u00b6 Loads arguments from a dictionary, ensuring all required arguments are set. :param args_dict: A dictionary from argument names to the values of the arguments. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :return: Returns self. Source code in mapper\\main.py def from_dict ( self , args_dict : Dict [ str , Any ], skip_unsettable : bool = False ) -> TapType : \"\"\"Loads arguments from a dictionary, ensuring all required arguments are set. :param args_dict: A dictionary from argument names to the values of the arguments. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :return: Returns self. \"\"\" # All of the required arguments must be provided or already set required_args = { a . dest for a in self . _actions if a . required } unprovided_required_args = required_args - args_dict . keys () missing_required_args = [ arg for arg in unprovided_required_args if not hasattr ( self , arg )] if len ( missing_required_args ) > 0 : raise ValueError ( f 'Input dictionary \" { args_dict } \" does not include ' f 'all unset required arguments: \" { missing_required_args } \".' ) # Load all arguments for key , value in args_dict . items (): try : setattr ( self , key , value ) except AttributeError : if not skip_unsettable : raise AttributeError ( f 'Cannot set attribute \" { key } \" to \" { value } \". ' f \"To skip arguments that cannot be set \\n \" f ' \\t \"skip_unsettable = True\"' ) self . _parsed = True return self Method get_reproducibility_info ( repo_path = None ) inherited \u00b6 Gets a dictionary of reproducibility information. Reproducibility information always includes: - command_line: The command line command used to execute the code. - time: The current time. If git is installed, reproducibility information also includes: - git_root: The root of the git repo where the command is run. - git_url: The url of the current hash of the git repo where the command is run. Ex. https://github.com/swansonk14/rationale-alignment/tree/ - git_has_uncommitted_changes: Whether the current git repo has uncommitted changes. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: A dictionary of reproducibility information. Source code in mapper\\main.py @staticmethod def get_reproducibility_info ( repo_path : Optional [ PathLike ] = None ) -> Dict [ str , str ]: \"\"\"Gets a dictionary of reproducibility information. Reproducibility information always includes: - command_line: The command line command used to execute the code. - time: The current time. If git is installed, reproducibility information also includes: - git_root: The root of the git repo where the command is run. - git_url: The url of the current hash of the git repo where the command is run. Ex. https://github.com/swansonk14/rationale-alignment/tree/<hash> - git_has_uncommitted_changes: Whether the current git repo has uncommitted changes. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: A dictionary of reproducibility information. \"\"\" # Get the path to the Python file that is being run if repo_path is None : repo_path = ( Path . cwd () / Path ( sys . argv [ 0 ]) . parent ) . resolve () reproducibility = { \"command_line\" : f 'python { \" \" . join ( quote ( arg ) for arg in sys . argv ) } ' , \"time\" : time . strftime ( \" %c \" ), } git_info = GitInfo ( repo_path = repo_path ) if git_info . has_git (): reproducibility [ \"git_root\" ] = git_info . get_git_root () reproducibility [ \"git_url\" ] = git_info . get_git_url ( commit_hash = True ) reproducibility [ \"git_has_uncommitted_changes\" ] = git_info . has_uncommitted_changes () return reproducibility Method load ( self , path , check_reproducibility = False , skip_unsettable = False , repo_path = None ) inherited \u00b6 Loads the arguments in JSON format. Note: Due to JSON, tuples are loaded as lists. :param path: Path to the JSON file where the arguments will be loaded from. :param check_reproducibility: When True, raises an error if the loaded reproducibility information doesn't match the current reproducibility information. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: Returns self. Source code in mapper\\main.py def load ( self , path : PathLike , check_reproducibility : bool = False , skip_unsettable : bool = False , repo_path : Optional [ PathLike ] = None , ) -> TapType : \"\"\"Loads the arguments in JSON format. Note: Due to JSON, tuples are loaded as lists. :param path: Path to the JSON file where the arguments will be loaded from. :param check_reproducibility: When True, raises an error if the loaded reproducibility information doesn't match the current reproducibility information. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: Returns self. \"\"\" with open ( path ) as f : args_dict = json . load ( f , object_hook = as_python_object ) # Remove loaded reproducibility information since it is no longer valid saved_reproducibility_data = args_dict . pop ( \"reproducibility\" , None ) if check_reproducibility : current_reproducibility_data = self . get_reproducibility_info ( repo_path = repo_path ) enforce_reproducibility ( saved_reproducibility_data , current_reproducibility_data , path ) self . from_dict ( args_dict , skip_unsettable = skip_unsettable ) return self Method parse_args ( self , args = None , known_only = False , legacy_config_parsing = False ) inherited \u00b6 Parses arguments, sets attributes of self equal to the parsed arguments, and processes arguments. :param args: List of strings to parse. The default is taken from sys.argv . :param known_only: If true, ignores extra arguments and only parses known arguments. Unparsed arguments are saved to self.extra_args. :param legacy_config_parsing: If true, config files are parsed using str.split instead of shlex.split . :return: self, which is a Tap instance containing all of the parsed args. Source code in mapper\\main.py def parse_args ( self : TapType , args : Optional [ Sequence [ str ]] = None , known_only : bool = False , legacy_config_parsing = False ) -> TapType : \"\"\"Parses arguments, sets attributes of self equal to the parsed arguments, and processes arguments. :param args: List of strings to parse. The default is taken from `sys.argv`. :param known_only: If true, ignores extra arguments and only parses known arguments. Unparsed arguments are saved to self.extra_args. :param legacy_config_parsing: If true, config files are parsed using `str.split` instead of `shlex.split`. :return: self, which is a Tap instance containing all of the parsed args. \"\"\" # Prevent double parsing if self . _parsed : raise ValueError ( \"parse_args can only be called once.\" ) # Collect arguments from all of the configs if legacy_config_parsing : splitter = lambda arg_string : arg_string . split () else : splitter = lambda arg_string : split ( arg_string , comments = True ) config_args = [ arg for args_from_config in self . args_from_configs for arg in splitter ( args_from_config )] # Add config args at lower precedence and extract args from the command line if they are not passed explicitly args = config_args + ( sys . argv [ 1 :] if args is None else list ( args )) # Parse args using super class ArgumentParser's parse_args or parse_known_args function if known_only : default_namespace , self . extra_args = super ( Tap , self ) . parse_known_args ( args ) else : default_namespace = super ( Tap , self ) . parse_args ( args ) # Copy parsed arguments to self for variable , value in vars ( default_namespace ) . items (): # Conversion from list to set or tuple if variable in self . _annotations : if type ( value ) == list : var_type = get_origin ( self . _annotations [ variable ]) # Unpack nested boxed types such as Optional[List[int]] if var_type is Union : var_type = get_origin ( get_args ( self . _annotations [ variable ])[ 0 ]) # If var_type is tuple as in Python 3.6, change to a typing type # (e.g., (typing.Tuple, <class 'bool'>) ==> typing.Tuple) if isinstance ( var_type , tuple ): var_type = var_type [ 0 ] if var_type in ( Set , set ): value = set ( value ) elif var_type in ( Tuple , tuple ): value = tuple ( value ) # Set variable in self setattr ( self , variable , value ) # Process args self . process_args () # Indicate that args have been parsed self . _parsed = True return self Method process_args ( self ) inherited \u00b6 Perform additional argument processing and/or validation. Source code in mapper\\main.py def process_args ( self ) -> None : \"\"\"Perform additional argument processing and/or validation.\"\"\" pass Method save ( self , path , with_reproducibility = True , skip_unpicklable = False , repo_path = None ) inherited \u00b6 Saves the arguments and reproducibility information in JSON format, pickling what can't be encoded. :param path: Path to the JSON file where the arguments will be saved. :param with_reproducibility: If True, adds a \"reproducibility\" field with information (e.g. git hash) to the JSON file. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :param skip_unpicklable: If True, does not save attributes whose values cannot be pickled. Source code in mapper\\main.py def save ( self , path : PathLike , with_reproducibility : bool = True , skip_unpicklable : bool = False , repo_path : Optional [ PathLike ] = None , ) -> None : \"\"\"Saves the arguments and reproducibility information in JSON format, pickling what can't be encoded. :param path: Path to the JSON file where the arguments will be saved. :param with_reproducibility: If True, adds a \"reproducibility\" field with information (e.g. git hash) to the JSON file. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :param skip_unpicklable: If True, does not save attributes whose values cannot be pickled. \"\"\" with open ( path , \"w\" ) as f : args = self . _log_all ( repo_path = repo_path ) if with_reproducibility else self . as_dict () json . dump ( args , f , indent = 4 , sort_keys = True , cls = define_python_object_encoder ( skip_unpicklable )) Class Game( Thread ) \u00b6 Source code in mapper\\main.py class Game ( threading . Thread ): def __init__ ( self , game : BufferedSocket , mapper : Mapper ) -> None : threading . Thread . __init__ ( self ) self . name : str = \"Game\" self . game : BufferedSocket = game self . mapper : Mapper = mapper self . finished : threading . Event = threading . Event () def close ( self ) -> None : self . finished . set () def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except FakeSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None ) Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\main.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except FakeSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None ) Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\main.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Class Player( Thread ) \u00b6 Source code in mapper\\main.py class Player ( threading . Thread ): def __init__ ( self , player : BufferedSocket , mapper : Mapper ) -> None : threading . Thread . __init__ ( self ) self . name : str = \"Player\" self . player : BufferedSocket = player self . mapper : Mapper = mapper self . finished : threading . Event = threading . Event () def close ( self ) -> None : self . finished . set () def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" ) Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\main.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" ) Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\main.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"main.py"},{"location":"api/main/#mapper.main","text":"","title":"main"},{"location":"api/main/#mapper.main.ArgumentParser","text":"Source code in mapper\\main.py class ArgumentParser ( Tap ): emulation : bool = False \"\"\"Start in emulation mode.\"\"\" interface : LITERAL_INTERFACES = INTERFACES [ 0 ] \"\"\"Select a user interface.\"\"\" format : LITERAL_OUTPUT_FORMATS = OUTPUT_FORMATS [ 0 ] \"\"\"Select how data from the server is transformed before being sent to the client.\"\"\" local_host : str = \"127.0.0.1\" \"\"\"The local host address to bind to.\"\"\" local_port : int = 4000 \"\"\"The local port to bind to.\"\"\" remote_host : str = \"mume.org\" \"\"\"The remote host address to connect to.\"\"\" remote_port : int = 4242 \"\"\"The remote port to connect to.\"\"\" no_ssl : bool = False \"\"\"Disable encrypted communication between the local and remote hosts.\"\"\" prompt_terminator_lf : bool = False \"\"\"Terminate game prompts with return-linefeed characters (IAC + GA is default).\"\"\" gag_prompts : bool = False \"\"\"Gag emulated prompts.\"\"\" find_format : str = \" {vnum} , {name} , {attribute} \" \"\"\" The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute}, {direction}, {clockPosition}, {distance}, {name}, {vnum}. Where {attribute} represents the attribute on which the search is performed. \"\"\" def configure ( self ) -> None : version : str = ( f \"%(prog)s v { __version__ } \" + f \"(Python { '.' . join ( str ( i ) for i in sys . version_info [: 3 ]) } { sys . version_info . releaselevel } )\" ) self . add_argument ( \"-v\" , \"--version\" , help = \"Print the program version as well as the Python version.\" , action = \"version\" , version = version , ) self . add_argument ( \"-e\" , \"--emulation\" ) self . add_argument ( \"-i\" , \"--interface\" ) self . add_argument ( \"-f\" , \"--format\" ) self . add_argument ( \"-lh\" , \"--local_host\" , metavar = \"address\" ) self . add_argument ( \"-lp\" , \"--local_port\" , metavar = \"port\" ) self . add_argument ( \"-rh\" , \"--remote_host\" , metavar = \"address\" ) self . add_argument ( \"-rp\" , \"--remote_port\" , metavar = \"port\" ) self . add_argument ( \"-nssl\" , \"--no_ssl\" ) self . add_argument ( \"-ptlf\" , \"--prompt_terminator_lf\" ) self . add_argument ( \"-gp\" , \"--gag_prompts\" ) self . add_argument ( \"-ff\" , \"--find_format\" , metavar = \"text\" )","title":"ArgumentParser"},{"location":"api/main/#mapper.main.ArgumentParser.emulation","text":"Start in emulation mode.","title":"emulation"},{"location":"api/main/#mapper.main.ArgumentParser.find_format","text":"The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute}, {direction}, {clockPosition}, {distance}, {name}, {vnum}. Where {attribute} represents the attribute on which the search is performed.","title":"find_format"},{"location":"api/main/#mapper.main.ArgumentParser.format","text":"Select how data from the server is transformed before being sent to the client.","title":"format"},{"location":"api/main/#mapper.main.ArgumentParser.gag_prompts","text":"Gag emulated prompts.","title":"gag_prompts"},{"location":"api/main/#mapper.main.ArgumentParser.interface","text":"Select a user interface.","title":"interface"},{"location":"api/main/#mapper.main.ArgumentParser.local_host","text":"The local host address to bind to.","title":"local_host"},{"location":"api/main/#mapper.main.ArgumentParser.local_port","text":"The local port to bind to.","title":"local_port"},{"location":"api/main/#mapper.main.ArgumentParser.no_ssl","text":"Disable encrypted communication between the local and remote hosts.","title":"no_ssl"},{"location":"api/main/#mapper.main.ArgumentParser.prompt_terminator_lf","text":"Terminate game prompts with return-linefeed characters (IAC + GA is default).","title":"prompt_terminator_lf"},{"location":"api/main/#mapper.main.ArgumentParser.remote_host","text":"The remote host address to connect to.","title":"remote_host"},{"location":"api/main/#mapper.main.ArgumentParser.remote_port","text":"The remote port to connect to.","title":"remote_port"},{"location":"api/main/#mapper.main.ArgumentParser.add_argument","text":"Adds an argument to the argument buffer, which will later be passed to _add_argument. Source code in mapper\\main.py def add_argument ( self , * name_or_flags , ** kwargs ) -> None : \"\"\"Adds an argument to the argument buffer, which will later be passed to _add_argument.\"\"\" if self . _initialized : raise ValueError ( \"add_argument cannot be called after initialization. \" \"Arguments must be added either as class variables or by overriding \" \"configure and including a self.add_argument call there.\" ) variable = get_argument_name ( * name_or_flags ) . replace ( \"-\" , \"_\" ) self . argument_buffer [ variable ] = ( name_or_flags , kwargs )","title":"add_argument()"},{"location":"api/main/#mapper.main.ArgumentParser.add_subparser","text":"Add a subparser to the collection of subparsers Source code in mapper\\main.py def add_subparser ( self , flag : str , subparser_type : type , ** kwargs ) -> None : \"\"\"Add a subparser to the collection of subparsers\"\"\" help_desc = kwargs . get ( \"help\" , subparser_type . __doc__ ) kwargs [ \"help\" ] = help_desc self . _subparser_buffer . append (( flag , subparser_type , kwargs ))","title":"add_subparser()"},{"location":"api/main/#mapper.main.ArgumentParser.as_dict","text":"Returns the member variables corresponding to the parsed arguments. Note: This does not include attributes set directly on an instance (e.g. arg is not included in MyTap().arg = \"hi\") :return: A dictionary mapping each argument's name to its value. Source code in mapper\\main.py def as_dict ( self ) -> Dict [ str , Any ]: \"\"\"Returns the member variables corresponding to the parsed arguments. Note: This does not include attributes set directly on an instance (e.g. arg is not included in MyTap().arg = \"hi\") :return: A dictionary mapping each argument's name to its value. \"\"\" if not self . _parsed : raise ValueError ( \"You should call `parse_args` before retrieving arguments.\" ) self_dict = self . __dict__ class_dict = self . _get_from_self_and_super ( extract_func = lambda super_class : dict ( getattr ( super_class , \"__dict__\" , dict ())) ) class_dict = { key : val for key , val in class_dict . items () if key not in self_dict } stored_dict = { ** self_dict , ** class_dict } stored_dict = { var : getattr ( self , var ) for var , val in stored_dict . items () if not ( var . startswith ( \"_\" ) or isinstance ( val , MethodType ) or isinstance ( val , staticmethod )) } tap_class_dict_keys = Tap () . __dict__ . keys () | Tap . __dict__ . keys () stored_dict = { key : stored_dict [ key ] for key in stored_dict . keys () - tap_class_dict_keys } return stored_dict","title":"as_dict()"},{"location":"api/main/#mapper.main.ArgumentParser.configure","text":"Overwrite this method to configure the parser during initialization. For example, self.add_argument('--sum', dest='accumulate', action='store_const', const=sum, default=max) self.add_subparsers(help='sub-command help') self.add_subparser('a', SubparserA, help='a help') Source code in mapper\\main.py def configure ( self ) -> None : version : str = ( f \"%(prog)s v { __version__ } \" + f \"(Python { '.' . join ( str ( i ) for i in sys . version_info [: 3 ]) } { sys . version_info . releaselevel } )\" ) self . add_argument ( \"-v\" , \"--version\" , help = \"Print the program version as well as the Python version.\" , action = \"version\" , version = version , ) self . add_argument ( \"-e\" , \"--emulation\" ) self . add_argument ( \"-i\" , \"--interface\" ) self . add_argument ( \"-f\" , \"--format\" ) self . add_argument ( \"-lh\" , \"--local_host\" , metavar = \"address\" ) self . add_argument ( \"-lp\" , \"--local_port\" , metavar = \"port\" ) self . add_argument ( \"-rh\" , \"--remote_host\" , metavar = \"address\" ) self . add_argument ( \"-rp\" , \"--remote_port\" , metavar = \"port\" ) self . add_argument ( \"-nssl\" , \"--no_ssl\" ) self . add_argument ( \"-ptlf\" , \"--prompt_terminator_lf\" ) self . add_argument ( \"-gp\" , \"--gag_prompts\" ) self . add_argument ( \"-ff\" , \"--find_format\" , metavar = \"text\" )","title":"configure()"},{"location":"api/main/#mapper.main.ArgumentParser.error","text":"error(message: string) Prints a usage message incorporating the message to stderr and exits. If you override this in a subclass, it should not return -- it should either exit or raise an exception. Source code in mapper\\main.py def error ( self , message ): \"\"\"error(message: string) Prints a usage message incorporating the message to stderr and exits. If you override this in a subclass, it should not return -- it should either exit or raise an exception. \"\"\" self . print_usage ( _sys . stderr ) args = { 'prog' : self . prog , 'message' : message } self . exit ( 2 , _ ( ' %(prog)s : error: %(message)s \\n ' ) % args )","title":"error()"},{"location":"api/main/#mapper.main.ArgumentParser.from_dict","text":"Loads arguments from a dictionary, ensuring all required arguments are set. :param args_dict: A dictionary from argument names to the values of the arguments. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :return: Returns self. Source code in mapper\\main.py def from_dict ( self , args_dict : Dict [ str , Any ], skip_unsettable : bool = False ) -> TapType : \"\"\"Loads arguments from a dictionary, ensuring all required arguments are set. :param args_dict: A dictionary from argument names to the values of the arguments. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :return: Returns self. \"\"\" # All of the required arguments must be provided or already set required_args = { a . dest for a in self . _actions if a . required } unprovided_required_args = required_args - args_dict . keys () missing_required_args = [ arg for arg in unprovided_required_args if not hasattr ( self , arg )] if len ( missing_required_args ) > 0 : raise ValueError ( f 'Input dictionary \" { args_dict } \" does not include ' f 'all unset required arguments: \" { missing_required_args } \".' ) # Load all arguments for key , value in args_dict . items (): try : setattr ( self , key , value ) except AttributeError : if not skip_unsettable : raise AttributeError ( f 'Cannot set attribute \" { key } \" to \" { value } \". ' f \"To skip arguments that cannot be set \\n \" f ' \\t \"skip_unsettable = True\"' ) self . _parsed = True return self","title":"from_dict()"},{"location":"api/main/#mapper.main.ArgumentParser.get_reproducibility_info","text":"Gets a dictionary of reproducibility information. Reproducibility information always includes: - command_line: The command line command used to execute the code. - time: The current time. If git is installed, reproducibility information also includes: - git_root: The root of the git repo where the command is run. - git_url: The url of the current hash of the git repo where the command is run. Ex. https://github.com/swansonk14/rationale-alignment/tree/ - git_has_uncommitted_changes: Whether the current git repo has uncommitted changes. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: A dictionary of reproducibility information. Source code in mapper\\main.py @staticmethod def get_reproducibility_info ( repo_path : Optional [ PathLike ] = None ) -> Dict [ str , str ]: \"\"\"Gets a dictionary of reproducibility information. Reproducibility information always includes: - command_line: The command line command used to execute the code. - time: The current time. If git is installed, reproducibility information also includes: - git_root: The root of the git repo where the command is run. - git_url: The url of the current hash of the git repo where the command is run. Ex. https://github.com/swansonk14/rationale-alignment/tree/<hash> - git_has_uncommitted_changes: Whether the current git repo has uncommitted changes. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: A dictionary of reproducibility information. \"\"\" # Get the path to the Python file that is being run if repo_path is None : repo_path = ( Path . cwd () / Path ( sys . argv [ 0 ]) . parent ) . resolve () reproducibility = { \"command_line\" : f 'python { \" \" . join ( quote ( arg ) for arg in sys . argv ) } ' , \"time\" : time . strftime ( \" %c \" ), } git_info = GitInfo ( repo_path = repo_path ) if git_info . has_git (): reproducibility [ \"git_root\" ] = git_info . get_git_root () reproducibility [ \"git_url\" ] = git_info . get_git_url ( commit_hash = True ) reproducibility [ \"git_has_uncommitted_changes\" ] = git_info . has_uncommitted_changes () return reproducibility","title":"get_reproducibility_info()"},{"location":"api/main/#mapper.main.ArgumentParser.load","text":"Loads the arguments in JSON format. Note: Due to JSON, tuples are loaded as lists. :param path: Path to the JSON file where the arguments will be loaded from. :param check_reproducibility: When True, raises an error if the loaded reproducibility information doesn't match the current reproducibility information. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: Returns self. Source code in mapper\\main.py def load ( self , path : PathLike , check_reproducibility : bool = False , skip_unsettable : bool = False , repo_path : Optional [ PathLike ] = None , ) -> TapType : \"\"\"Loads the arguments in JSON format. Note: Due to JSON, tuples are loaded as lists. :param path: Path to the JSON file where the arguments will be loaded from. :param check_reproducibility: When True, raises an error if the loaded reproducibility information doesn't match the current reproducibility information. :param skip_unsettable: When True, skips attributes that cannot be set in the Tap object, e.g. properties without setters. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :return: Returns self. \"\"\" with open ( path ) as f : args_dict = json . load ( f , object_hook = as_python_object ) # Remove loaded reproducibility information since it is no longer valid saved_reproducibility_data = args_dict . pop ( \"reproducibility\" , None ) if check_reproducibility : current_reproducibility_data = self . get_reproducibility_info ( repo_path = repo_path ) enforce_reproducibility ( saved_reproducibility_data , current_reproducibility_data , path ) self . from_dict ( args_dict , skip_unsettable = skip_unsettable ) return self","title":"load()"},{"location":"api/main/#mapper.main.ArgumentParser.parse_args","text":"Parses arguments, sets attributes of self equal to the parsed arguments, and processes arguments. :param args: List of strings to parse. The default is taken from sys.argv . :param known_only: If true, ignores extra arguments and only parses known arguments. Unparsed arguments are saved to self.extra_args. :param legacy_config_parsing: If true, config files are parsed using str.split instead of shlex.split . :return: self, which is a Tap instance containing all of the parsed args. Source code in mapper\\main.py def parse_args ( self : TapType , args : Optional [ Sequence [ str ]] = None , known_only : bool = False , legacy_config_parsing = False ) -> TapType : \"\"\"Parses arguments, sets attributes of self equal to the parsed arguments, and processes arguments. :param args: List of strings to parse. The default is taken from `sys.argv`. :param known_only: If true, ignores extra arguments and only parses known arguments. Unparsed arguments are saved to self.extra_args. :param legacy_config_parsing: If true, config files are parsed using `str.split` instead of `shlex.split`. :return: self, which is a Tap instance containing all of the parsed args. \"\"\" # Prevent double parsing if self . _parsed : raise ValueError ( \"parse_args can only be called once.\" ) # Collect arguments from all of the configs if legacy_config_parsing : splitter = lambda arg_string : arg_string . split () else : splitter = lambda arg_string : split ( arg_string , comments = True ) config_args = [ arg for args_from_config in self . args_from_configs for arg in splitter ( args_from_config )] # Add config args at lower precedence and extract args from the command line if they are not passed explicitly args = config_args + ( sys . argv [ 1 :] if args is None else list ( args )) # Parse args using super class ArgumentParser's parse_args or parse_known_args function if known_only : default_namespace , self . extra_args = super ( Tap , self ) . parse_known_args ( args ) else : default_namespace = super ( Tap , self ) . parse_args ( args ) # Copy parsed arguments to self for variable , value in vars ( default_namespace ) . items (): # Conversion from list to set or tuple if variable in self . _annotations : if type ( value ) == list : var_type = get_origin ( self . _annotations [ variable ]) # Unpack nested boxed types such as Optional[List[int]] if var_type is Union : var_type = get_origin ( get_args ( self . _annotations [ variable ])[ 0 ]) # If var_type is tuple as in Python 3.6, change to a typing type # (e.g., (typing.Tuple, <class 'bool'>) ==> typing.Tuple) if isinstance ( var_type , tuple ): var_type = var_type [ 0 ] if var_type in ( Set , set ): value = set ( value ) elif var_type in ( Tuple , tuple ): value = tuple ( value ) # Set variable in self setattr ( self , variable , value ) # Process args self . process_args () # Indicate that args have been parsed self . _parsed = True return self","title":"parse_args()"},{"location":"api/main/#mapper.main.ArgumentParser.process_args","text":"Perform additional argument processing and/or validation. Source code in mapper\\main.py def process_args ( self ) -> None : \"\"\"Perform additional argument processing and/or validation.\"\"\" pass","title":"process_args()"},{"location":"api/main/#mapper.main.ArgumentParser.save","text":"Saves the arguments and reproducibility information in JSON format, pickling what can't be encoded. :param path: Path to the JSON file where the arguments will be saved. :param with_reproducibility: If True, adds a \"reproducibility\" field with information (e.g. git hash) to the JSON file. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :param skip_unpicklable: If True, does not save attributes whose values cannot be pickled. Source code in mapper\\main.py def save ( self , path : PathLike , with_reproducibility : bool = True , skip_unpicklable : bool = False , repo_path : Optional [ PathLike ] = None , ) -> None : \"\"\"Saves the arguments and reproducibility information in JSON format, pickling what can't be encoded. :param path: Path to the JSON file where the arguments will be saved. :param with_reproducibility: If True, adds a \"reproducibility\" field with information (e.g. git hash) to the JSON file. :param repo_path: Path to the git repo to examine for reproducibility info. If None, uses the git repo of the Python file that is run. :param skip_unpicklable: If True, does not save attributes whose values cannot be pickled. \"\"\" with open ( path , \"w\" ) as f : args = self . _log_all ( repo_path = repo_path ) if with_reproducibility else self . as_dict () json . dump ( args , f , indent = 4 , sort_keys = True , cls = define_python_object_encoder ( skip_unpicklable ))","title":"save()"},{"location":"api/main/#mapper.main.Game","text":"Source code in mapper\\main.py class Game ( threading . Thread ): def __init__ ( self , game : BufferedSocket , mapper : Mapper ) -> None : threading . Thread . __init__ ( self ) self . name : str = \"Game\" self . game : BufferedSocket = game self . mapper : Mapper = mapper self . finished : threading . Event = threading . Event () def close ( self ) -> None : self . finished . set () def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except FakeSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None )","title":"Game"},{"location":"api/main/#mapper.main.Game.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/main/#mapper.main.Game.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/main/#mapper.main.Game.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/main/#mapper.main.Game.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/main/#mapper.main.Game.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/main/#mapper.main.Game.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\main.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/main/#mapper.main.Game.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/main/#mapper.main.Game.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/main/#mapper.main.Game.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except FakeSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None )","title":"run()"},{"location":"api/main/#mapper.main.Game.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\main.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/main/#mapper.main.Game.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/main/#mapper.main.Game.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/main/#mapper.main.Player","text":"Source code in mapper\\main.py class Player ( threading . Thread ): def __init__ ( self , player : BufferedSocket , mapper : Mapper ) -> None : threading . Thread . __init__ ( self ) self . name : str = \"Player\" self . player : BufferedSocket = player self . mapper : Mapper = mapper self . finished : threading . Event = threading . Event () def close ( self ) -> None : self . finished . set () def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" )","title":"Player"},{"location":"api/main/#mapper.main.Player.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/main/#mapper.main.Player.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/main/#mapper.main.Player.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/main/#mapper.main.Player.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/main/#mapper.main.Player.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/main/#mapper.main.Player.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\main.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/main/#mapper.main.Player.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\main.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/main/#mapper.main.Player.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/main/#mapper.main.Player.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py def run ( self ) -> None : data : bytes while not self . finished . is_set (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" )","title":"run()"},{"location":"api/main/#mapper.main.Player.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\main.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/main/#mapper.main.Player.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\main.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/main/#mapper.main.Player.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/mapper/","text":"Module mapper.mapper \u00b6 Class Mapper( Thread , World ) \u00b6 Source code in mapper\\mapper.py class Mapper ( threading . Thread , World ): def __init__ ( self , playerSocket : BufferedSocket , gameSocket : BufferedSocket , outputFormat : str , interface : str , promptTerminator : Union [ bytes , None ], gagPrompts : bool , findFormat : str , isEmulatingOffline : bool , ) -> None : threading . Thread . __init__ ( self ) self . name : str = \"Mapper\" # Initialize the timer. self . initTimer : float = default_timer () self . outputFormat : str = outputFormat self . interface : str = interface self . gagPrompts : bool = gagPrompts self . findFormat : str = findFormat self . isEmulatingOffline : bool = isEmulatingOffline self . queue : MAPPER_QUEUE_TYPE = SimpleQueue () self . autoMapping : bool = False self . autoMerging : bool = True self . autoLinking : bool = True self . autoWalk : bool = False self . autoWalkDirections : list [ str ] = [] userCommandPrefix : str = \"user_command_\" self . userCommands : list [ str ] = [ removePrefix ( func , userCommandPrefix ) for func in dir ( self ) if func . startswith ( userCommandPrefix ) and callable ( getattr ( self , func )) ] self . mudEventHandlers : dict [ str , set [ MUD_EVENT_HANDLER_TYPE ]] = {} self . unknownMudEvents : list [ str ] = [] mudEventPrefix : str = \"mud_event_\" legacyHandlers : list [ str ] = [ removePrefix ( func , mudEventPrefix ) for func in dir ( self ) if func . startswith ( mudEventPrefix ) and callable ( getattr ( self , func )) ] for legacyHandler in legacyHandlers : self . registerMudEventHandler ( legacyHandler , getattr ( self , mudEventPrefix + legacyHandler )) ExitsCleaner ( self , \"exits\" ) emulationCommandPrefix : str = \"emulation_command_\" self . emulationCommands : list [ str ] = [ removePrefix ( func , emulationCommandPrefix ) for func in dir ( self ) if func . startswith ( emulationCommandPrefix ) and callable ( getattr ( self , func )) ] # Commands that should have priority when matching user input to an emulation command. priorityCommands : list [ str ] = [ \"exits\" , ] self . emulationCommands . sort ( key = lambda command : ( # Sort emulation commands with prioritized commands at the top, alphabetically otherwise. priorityCommands . index ( command ) if command in priorityCommands else len ( priorityCommands ), command , ) ) self . isEmulatingBriefMode : bool = True self . isEmulatingDynamicDescs : bool = True self . lastPathFindQuery : str = \"\" self . prompt : str = \"\" self . clock : Clock = Clock () self . scouting : bool = False self . movement : Union [ str , None ] = None self . moved : Union [ str , None ] = None self . roomName : Union [ str , None ] = None self . description : Union [ str , None ] = None self . dynamic : Union [ str , None ] = None self . exits : Union [ str , None ] = None self . xmlRoomAttributes : dict [ str , Union [ str , None ]] = {} self . gmcpCharVitals : dict [ str , Any ] = {} self . timeEvent : Union [ str , None ] = None self . timeEventOffset : int = 0 self . parsedHour : int = 0 self . parsedMinutes : int = 0 self . timeSynchronized : bool = False self . proxy : ProxyHandler = ProxyHandler ( cast ( PLAYER_WRITER_TYPE , playerSocket . send ), # todo: Fix this later. cast ( GAME_WRITER_TYPE , gameSocket . send ), # todo: Fix this later. outputFormat = outputFormat , promptTerminator = promptTerminator , isEmulatingOffline = isEmulatingOffline , mapperCommands = [ func . encode ( \"us-ascii\" ) for func in self . userCommands ], eventCaller = self . queue . put , ) cfg : Config = Config () self . _autoUpdateRooms : bool = cfg . get ( \"autoUpdateRooms\" , False ) try : self . mpiHandler . isWordWrapping = cfg . get ( \"wordwrap\" , False ) except LookupError : logger . exception ( \"Unable to set initial value of MPI word wrap.\" ) del cfg self . proxy . connect () World . __init__ ( self , interface = self . interface ) self . emulationRoom : Room = self . currentRoom self . lastEmulatedJump : Union [ str , None ] = None @property def outputFormat ( self ) -> str : return str ( getattr ( self , \"_outputFormat\" , OUTPUT_FORMATS [ 0 ])) @outputFormat . setter def outputFormat ( self , value : str ) -> None : if value not in OUTPUT_FORMATS : raise ValueError ( f \" { value } not in { OUTPUT_FORMATS } \" ) self . _outputFormat = value @property def interface ( self ) -> str : return str ( getattr ( self , \"_interface\" , INTERFACES [ 0 ])) @interface . setter def interface ( self , value : str ) -> None : if value not in INTERFACES : raise ValueError ( f \" { value } not in { INTERFACES } \" ) self . _interface = value @property def autoUpdateRooms ( self ) -> bool : return self . _autoUpdateRooms @autoUpdateRooms . setter def autoUpdateRooms ( self , value : bool ) -> None : self . _autoUpdateRooms = bool ( value ) cfg : Config = Config () cfg [ \"autoUpdateRooms\" ] = self . _autoUpdateRooms cfg . save () del cfg @property def mpiHandler ( self ) -> MPIProtocol : for handler in self . proxy . game . _handlers : if isinstance ( handler , MPIProtocol ): return handler raise LookupError ( \"MPI Handler not found\" ) @property def playerTelnetHandler ( self ) -> Player : for handler in self . proxy . player . _handlers : if isinstance ( handler , Player ): return handler raise LookupError ( \"Player Telnet Handler not found\" ) def output ( self , * args : Any , ** kwargs : Any ) -> None : # Override World.output. self . sendPlayer ( * args , ** kwargs ) def sendPlayer ( self , msg : str , showPrompt : bool = True ) -> None : with suppress ( ConnectionError ): with suppress ( LookupError ): gmcpMessageOutput : bool = self . playerTelnetHandler . mpmMessageSend ({ \"text\" : msg }) if gmcpMessageOutput : # Player is receiving messages through GMCP. return None if self . outputFormat == \"raw\" : if showPrompt and self . prompt and not self . gagPrompts : msg = f \" { escapeXMLString ( msg ) } \\n <prompt> { escapeXMLString ( self . prompt ) } </prompt>\" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True , prompt = True ) else : msg = f \" \\n { escapeXMLString ( msg ) } \\n \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True ) elif self . outputFormat == \"tintin\" : if showPrompt and self . prompt and not self . gagPrompts : msg = f \" { msg } \\n PROMPT: { self . prompt } :PROMPT\" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True , prompt = True ) else : msg = f \" \\n { msg } \\n \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True ) else : if showPrompt and self . prompt and not self . gagPrompts : msg = f \" { msg } \\n { self . prompt } \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True , prompt = True ) else : msg = f \" \\n { msg } \\n \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True ) def sendGame ( self , msg : str ) -> None : with suppress ( ConnectionError ): self . proxy . game . write ( msg . encode ( \"utf-8\" ) + b \" \\n \" , escape = True ) def emulation_command_quit ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) return args def emulation_command_at ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () command : str = \" \" . join ( args [ 1 :]) . strip () if not label : self . sendPlayer ( \"Please provide a room in which to execute commands.\" ) else : room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is None : pass # Alternative suggestions were sent by the call to `getRoomFromLabel`. elif not command : self . sendPlayer ( f \"What do you want to do at { label } ?\" ) else : # Execute command at room. oldRoom : Room = self . emulationRoom self . emulationRoom = room self . user_command_emu ( command ) self . emulationRoom = oldRoom return () def emulation_command_brief ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) return args def emulation_command_dynamic ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles automatic speaking of dynamic descs.\"\"\" self . isEmulatingDynamicDescs = not self . isEmulatingDynamicDescs self . sendPlayer ( f \"dynamic descs { 'on' if self . isEmulatingDynamicDescs else 'off' } \" ) return args def emulation_command_examine ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) return args def emulation_command_exits ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the exits in the room.\"\"\" exits : list [ str ] = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) return args def emulation_command_go ( self , * args : str , isJump : bool = True ) -> tuple [ str , ... ]: \"\"\"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () args = args [ 1 :] room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is not None : self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room . vnum return args def emulation_command_help ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) return args def emulation_command_look ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) if self . isEmulatingDynamicDescs : self . sendPlayer ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) return args def emulation_command_return ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump is not None : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) return args def emulation_command_rename ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"changes the room name. (useful for exploring places with many similar names)\"\"\" name : str = \" \" . join ( args ) . strip () if name : self . emulationRoom . name = name self . sendPlayer ( f \"Room name set to ' { name } '.\" ) else : self . sendPlayer ( \"Error: You must specify a new room name.\" ) return () def emulation_command_sync ( self , * args : str ) -> tuple [ str , ... ]: \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom . vnum ) return args def emulate_leave ( self , direction : str , * args : str ) -> tuple [ str , ... ]: \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return args vnum : str = self . emulationRoom . exits [ direction ] . to if vnum == \"death\" : self . output ( \"deathtrap!\" ) elif vnum == \"undefined\" : self . output ( \"undefined\" ) else : self . emulation_command_go ( vnum , isJump = False ) return args def user_command_emu ( self , inputText : str , * args : str ) -> None : if not inputText : self . output ( \"What command do you want to emulate?\" ) return None else : words : tuple [ str , ... ] = tuple ( inputText . strip () . split ()) while words : words = self . emulateCommands ( * words ) def emulateCommands ( self , * words : str ) -> tuple [ str , ... ]: userCommand : str = words [ 0 ] . lower () userArgs : tuple [ str , ... ] = words [ 1 :] # Get the full name of the user's command. for command in [ * DIRECTIONS , * self . emulationCommands ]: if command . startswith ( userCommand ): remainingArgs : tuple [ str , ... ] if command in DIRECTIONS : remainingArgs = self . emulate_leave ( command , * userArgs ) else : remainingArgs = getattr ( self , f \"emulation_command_ { command } \" )( * userArgs ) return remainingArgs # Else try to execute the user command as a regular mapper command. if userCommand in self . userCommands : # Call the user command from the emulation room. oldRoom : Room = self . currentRoom self . currentRoom = self . emulationRoom getattr ( self , f \"user_command_ { userCommand } \" )( \" \" . join ( userArgs )) self . currentRoom = oldRoom return () # Otherwise, treat userCommand as a potential vnum or room label to jump to. return self . emulation_command_go ( userCommand , * userArgs ) def user_command_gettimer ( self , * args : str ) -> None : self . sendPlayer ( f \"TIMER: { int ( default_timer () - self . initTimer ) } :TIMER\" ) def user_command_gettimerms ( self , * args : str ) -> None : self . sendPlayer ( f \"TIMERMS: { int (( default_timer () - self . initTimer ) * 1000 ) } :TIMERMS\" ) def user_command_clock ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( self . clock . time ()) else : self . sendGame ( self . clock . time ( args [ 0 ] . strip () . lower ())) def user_command_secretaction ( self , * args : str ) -> None : matchPattern : str = rf \"^\\s*(?P<action>.+?)(?:\\s+(?P<direction> { regexFuzzy ( DIRECTIONS ) } ))?$\" match : REGEX_MATCH = re . match ( matchPattern , args [ 0 ] . strip () . lower ()) if match is None : self . sendPlayer ( f \"Syntax: 'secretaction [action] [ { ' | ' . join ( DIRECTIONS ) } ]'.\" ) return None matchDict : dict [ str , str ] = match . groupdict () direction : str if matchDict [ \"direction\" ]: direction = \"\" . join ( d for d in DIRECTIONS if d . startswith ( matchDict [ \"direction\" ])) else : direction = \"\" door : str if direction and direction in self . currentRoom . exits and self . currentRoom . exits [ direction ] . door : door = self . currentRoom . exits [ direction ] . door else : door = \"exit\" self . sendGame ( \" \" . join ( item for item in ( matchDict [ \"action\" ], door , direction [ 0 : 1 ]) if item )) def user_command_automap ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoMapping = not self . autoMapping else : self . autoMapping = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto Mapping { 'on' if self . autoMapping else 'off' } .\" ) def user_command_autoupdate ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoUpdateRooms = not self . autoUpdateRooms else : self . autoUpdateRooms = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto update rooms { 'on' if self . autoUpdateRooms else 'off' } .\" ) def user_command_automerge ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoMerging = not self . autoMerging else : self . autoMerging = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto Merging { 'on' if self . autoMerging else 'off' } .\" ) def user_command_autolink ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoLinking = not self . autoLinking else : self . autoLinking = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto Linking { 'on' if self . autoLinking else 'off' } .\" ) def user_command_rdelete ( self , * args : str ) -> None : self . sendPlayer ( self . rdelete ( * args )) def user_command_fdoor ( self , * args : str ) -> None : self . sendPlayer ( self . fdoor ( self . findFormat , * args )) def user_command_fdynamic ( self , * args : str ) -> None : self . sendPlayer ( self . fdynamic ( self . findFormat , * args )) def user_command_flabel ( self , * args : str ) -> None : self . sendPlayer ( self . flabel ( self . findFormat , * args )) def user_command_fname ( self , * args : str ) -> None : self . sendPlayer ( self . fname ( self . findFormat , * args )) def user_command_fnote ( self , * args : str ) -> None : self . sendPlayer ( self . fnote ( self . findFormat , * args )) def user_command_farea ( self , * args : str ) -> None : self . sendPlayer ( self . farea ( self . findFormat , * args )) def user_command_fsid ( self , * args : str ) -> None : self . sendPlayer ( self . fsid ( self . findFormat , * args )) def user_command_rnote ( self , * args : str ) -> None : self . sendPlayer ( self . rnote ( * args )) def user_command_ralign ( self , * args : str ) -> None : self . sendPlayer ( self . ralign ( * args )) def user_command_rlight ( self , * args : str ) -> None : self . sendPlayer ( self . rlight ( * args )) def user_command_rportable ( self , * args : str ) -> None : self . sendPlayer ( self . rportable ( * args )) def user_command_rridable ( self , * args : str ) -> None : self . sendPlayer ( self . rridable ( * args )) def user_command_rsundeath ( self , * args : str ) -> None : self . sendPlayer ( self . rsundeath ( * args )) def user_command_ravoid ( self , * args : str ) -> None : self . sendPlayer ( self . ravoid ( * args )) def user_command_rterrain ( self , * args : str ) -> None : self . sendPlayer ( self . rterrain ( * args )) def user_command_rx ( self , * args : str ) -> None : self . sendPlayer ( self . rx ( * args )) def user_command_ry ( self , * args : str ) -> None : self . sendPlayer ( self . ry ( * args )) def user_command_rz ( self , * args : str ) -> None : self . sendPlayer ( self . rz ( * args )) def user_command_rmobflags ( self , * args : str ) -> None : self . sendPlayer ( self . rmobflags ( * args )) def user_command_rloadflags ( self , * args : str ) -> None : self . sendPlayer ( self . rloadflags ( * args )) def user_command_exitflags ( self , * args : str ) -> None : self . sendPlayer ( self . exitflags ( * args )) def user_command_doorflags ( self , * args : str ) -> None : self . sendPlayer ( self . doorflags ( * args )) def user_command_wordwrap ( self , * args : str ) -> None : try : value : bool = not self . mpiHandler . isWordWrapping self . mpiHandler . isWordWrapping = value cfg : Config = Config () cfg [ \"wordwrap\" ] = value cfg . save () del cfg self . sendPlayer ( f \"Word Wrap { 'enabled' if value else 'disabled' } .\" ) except LookupError as e : self . sendPlayer ( f \"Unable to toggle word wrapping: { ', ' . join ( e . args ) } .\" ) def user_command_secret ( self , * args : str ) -> None : self . sendPlayer ( self . secret ( * args )) def user_command_rlink ( self , * args : str ) -> None : self . sendPlayer ( self . rlink ( * args )) def user_command_rinfo ( self , * args : str ) -> None : self . sendPlayer ( self . rinfo ( * args )) def user_command_vnum ( self , * args : str ) -> None : \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" ) def user_command_tvnum ( self , * args : str ) -> None : \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" ) def user_command_rlabel ( self , * args : str ) -> None : self . rlabel ( * args ) def user_command_getlabel ( self , * args : str ) -> None : self . sendPlayer ( self . getlabel ( * args )) def user_command_savemap ( self , * args : str ) -> None : self . saveRooms () def user_command_run ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Usage: run [label|vnum]\" ) return None self . stopRun () match : REGEX_MATCH destination : str argString : str = args [ 0 ] . strip () if argString . lower () == \"t\" or argString . lower () . startswith ( \"t \" ): argString = argString [ 2 :] . strip () if not argString and self . lastPathFindQuery : self . sendPlayer ( f \"Run target set to ' { self . lastPathFindQuery } '. Use 'run t [rlabel|vnum]' to change it.\" ) return None elif not argString : self . sendPlayer ( \"Please specify a VNum or room label to target.\" ) return None self . lastPathFindQuery = argString self . sendPlayer ( f \"Setting run target to ' { self . lastPathFindQuery } '\" ) return None elif argString . lower () == \"c\" : if self . lastPathFindQuery : match = RUN_DESTINATION_REGEX . match ( self . lastPathFindQuery ) if match is None : return None destination = match . group ( \"destination\" ) self . sendPlayer ( destination ) else : self . sendPlayer ( \"Error: no previous path to continue.\" ) return None else : match = RUN_DESTINATION_REGEX . match ( argString ) if match is None : return None destination = match . group ( \"destination\" ) flags : str = match . group ( \"flags\" ) result : Union [ list [ str ], None ] = self . pathFind ( destination = destination , flags = flags . split ( \"|\" ) if flags else None ) if result is not None : self . autoWalk = True if result : if argString != \"c\" : self . lastPathFindQuery = argString self . autoWalkDirections . extend ( result ) self . walkNextDirection () def user_command_step ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Usage: step [label|vnum]\" ) return None self . autoWalkDirections . clear () argString : str = args [ 0 ] . strip () match : REGEX_MATCH = RUN_DESTINATION_REGEX . match ( argString ) if match is not None : destination : str = match . group ( \"destination\" ) flags : str = match . group ( \"flags\" ) result : Union [ list [ str ], None ] = self . pathFind ( destination = destination , flags = flags . split ( \"|\" ) if flags else None ) if result is not None : self . autoWalkDirections . extend ( result ) self . walkNextDirection () return None self . sendPlayer ( \"Please specify a valid destination.\" ) def user_command_stop ( self , * args : str ) -> None : self . stopRun () self . sendPlayer ( \"Run canceled!\" ) def user_command_path ( self , * args : str ) -> None : self . path ( * args ) def user_command_sync ( self , * args : str ) -> None : if not args or not args [ 0 ]: self . sendPlayer ( \"Map no longer synced. Auto sync on.\" ) self . isSynced = False self . sendGame ( \"look\" ) else : self . sync ( vnum = args [ 0 ] . strip ()) def user_command_maphelp ( self , * args : str ) -> None : \"\"\"Shows documentation for mapper commands\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) def walkNextDirection ( self ) -> None : if not self . autoWalkDirections : return None while self . autoWalkDirections : command : str = self . autoWalkDirections . pop () if not self . autoWalkDirections : self . sendPlayer ( \"Arriving at destination.\" ) self . autoWalk = False if command in DIRECTIONS : # Send the first character of the direction to Mume. self . sendGame ( command [ 0 ]) break else : # command is a non-direction such as 'lead' or 'ride'. self . sendGame ( command ) def stopRun ( self ) -> None : self . autoWalk = False self . autoWalkDirections . clear () def sync ( self , name : Optional [ str ] = None , desc : Optional [ str ] = None , vnum : Optional [ str ] = None , ) -> bool : if vnum is not None : roomObj : Union [ Room , None ] = self . getRoomFromLabel ( vnum ) if roomObj is not None : self . currentRoom = roomObj self . isSynced = True self . sendPlayer ( f \"Synced to room { self . currentRoom . name } with vnum { self . currentRoom . vnum } \" ) else : nameVnums : list [ str ] = [] descVnums : list [ str ] = [] for vnum , roomObj in self . rooms . items (): if name and roomObj . name == name : nameVnums . append ( vnum ) if desc and roomObj . desc == desc : descVnums . append ( vnum ) if not nameVnums : self . sendPlayer ( \"Current room not in the database. Unable to sync.\" ) elif len ( descVnums ) == 1 : self . currentRoom = self . rooms [ descVnums [ 0 ]] self . isSynced = True self . sendPlayer ( f \"Synced to room { self . currentRoom . name } with vnum { self . currentRoom . vnum } \" ) elif len ( nameVnums ) == 1 : self . currentRoom = self . rooms [ nameVnums [ 0 ]] self . isSynced = True self . sendPlayer ( f \"Name-only synced to room { self . currentRoom . name } with vnum { self . currentRoom . vnum } \" ) else : self . sendPlayer ( \"More than one room in the database matches current room. Unable to sync.\" ) return self . isSynced def roomDetails ( self ) -> None : doors : list [ str ] = [] deathTraps : list [ str ] = [] oneWays : list [ str ] = [] undefineds : list [ str ] = [] for direction , exitObj in self . currentRoom . exits . items (): if exitObj . door and exitObj . door != \"exit\" : doors . append ( f \" { direction } : { exitObj . door } \" ) if not exitObj . to or exitObj . to == \"undefined\" : undefineds . append ( direction ) elif exitObj . to == \"death\" : deathTraps . append ( direction ) elif ( REVERSE_DIRECTIONS [ direction ] not in self . rooms [ exitObj . to ] . exits or self . rooms [ exitObj . to ] . exits [ REVERSE_DIRECTIONS [ direction ]] . to != self . currentRoom . vnum ): oneWays . append ( direction ) if doors : self . sendPlayer ( f \"Doors: { ', ' . join ( doors ) } \" , showPrompt = False ) if deathTraps : self . sendPlayer ( f \"Death Traps: { ', ' . join ( deathTraps ) } \" , showPrompt = False ) if oneWays : self . sendPlayer ( f \"One ways: { ', ' . join ( oneWays ) } \" , showPrompt = False ) if undefineds : self . sendPlayer ( f \"Undefineds: { ', ' . join ( undefineds ) } \" , showPrompt = False ) if self . currentRoom . note : self . sendPlayer ( f \"Note: { self . currentRoom . note } \" , showPrompt = False ) def updateRoomFlags ( self ) -> None : output : list [ str ] = [] lightSymbol : Union [ str , None ] = self . gmcpCharVitals . get ( \"light\" ) if lightSymbol is not None and lightSymbol in LIGHT_SYMBOLS : light : str = LIGHT_SYMBOLS [ lightSymbol ] if light == \"lit\" and self . currentRoom . light != light : # Todo: Orc can define sundeath, troll can define no_sundeath and lit/dark. # output.append(self.rlight(\"lit\")) pass ridable : bool = bool ( self . gmcpCharVitals . get ( \"ride\" ) or self . gmcpCharVitals . get ( \"ridden\" )) if ridable and self . currentRoom . ridable != \"ridable\" : output . append ( self . rridable ( \"ridable\" )) if output : self . sendPlayer ( \" \\n \" . join ( output )) def updateExitFlags ( self , exits : str ) -> None : if not exits : return None output : list [ str ] = [] exitsOutput : list [ str ] = [] for door , road , climb , portal , direction in EXIT_TAGS_REGEX . findall ( exits ): # Portals aren't real exits. if portal : continue if direction not in self . currentRoom . exits : output . append ( f \"Adding exit ' { direction } ' to current room.\" ) self . currentRoom . exits [ direction ] = self . getNewExit ( direction ) if self . autoLinking : currentRoomCoords : tuple [ int , int , int ] = ( self . currentRoom . x , self . currentRoom . y , self . currentRoom . z , ) vnums : list [ str ] = [ vnum for vnum , roomObj in self . rooms . items () if self . coordinatesAddDirection ( currentRoomCoords , direction ) == ( roomObj . x , roomObj . y , roomObj . z ) ] if ( len ( vnums ) == 1 and REVERSE_DIRECTIONS [ direction ] in self . rooms [ vnums [ 0 ]] . exits and self . rooms [ vnums [ 0 ]] . exits [ REVERSE_DIRECTIONS [ direction ]] . to == \"undefined\" ): output . append ( self . rlink ( f \"add { vnums [ 0 ] } { direction } \" )) roomExit : Exit = self . currentRoom . exits [ direction ] if door and \"door\" not in roomExit . exitFlags : output . append ( self . exitflags ( f \"add door { direction } \" )) if road and \"road\" not in roomExit . exitFlags : output . append ( self . exitflags ( f \"add road { direction } \" )) if climb and \"climb\" not in roomExit . exitFlags : output . append ( self . exitflags ( f \"add climb { direction } \" )) if exitsOutput : exitsOutput . insert ( 0 , f \"Exit { direction } :\" ) output . extend ( exitsOutput ) exitsOutput . clear () if output : self . sendPlayer ( \" \\n \" . join ( output )) def autoMergeRoom ( self , movement : str , roomObj : Room ) -> None : output : list [ str ] = [] if ( self . autoLinking and REVERSE_DIRECTIONS [ movement ] in roomObj . exits and roomObj . exits [ REVERSE_DIRECTIONS [ movement ]] . to == \"undefined\" ): output . append ( self . rlink ( f \"add { roomObj . vnum } { movement } \" )) else : output . append ( self . rlink ( f \"add oneway { roomObj . vnum } { movement } \" )) output . append ( f \"Auto Merging ' { roomObj . vnum } ' with name ' { roomObj . name } '.\" ) self . sendPlayer ( \" \\n \" . join ( output )) def addNewRoom ( self , movement : str , name : str , description : str , dynamic : str ) -> None : vnum : str = self . getNewVnum () newRoom : Room = Room () newRoom . vnum = vnum newRoom . name = name newRoom . desc = description newRoom . dynamicDesc = dynamic newRoom . x , newRoom . y , newRoom . z = self . coordinatesAddDirection ( ( self . currentRoom . x , self . currentRoom . y , self . currentRoom . z ), movement ) self . rooms [ vnum ] = newRoom if movement not in self . currentRoom . exits : self . currentRoom . exits [ movement ] = self . getNewExit ( movement , to = vnum ) else : self . currentRoom . exits [ movement ] . to = vnum self . sendPlayer ( f \"Adding room ' { newRoom . name } ' with vnum ' { vnum } '\" ) def mud_event_gmcp_char_vitals ( self , text : str ) -> None : newValues : dict [ str , Any ] = json . loads ( text ) self . gmcpCharVitals . update ( newValues ) if self . autoMapping : self . updateRoomFlags () def mud_event_prompt ( self , text : str ) -> None : self . playerTelnetHandler . mpmEventSend ({ \"prompt\" : text }) self . prompt = text if self . isSynced : if self . autoMapping and self . moved : self . updateRoomFlags () elif self . roomName : self . sync ( self . roomName , self . description ) if self . isSynced and self . dynamic is not None : self . roomDetails () if self . autoWalkDirections and self . moved and self . autoWalk : # The player is auto-walking. Send the next direction to Mume. self . walkNextDirection () self . scouting = False self . movement = None self . moved = None self . roomName = None self . description = None self . dynamic = None def mud_event_movement ( self , text : str ) -> None : self . movement = text self . scouting = False def mud_event_line ( self , text : str ) -> None : if text . startswith ( \"You quietly scout \" ): self . scouting = True return None elif text == \"A huge clock is standing here.\" : self . sendGame ( \"look at clock\" ) elif text == ( \"Wet, cold and filled with mud you drop down into a dark \" + \"and moist cave, while you notice the mud above you moving \" + \"to close the hole you left in the cave ceiling.\" ): self . sync ( vnum = \"17189\" ) elif text == ( \"The gravel below your feet loosens, shifting slightly.. \" + \"Suddenly, you lose your balance and crash to the cave floor below.\" ): self . sync ( vnum = \"15324\" ) elif not self . timeSynchronized : self . syncTime ( text ) if MOVEMENT_FORCED_REGEX . search ( text ) or MOVEMENT_PREVENTED_REGEX . search ( text ): self . stopRun () if self . isSynced and self . autoMapping : if text == \"It's too difficult to ride here.\" and self . currentRoom . ridable != \"not_ridable\" : self . sendPlayer ( self . rridable ( \"not_ridable\" )) elif text == \"You are already riding.\" and self . currentRoom . ridable != \"ridable\" : self . sendPlayer ( self . rridable ( \"ridable\" )) def syncTime ( self , text : str ) -> None : clockMatch : REGEX_MATCH = CLOCK_REGEX . match ( text ) timeMatch : REGEX_MATCH = TIME_REGEX . match ( text ) if self . timeEvent is None : if clockMatch is not None : hour : int = int ( clockMatch . group ( \"hour\" )) minutes : int = int ( clockMatch . group ( \"minutes\" )) amPm : str = clockMatch . group ( \"am_pm\" ) # parsedHour should be 0 - 23. self . parsedHour = hour % 12 + ( 12 if amPm == \"pm\" else 0 ) self . parsedMinutes = minutes if self . parsedHour == 23 and self . parsedMinutes == 59 : OneShot ( 1.0 , self . sendGame , \"look at clock\" ) else : self . timeEvent = \"clock\" self . sendGame ( \"time\" ) elif DAWN_REGEX . match ( text ) is not None : self . timeEvent = \"dawn\" self . timeEventOffset = 0 self . sendGame ( \"time\" ) elif DAY_REGEX . match ( text ) is not None : self . timeEvent = \"dawn\" self . timeEventOffset = 1 self . sendGame ( \"time\" ) elif DUSK_REGEX . match ( text ) is not None : self . timeEvent = \"dusk\" self . timeEventOffset = 0 self . sendGame ( \"time\" ) elif NIGHT_REGEX . match ( text ) is not None : self . timeEvent = \"dusk\" self . timeEventOffset = 1 self . sendGame ( \"time\" ) elif timeMatch is not None : day : int = int ( timeMatch . group ( \"day\" )) year : int = int ( timeMatch . group ( \"year\" )) month : int = 0 for i , m in enumerate ( MONTHS ): if timeMatch . group ( \"month\" ) in ( m [ \"westron\" ], m [ \"sindarin\" ]): month = i break if self . timeEvent in ( \"dawn\" , \"dusk\" ): self . parsedHour = int ( MONTHS [ month ][ self . timeEvent ]) + self . timeEventOffset self . parsedMinutes = 0 self . clock . setTime ( year , month , day , self . parsedHour , self . parsedMinutes ) self . timeEvent = None self . timeEventOffset = 0 self . timeSynchronized = True self . sendPlayer ( f \"Synchronized with epoch { self . clock . epoch } .\" , showPrompt = False ) def mud_event_room ( self , text : str ) -> None : self . xmlRoomAttributes . clear () self . xmlRoomAttributes . update ( getXMLAttributes ( text )) def mud_event_name ( self , text : str ) -> None : if text not in ( \"You just see a dense fog around you...\" , \"It is pitch black...\" ): self . roomName = simplified ( text ) else : self . roomName = \"\" def mud_event_description ( self , text : str ) -> None : self . description = simplified ( text ) def validateMovement ( self , movement : str ) -> bool : if not movement : # The player was forcibly moved in an unknown direction. self . sendPlayer ( \"Forced movement, no longer synced.\" ) elif movement not in DIRECTIONS : self . sendPlayer ( f \"Error: Invalid direction ' { movement } '. Map no longer synced!\" ) elif not self . autoMapping and movement not in self . currentRoom . exits : self . sendPlayer ( f \"Error: direction ' { movement } ' not in database. Map no longer synced!\" ) elif not self . autoMapping and self . currentRoom . exits [ movement ] . to not in self . rooms : self . sendPlayer ( f \"Error: vnum ( { self . currentRoom . exits [ movement ] . to } ) in direction ( { movement } ) \" + \"is not in the database. Map no longer synced!\" ) else : return True self . isSynced = False return False def updateRooms ( self ) -> None : if self . roomName and self . currentRoom . name != self . roomName : self . currentRoom . name = self . roomName self . sendPlayer ( \"Updating room name.\" ) if self . description and self . currentRoom . desc != self . description : self . currentRoom . desc = self . description self . sendPlayer ( \"Updating room description.\" ) if self . dynamic and self . currentRoom . dynamicDesc != self . dynamic : self . currentRoom . dynamicDesc = self . dynamic self . sendPlayer ( \"Updating room dynamic description.\" ) terrain : Union [ str , None ] = self . xmlRoomAttributes . get ( \"terrain\" ) if terrain is not None and self . currentRoom . terrain != terrain : self . sendPlayer ( self . rterrain ( terrain )) area : Union [ str , None ] = self . xmlRoomAttributes . get ( \"area\" ) if area is not None and self . currentRoom . area != area : self . currentRoom . area = area self . sendPlayer ( f \"Setting room area to ' { area } '.\" ) serverID : Union [ str , None ] = self . xmlRoomAttributes . get ( \"id\" ) if serverID is not None and serverID . isdigit () and self . currentRoom . serverID != serverID : self . currentRoom . serverID = serverID self . sendPlayer ( f \"Setting room server ID to ' { serverID } '.\" ) def mud_event_dynamic ( self , text : str ) -> None : self . dynamic = text . lstrip () self . moved = None addedNewRoomFrom : Union [ str , None ] = None if not self . isSynced or self . movement is None : return None elif self . validateMovement ( self . movement ): if self . autoMapping and ( self . movement not in self . currentRoom . exits or self . currentRoom . exits [ self . movement ] . to not in self . rooms ): # Player has moved in a direction that either doesn't exist in the database # or links to an invalid vnum (E.G. undefined). duplicates : Union [ list [ Room ], None ] if self . autoMerging and self . roomName and self . description : duplicates = self . searchRooms ( exactMatch = True , name = self . roomName , desc = self . description ) else : duplicates = None if not self . roomName : self . sendPlayer ( \"Unable to add new room: empty room name.\" ) elif not self . description : self . sendPlayer ( \"Unable to add new room: empty room description.\" ) elif duplicates is not None and len ( duplicates ) == 1 : self . autoMergeRoom ( self . movement , duplicates [ 0 ]) else : # Create new room. addedNewRoomFrom = self . currentRoom . vnum self . addNewRoom ( self . movement , self . roomName , self . description , self . dynamic ) self . currentRoom = self . rooms [ self . currentRoom . exits [ self . movement ] . to ] self . moved = self . movement self . movement = None if self . autoMapping and self . autoUpdateRooms : self . updateRooms () if self . autoMapping and self . isSynced and self . moved and self . exits : if addedNewRoomFrom and REVERSE_DIRECTIONS [ self . moved ] in self . exits : self . currentRoom . exits [ REVERSE_DIRECTIONS [ self . moved ]] = self . getNewExit ( REVERSE_DIRECTIONS [ self . moved ], to = addedNewRoomFrom ) self . updateExitFlags ( self . exits ) self . exits = None def mud_event_exits ( self , text : str ) -> None : self . exits = text def handleUserInput ( self , text : str ) -> None : text = text . strip () if not text : return None elif self . isEmulatingOffline : self . user_command_emu ( text ) else : userCommand : str = text . split ()[ 0 ] args : str = removePrefix ( text , userCommand ) . strip () getattr ( self , f \"user_command_ { userCommand } \" )( args ) def handleMudEvent ( self , event : str , text : str ) -> None : text = stripAnsi ( text ) if event in self . mudEventHandlers : if not self . scouting or event in ( \"prompt\" , \"movement\" ): for handler in self . mudEventHandlers [ event ]: handler ( text ) elif event not in self . unknownMudEvents : self . unknownMudEvents . append ( event ) logger . debug ( f \"received data with an unknown event type of { event } \" ) def registerMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () if event in self . unknownMudEvents : self . unknownMudEvents . remove ( event ) self . mudEventHandlers [ event ] . add ( handler ) def deregisterMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) if not self . mudEventHandlers [ event ]: del self . mudEventHandlers [ event ] def run ( self ) -> None : for item in iter ( self . queue . get , None ): try : event , data = item text = decodeBytes ( data ) if event == \"userInput\" : self . handleUserInput ( text ) else : self . handleMudEvent ( event , text ) except Exception : self . output ( f \"Error in mapper thread: \\n { traceback . format_exc () . strip () } \" ) logger . exception ( \"Error in mapper thread\" ) self . sendPlayer ( \"Exiting mapper thread.\" ) Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Attribute native_id inherited property readonly \u00b6 Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Method GUIRefresh ( self ) inherited \u00b6 Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\mapper.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_guiRefresh\" ,)) Method createSpeedWalk ( self , directionsList ) inherited \u00b6 Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\mapper.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> list [ str ]: speedWalkDirs : list [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : list [ str ] = [] directionsBuffer : list [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" Method deregisterMudEventHandler ( self , event , handler ) \u00b6 Deregisters mud event handlers. params: same as registerMudEventHandler. Source code in mapper\\mapper.py def deregisterMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) if not self . mudEventHandlers [ event ]: del self . mudEventHandlers [ event ] Method emulate_leave ( self , direction , * args ) \u00b6 emulates leaving the room into a neighbouring room Source code in mapper\\mapper.py def emulate_leave ( self , direction : str , * args : str ) -> tuple [ str , ... ]: \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return args vnum : str = self . emulationRoom . exits [ direction ] . to if vnum == \"death\" : self . output ( \"deathtrap!\" ) elif vnum == \"undefined\" : self . output ( \"undefined\" ) else : self . emulation_command_go ( vnum , isJump = False ) return args Method emulation_command_at ( self , * args ) \u00b6 mimic the /at command that the ainur use. Syntax: at (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_at ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () command : str = \" \" . join ( args [ 1 :]) . strip () if not label : self . sendPlayer ( \"Please provide a room in which to execute commands.\" ) else : room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is None : pass # Alternative suggestions were sent by the call to `getRoomFromLabel`. elif not command : self . sendPlayer ( f \"What do you want to do at { label } ?\" ) else : # Execute command at room. oldRoom : Room = self . emulationRoom self . emulationRoom = room self . user_command_emu ( command ) self . emulationRoom = oldRoom return () Method emulation_command_brief ( self , * args ) \u00b6 toggles brief mode. Source code in mapper\\mapper.py def emulation_command_brief ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) return args Method emulation_command_dynamic ( self , * args ) \u00b6 toggles automatic speaking of dynamic descs. Source code in mapper\\mapper.py def emulation_command_dynamic ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles automatic speaking of dynamic descs.\"\"\" self . isEmulatingDynamicDescs = not self . isEmulatingDynamicDescs self . sendPlayer ( f \"dynamic descs { 'on' if self . isEmulatingDynamicDescs else 'off' } \" ) return args Method emulation_command_examine ( self , * args ) \u00b6 shows the room's description. Source code in mapper\\mapper.py def emulation_command_examine ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) return args Method emulation_command_exits ( self , * args ) \u00b6 shows the exits in the room. Source code in mapper\\mapper.py def emulation_command_exits ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the exits in the room.\"\"\" exits : list [ str ] = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) return args Method emulation_command_go ( self , * args , * , isJump = True ) \u00b6 mimic the /go command that the ainur use. Syntax: go (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_go ( self , * args : str , isJump : bool = True ) -> tuple [ str , ... ]: \"\"\"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () args = args [ 1 :] room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is not None : self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room . vnum return args Method emulation_command_help ( self , * args ) \u00b6 Shows documentation for mapper's emulation commands. Source code in mapper\\mapper.py def emulation_command_help ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) return args Method emulation_command_look ( self , * args ) \u00b6 looks at the room. Source code in mapper\\mapper.py def emulation_command_look ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) if self . isEmulatingDynamicDescs : self . sendPlayer ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) return args Method emulation_command_quit ( self , * args ) \u00b6 Exits the program. Source code in mapper\\mapper.py def emulation_command_quit ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) return args Method emulation_command_rename ( self , * args ) \u00b6 changes the room name. (useful for exploring places with many similar names) Source code in mapper\\mapper.py def emulation_command_rename ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"changes the room name. (useful for exploring places with many similar names)\"\"\" name : str = \" \" . join ( args ) . strip () if name : self . emulationRoom . name = name self . sendPlayer ( f \"Room name set to ' { name } '.\" ) else : self . sendPlayer ( \"Error: You must specify a new room name.\" ) return () Method emulation_command_return ( self , * args ) \u00b6 returns to the last room jumped to with the go command. Source code in mapper\\mapper.py def emulation_command_return ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump is not None : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) return args Method emulation_command_sync ( self , * args ) \u00b6 When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. Source code in mapper\\mapper.py def emulation_command_sync ( self , * args : str ) -> tuple [ str , ... ]: \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom . vnum ) return args Method getName ( self ) inherited \u00b6 Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\mapper.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name Method getNeighborsFromCoordinates ( self , start , radius ) inherited \u00b6 A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNeighborsFromRoom ( self , start , radius ) inherited \u00b6 A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNewExit ( self , direction , to = 'undefined' , vnum = None ) inherited \u00b6 Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\mapper.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit Method isBidirectional ( self , exitObj ) inherited \u00b6 Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\mapper.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False Method isDaemon ( self ) inherited \u00b6 Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\mapper.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\mapper.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\mapper.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method pathFind ( self , origin = None , destination = None , flags = None ) inherited \u00b6 Find the path Source code in mapper\\mapper.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> list [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : frozenset [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : frozenset [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc ) Method registerMudEventHandler ( self , event , handler ) \u00b6 Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. Source code in mapper\\mapper.py def registerMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () if event in self . unknownMudEvents : self . unknownMudEvents . remove ( event ) self . mudEventHandlers [ event ] . add ( handler ) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\mapper.py def run ( self ) -> None : for item in iter ( self . queue . get , None ): try : event , data = item text = decodeBytes ( data ) if event == \"userInput\" : self . handleUserInput ( text ) else : self . handleMudEvent ( event , text ) except Exception : self . output ( f \"Error in mapper thread: \\n { traceback . format_exc () . strip () } \" ) logger . exception ( \"Error in mapper thread\" ) self . sendPlayer ( \"Exiting mapper thread.\" ) Method setDaemon ( self , daemonic ) inherited \u00b6 Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\mapper.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic Method setName ( self , name ) inherited \u00b6 Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\mapper.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\mapper.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method user_command_maphelp ( self , * args ) \u00b6 Shows documentation for mapper commands Source code in mapper\\mapper.py def user_command_maphelp ( self , * args : str ) -> None : \"\"\"Shows documentation for mapper commands\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) Method user_command_tvnum ( self , * args ) \u00b6 tells a given char the vnum of your room Source code in mapper\\mapper.py def user_command_tvnum ( self , * args : str ) -> None : \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" ) Method user_command_vnum ( self , * args ) \u00b6 states the vnum of the current room Source code in mapper\\mapper.py def user_command_vnum ( self , * args : str ) -> None : \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" )","title":"mapper.py"},{"location":"api/mapper/#mapper.mapper","text":"","title":"mapper"},{"location":"api/mapper/#mapper.mapper.Mapper","text":"Source code in mapper\\mapper.py class Mapper ( threading . Thread , World ): def __init__ ( self , playerSocket : BufferedSocket , gameSocket : BufferedSocket , outputFormat : str , interface : str , promptTerminator : Union [ bytes , None ], gagPrompts : bool , findFormat : str , isEmulatingOffline : bool , ) -> None : threading . Thread . __init__ ( self ) self . name : str = \"Mapper\" # Initialize the timer. self . initTimer : float = default_timer () self . outputFormat : str = outputFormat self . interface : str = interface self . gagPrompts : bool = gagPrompts self . findFormat : str = findFormat self . isEmulatingOffline : bool = isEmulatingOffline self . queue : MAPPER_QUEUE_TYPE = SimpleQueue () self . autoMapping : bool = False self . autoMerging : bool = True self . autoLinking : bool = True self . autoWalk : bool = False self . autoWalkDirections : list [ str ] = [] userCommandPrefix : str = \"user_command_\" self . userCommands : list [ str ] = [ removePrefix ( func , userCommandPrefix ) for func in dir ( self ) if func . startswith ( userCommandPrefix ) and callable ( getattr ( self , func )) ] self . mudEventHandlers : dict [ str , set [ MUD_EVENT_HANDLER_TYPE ]] = {} self . unknownMudEvents : list [ str ] = [] mudEventPrefix : str = \"mud_event_\" legacyHandlers : list [ str ] = [ removePrefix ( func , mudEventPrefix ) for func in dir ( self ) if func . startswith ( mudEventPrefix ) and callable ( getattr ( self , func )) ] for legacyHandler in legacyHandlers : self . registerMudEventHandler ( legacyHandler , getattr ( self , mudEventPrefix + legacyHandler )) ExitsCleaner ( self , \"exits\" ) emulationCommandPrefix : str = \"emulation_command_\" self . emulationCommands : list [ str ] = [ removePrefix ( func , emulationCommandPrefix ) for func in dir ( self ) if func . startswith ( emulationCommandPrefix ) and callable ( getattr ( self , func )) ] # Commands that should have priority when matching user input to an emulation command. priorityCommands : list [ str ] = [ \"exits\" , ] self . emulationCommands . sort ( key = lambda command : ( # Sort emulation commands with prioritized commands at the top, alphabetically otherwise. priorityCommands . index ( command ) if command in priorityCommands else len ( priorityCommands ), command , ) ) self . isEmulatingBriefMode : bool = True self . isEmulatingDynamicDescs : bool = True self . lastPathFindQuery : str = \"\" self . prompt : str = \"\" self . clock : Clock = Clock () self . scouting : bool = False self . movement : Union [ str , None ] = None self . moved : Union [ str , None ] = None self . roomName : Union [ str , None ] = None self . description : Union [ str , None ] = None self . dynamic : Union [ str , None ] = None self . exits : Union [ str , None ] = None self . xmlRoomAttributes : dict [ str , Union [ str , None ]] = {} self . gmcpCharVitals : dict [ str , Any ] = {} self . timeEvent : Union [ str , None ] = None self . timeEventOffset : int = 0 self . parsedHour : int = 0 self . parsedMinutes : int = 0 self . timeSynchronized : bool = False self . proxy : ProxyHandler = ProxyHandler ( cast ( PLAYER_WRITER_TYPE , playerSocket . send ), # todo: Fix this later. cast ( GAME_WRITER_TYPE , gameSocket . send ), # todo: Fix this later. outputFormat = outputFormat , promptTerminator = promptTerminator , isEmulatingOffline = isEmulatingOffline , mapperCommands = [ func . encode ( \"us-ascii\" ) for func in self . userCommands ], eventCaller = self . queue . put , ) cfg : Config = Config () self . _autoUpdateRooms : bool = cfg . get ( \"autoUpdateRooms\" , False ) try : self . mpiHandler . isWordWrapping = cfg . get ( \"wordwrap\" , False ) except LookupError : logger . exception ( \"Unable to set initial value of MPI word wrap.\" ) del cfg self . proxy . connect () World . __init__ ( self , interface = self . interface ) self . emulationRoom : Room = self . currentRoom self . lastEmulatedJump : Union [ str , None ] = None @property def outputFormat ( self ) -> str : return str ( getattr ( self , \"_outputFormat\" , OUTPUT_FORMATS [ 0 ])) @outputFormat . setter def outputFormat ( self , value : str ) -> None : if value not in OUTPUT_FORMATS : raise ValueError ( f \" { value } not in { OUTPUT_FORMATS } \" ) self . _outputFormat = value @property def interface ( self ) -> str : return str ( getattr ( self , \"_interface\" , INTERFACES [ 0 ])) @interface . setter def interface ( self , value : str ) -> None : if value not in INTERFACES : raise ValueError ( f \" { value } not in { INTERFACES } \" ) self . _interface = value @property def autoUpdateRooms ( self ) -> bool : return self . _autoUpdateRooms @autoUpdateRooms . setter def autoUpdateRooms ( self , value : bool ) -> None : self . _autoUpdateRooms = bool ( value ) cfg : Config = Config () cfg [ \"autoUpdateRooms\" ] = self . _autoUpdateRooms cfg . save () del cfg @property def mpiHandler ( self ) -> MPIProtocol : for handler in self . proxy . game . _handlers : if isinstance ( handler , MPIProtocol ): return handler raise LookupError ( \"MPI Handler not found\" ) @property def playerTelnetHandler ( self ) -> Player : for handler in self . proxy . player . _handlers : if isinstance ( handler , Player ): return handler raise LookupError ( \"Player Telnet Handler not found\" ) def output ( self , * args : Any , ** kwargs : Any ) -> None : # Override World.output. self . sendPlayer ( * args , ** kwargs ) def sendPlayer ( self , msg : str , showPrompt : bool = True ) -> None : with suppress ( ConnectionError ): with suppress ( LookupError ): gmcpMessageOutput : bool = self . playerTelnetHandler . mpmMessageSend ({ \"text\" : msg }) if gmcpMessageOutput : # Player is receiving messages through GMCP. return None if self . outputFormat == \"raw\" : if showPrompt and self . prompt and not self . gagPrompts : msg = f \" { escapeXMLString ( msg ) } \\n <prompt> { escapeXMLString ( self . prompt ) } </prompt>\" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True , prompt = True ) else : msg = f \" \\n { escapeXMLString ( msg ) } \\n \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True ) elif self . outputFormat == \"tintin\" : if showPrompt and self . prompt and not self . gagPrompts : msg = f \" { msg } \\n PROMPT: { self . prompt } :PROMPT\" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True , prompt = True ) else : msg = f \" \\n { msg } \\n \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True ) else : if showPrompt and self . prompt and not self . gagPrompts : msg = f \" { msg } \\n { self . prompt } \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True , prompt = True ) else : msg = f \" \\n { msg } \\n \" self . proxy . player . write ( msg . encode ( \"utf-8\" ), escape = True ) def sendGame ( self , msg : str ) -> None : with suppress ( ConnectionError ): self . proxy . game . write ( msg . encode ( \"utf-8\" ) + b \" \\n \" , escape = True ) def emulation_command_quit ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) return args def emulation_command_at ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () command : str = \" \" . join ( args [ 1 :]) . strip () if not label : self . sendPlayer ( \"Please provide a room in which to execute commands.\" ) else : room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is None : pass # Alternative suggestions were sent by the call to `getRoomFromLabel`. elif not command : self . sendPlayer ( f \"What do you want to do at { label } ?\" ) else : # Execute command at room. oldRoom : Room = self . emulationRoom self . emulationRoom = room self . user_command_emu ( command ) self . emulationRoom = oldRoom return () def emulation_command_brief ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) return args def emulation_command_dynamic ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles automatic speaking of dynamic descs.\"\"\" self . isEmulatingDynamicDescs = not self . isEmulatingDynamicDescs self . sendPlayer ( f \"dynamic descs { 'on' if self . isEmulatingDynamicDescs else 'off' } \" ) return args def emulation_command_examine ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) return args def emulation_command_exits ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the exits in the room.\"\"\" exits : list [ str ] = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) return args def emulation_command_go ( self , * args : str , isJump : bool = True ) -> tuple [ str , ... ]: \"\"\"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () args = args [ 1 :] room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is not None : self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room . vnum return args def emulation_command_help ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) return args def emulation_command_look ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) if self . isEmulatingDynamicDescs : self . sendPlayer ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) return args def emulation_command_return ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump is not None : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) return args def emulation_command_rename ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"changes the room name. (useful for exploring places with many similar names)\"\"\" name : str = \" \" . join ( args ) . strip () if name : self . emulationRoom . name = name self . sendPlayer ( f \"Room name set to ' { name } '.\" ) else : self . sendPlayer ( \"Error: You must specify a new room name.\" ) return () def emulation_command_sync ( self , * args : str ) -> tuple [ str , ... ]: \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom . vnum ) return args def emulate_leave ( self , direction : str , * args : str ) -> tuple [ str , ... ]: \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return args vnum : str = self . emulationRoom . exits [ direction ] . to if vnum == \"death\" : self . output ( \"deathtrap!\" ) elif vnum == \"undefined\" : self . output ( \"undefined\" ) else : self . emulation_command_go ( vnum , isJump = False ) return args def user_command_emu ( self , inputText : str , * args : str ) -> None : if not inputText : self . output ( \"What command do you want to emulate?\" ) return None else : words : tuple [ str , ... ] = tuple ( inputText . strip () . split ()) while words : words = self . emulateCommands ( * words ) def emulateCommands ( self , * words : str ) -> tuple [ str , ... ]: userCommand : str = words [ 0 ] . lower () userArgs : tuple [ str , ... ] = words [ 1 :] # Get the full name of the user's command. for command in [ * DIRECTIONS , * self . emulationCommands ]: if command . startswith ( userCommand ): remainingArgs : tuple [ str , ... ] if command in DIRECTIONS : remainingArgs = self . emulate_leave ( command , * userArgs ) else : remainingArgs = getattr ( self , f \"emulation_command_ { command } \" )( * userArgs ) return remainingArgs # Else try to execute the user command as a regular mapper command. if userCommand in self . userCommands : # Call the user command from the emulation room. oldRoom : Room = self . currentRoom self . currentRoom = self . emulationRoom getattr ( self , f \"user_command_ { userCommand } \" )( \" \" . join ( userArgs )) self . currentRoom = oldRoom return () # Otherwise, treat userCommand as a potential vnum or room label to jump to. return self . emulation_command_go ( userCommand , * userArgs ) def user_command_gettimer ( self , * args : str ) -> None : self . sendPlayer ( f \"TIMER: { int ( default_timer () - self . initTimer ) } :TIMER\" ) def user_command_gettimerms ( self , * args : str ) -> None : self . sendPlayer ( f \"TIMERMS: { int (( default_timer () - self . initTimer ) * 1000 ) } :TIMERMS\" ) def user_command_clock ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( self . clock . time ()) else : self . sendGame ( self . clock . time ( args [ 0 ] . strip () . lower ())) def user_command_secretaction ( self , * args : str ) -> None : matchPattern : str = rf \"^\\s*(?P<action>.+?)(?:\\s+(?P<direction> { regexFuzzy ( DIRECTIONS ) } ))?$\" match : REGEX_MATCH = re . match ( matchPattern , args [ 0 ] . strip () . lower ()) if match is None : self . sendPlayer ( f \"Syntax: 'secretaction [action] [ { ' | ' . join ( DIRECTIONS ) } ]'.\" ) return None matchDict : dict [ str , str ] = match . groupdict () direction : str if matchDict [ \"direction\" ]: direction = \"\" . join ( d for d in DIRECTIONS if d . startswith ( matchDict [ \"direction\" ])) else : direction = \"\" door : str if direction and direction in self . currentRoom . exits and self . currentRoom . exits [ direction ] . door : door = self . currentRoom . exits [ direction ] . door else : door = \"exit\" self . sendGame ( \" \" . join ( item for item in ( matchDict [ \"action\" ], door , direction [ 0 : 1 ]) if item )) def user_command_automap ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoMapping = not self . autoMapping else : self . autoMapping = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto Mapping { 'on' if self . autoMapping else 'off' } .\" ) def user_command_autoupdate ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoUpdateRooms = not self . autoUpdateRooms else : self . autoUpdateRooms = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto update rooms { 'on' if self . autoUpdateRooms else 'off' } .\" ) def user_command_automerge ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoMerging = not self . autoMerging else : self . autoMerging = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto Merging { 'on' if self . autoMerging else 'off' } .\" ) def user_command_autolink ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . autoLinking = not self . autoLinking else : self . autoLinking = args [ 0 ] . strip () . lower () == \"on\" self . sendPlayer ( f \"Auto Linking { 'on' if self . autoLinking else 'off' } .\" ) def user_command_rdelete ( self , * args : str ) -> None : self . sendPlayer ( self . rdelete ( * args )) def user_command_fdoor ( self , * args : str ) -> None : self . sendPlayer ( self . fdoor ( self . findFormat , * args )) def user_command_fdynamic ( self , * args : str ) -> None : self . sendPlayer ( self . fdynamic ( self . findFormat , * args )) def user_command_flabel ( self , * args : str ) -> None : self . sendPlayer ( self . flabel ( self . findFormat , * args )) def user_command_fname ( self , * args : str ) -> None : self . sendPlayer ( self . fname ( self . findFormat , * args )) def user_command_fnote ( self , * args : str ) -> None : self . sendPlayer ( self . fnote ( self . findFormat , * args )) def user_command_farea ( self , * args : str ) -> None : self . sendPlayer ( self . farea ( self . findFormat , * args )) def user_command_fsid ( self , * args : str ) -> None : self . sendPlayer ( self . fsid ( self . findFormat , * args )) def user_command_rnote ( self , * args : str ) -> None : self . sendPlayer ( self . rnote ( * args )) def user_command_ralign ( self , * args : str ) -> None : self . sendPlayer ( self . ralign ( * args )) def user_command_rlight ( self , * args : str ) -> None : self . sendPlayer ( self . rlight ( * args )) def user_command_rportable ( self , * args : str ) -> None : self . sendPlayer ( self . rportable ( * args )) def user_command_rridable ( self , * args : str ) -> None : self . sendPlayer ( self . rridable ( * args )) def user_command_rsundeath ( self , * args : str ) -> None : self . sendPlayer ( self . rsundeath ( * args )) def user_command_ravoid ( self , * args : str ) -> None : self . sendPlayer ( self . ravoid ( * args )) def user_command_rterrain ( self , * args : str ) -> None : self . sendPlayer ( self . rterrain ( * args )) def user_command_rx ( self , * args : str ) -> None : self . sendPlayer ( self . rx ( * args )) def user_command_ry ( self , * args : str ) -> None : self . sendPlayer ( self . ry ( * args )) def user_command_rz ( self , * args : str ) -> None : self . sendPlayer ( self . rz ( * args )) def user_command_rmobflags ( self , * args : str ) -> None : self . sendPlayer ( self . rmobflags ( * args )) def user_command_rloadflags ( self , * args : str ) -> None : self . sendPlayer ( self . rloadflags ( * args )) def user_command_exitflags ( self , * args : str ) -> None : self . sendPlayer ( self . exitflags ( * args )) def user_command_doorflags ( self , * args : str ) -> None : self . sendPlayer ( self . doorflags ( * args )) def user_command_wordwrap ( self , * args : str ) -> None : try : value : bool = not self . mpiHandler . isWordWrapping self . mpiHandler . isWordWrapping = value cfg : Config = Config () cfg [ \"wordwrap\" ] = value cfg . save () del cfg self . sendPlayer ( f \"Word Wrap { 'enabled' if value else 'disabled' } .\" ) except LookupError as e : self . sendPlayer ( f \"Unable to toggle word wrapping: { ', ' . join ( e . args ) } .\" ) def user_command_secret ( self , * args : str ) -> None : self . sendPlayer ( self . secret ( * args )) def user_command_rlink ( self , * args : str ) -> None : self . sendPlayer ( self . rlink ( * args )) def user_command_rinfo ( self , * args : str ) -> None : self . sendPlayer ( self . rinfo ( * args )) def user_command_vnum ( self , * args : str ) -> None : \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" ) def user_command_tvnum ( self , * args : str ) -> None : \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" ) def user_command_rlabel ( self , * args : str ) -> None : self . rlabel ( * args ) def user_command_getlabel ( self , * args : str ) -> None : self . sendPlayer ( self . getlabel ( * args )) def user_command_savemap ( self , * args : str ) -> None : self . saveRooms () def user_command_run ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Usage: run [label|vnum]\" ) return None self . stopRun () match : REGEX_MATCH destination : str argString : str = args [ 0 ] . strip () if argString . lower () == \"t\" or argString . lower () . startswith ( \"t \" ): argString = argString [ 2 :] . strip () if not argString and self . lastPathFindQuery : self . sendPlayer ( f \"Run target set to ' { self . lastPathFindQuery } '. Use 'run t [rlabel|vnum]' to change it.\" ) return None elif not argString : self . sendPlayer ( \"Please specify a VNum or room label to target.\" ) return None self . lastPathFindQuery = argString self . sendPlayer ( f \"Setting run target to ' { self . lastPathFindQuery } '\" ) return None elif argString . lower () == \"c\" : if self . lastPathFindQuery : match = RUN_DESTINATION_REGEX . match ( self . lastPathFindQuery ) if match is None : return None destination = match . group ( \"destination\" ) self . sendPlayer ( destination ) else : self . sendPlayer ( \"Error: no previous path to continue.\" ) return None else : match = RUN_DESTINATION_REGEX . match ( argString ) if match is None : return None destination = match . group ( \"destination\" ) flags : str = match . group ( \"flags\" ) result : Union [ list [ str ], None ] = self . pathFind ( destination = destination , flags = flags . split ( \"|\" ) if flags else None ) if result is not None : self . autoWalk = True if result : if argString != \"c\" : self . lastPathFindQuery = argString self . autoWalkDirections . extend ( result ) self . walkNextDirection () def user_command_step ( self , * args : str ) -> None : if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Usage: step [label|vnum]\" ) return None self . autoWalkDirections . clear () argString : str = args [ 0 ] . strip () match : REGEX_MATCH = RUN_DESTINATION_REGEX . match ( argString ) if match is not None : destination : str = match . group ( \"destination\" ) flags : str = match . group ( \"flags\" ) result : Union [ list [ str ], None ] = self . pathFind ( destination = destination , flags = flags . split ( \"|\" ) if flags else None ) if result is not None : self . autoWalkDirections . extend ( result ) self . walkNextDirection () return None self . sendPlayer ( \"Please specify a valid destination.\" ) def user_command_stop ( self , * args : str ) -> None : self . stopRun () self . sendPlayer ( \"Run canceled!\" ) def user_command_path ( self , * args : str ) -> None : self . path ( * args ) def user_command_sync ( self , * args : str ) -> None : if not args or not args [ 0 ]: self . sendPlayer ( \"Map no longer synced. Auto sync on.\" ) self . isSynced = False self . sendGame ( \"look\" ) else : self . sync ( vnum = args [ 0 ] . strip ()) def user_command_maphelp ( self , * args : str ) -> None : \"\"\"Shows documentation for mapper commands\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) def walkNextDirection ( self ) -> None : if not self . autoWalkDirections : return None while self . autoWalkDirections : command : str = self . autoWalkDirections . pop () if not self . autoWalkDirections : self . sendPlayer ( \"Arriving at destination.\" ) self . autoWalk = False if command in DIRECTIONS : # Send the first character of the direction to Mume. self . sendGame ( command [ 0 ]) break else : # command is a non-direction such as 'lead' or 'ride'. self . sendGame ( command ) def stopRun ( self ) -> None : self . autoWalk = False self . autoWalkDirections . clear () def sync ( self , name : Optional [ str ] = None , desc : Optional [ str ] = None , vnum : Optional [ str ] = None , ) -> bool : if vnum is not None : roomObj : Union [ Room , None ] = self . getRoomFromLabel ( vnum ) if roomObj is not None : self . currentRoom = roomObj self . isSynced = True self . sendPlayer ( f \"Synced to room { self . currentRoom . name } with vnum { self . currentRoom . vnum } \" ) else : nameVnums : list [ str ] = [] descVnums : list [ str ] = [] for vnum , roomObj in self . rooms . items (): if name and roomObj . name == name : nameVnums . append ( vnum ) if desc and roomObj . desc == desc : descVnums . append ( vnum ) if not nameVnums : self . sendPlayer ( \"Current room not in the database. Unable to sync.\" ) elif len ( descVnums ) == 1 : self . currentRoom = self . rooms [ descVnums [ 0 ]] self . isSynced = True self . sendPlayer ( f \"Synced to room { self . currentRoom . name } with vnum { self . currentRoom . vnum } \" ) elif len ( nameVnums ) == 1 : self . currentRoom = self . rooms [ nameVnums [ 0 ]] self . isSynced = True self . sendPlayer ( f \"Name-only synced to room { self . currentRoom . name } with vnum { self . currentRoom . vnum } \" ) else : self . sendPlayer ( \"More than one room in the database matches current room. Unable to sync.\" ) return self . isSynced def roomDetails ( self ) -> None : doors : list [ str ] = [] deathTraps : list [ str ] = [] oneWays : list [ str ] = [] undefineds : list [ str ] = [] for direction , exitObj in self . currentRoom . exits . items (): if exitObj . door and exitObj . door != \"exit\" : doors . append ( f \" { direction } : { exitObj . door } \" ) if not exitObj . to or exitObj . to == \"undefined\" : undefineds . append ( direction ) elif exitObj . to == \"death\" : deathTraps . append ( direction ) elif ( REVERSE_DIRECTIONS [ direction ] not in self . rooms [ exitObj . to ] . exits or self . rooms [ exitObj . to ] . exits [ REVERSE_DIRECTIONS [ direction ]] . to != self . currentRoom . vnum ): oneWays . append ( direction ) if doors : self . sendPlayer ( f \"Doors: { ', ' . join ( doors ) } \" , showPrompt = False ) if deathTraps : self . sendPlayer ( f \"Death Traps: { ', ' . join ( deathTraps ) } \" , showPrompt = False ) if oneWays : self . sendPlayer ( f \"One ways: { ', ' . join ( oneWays ) } \" , showPrompt = False ) if undefineds : self . sendPlayer ( f \"Undefineds: { ', ' . join ( undefineds ) } \" , showPrompt = False ) if self . currentRoom . note : self . sendPlayer ( f \"Note: { self . currentRoom . note } \" , showPrompt = False ) def updateRoomFlags ( self ) -> None : output : list [ str ] = [] lightSymbol : Union [ str , None ] = self . gmcpCharVitals . get ( \"light\" ) if lightSymbol is not None and lightSymbol in LIGHT_SYMBOLS : light : str = LIGHT_SYMBOLS [ lightSymbol ] if light == \"lit\" and self . currentRoom . light != light : # Todo: Orc can define sundeath, troll can define no_sundeath and lit/dark. # output.append(self.rlight(\"lit\")) pass ridable : bool = bool ( self . gmcpCharVitals . get ( \"ride\" ) or self . gmcpCharVitals . get ( \"ridden\" )) if ridable and self . currentRoom . ridable != \"ridable\" : output . append ( self . rridable ( \"ridable\" )) if output : self . sendPlayer ( \" \\n \" . join ( output )) def updateExitFlags ( self , exits : str ) -> None : if not exits : return None output : list [ str ] = [] exitsOutput : list [ str ] = [] for door , road , climb , portal , direction in EXIT_TAGS_REGEX . findall ( exits ): # Portals aren't real exits. if portal : continue if direction not in self . currentRoom . exits : output . append ( f \"Adding exit ' { direction } ' to current room.\" ) self . currentRoom . exits [ direction ] = self . getNewExit ( direction ) if self . autoLinking : currentRoomCoords : tuple [ int , int , int ] = ( self . currentRoom . x , self . currentRoom . y , self . currentRoom . z , ) vnums : list [ str ] = [ vnum for vnum , roomObj in self . rooms . items () if self . coordinatesAddDirection ( currentRoomCoords , direction ) == ( roomObj . x , roomObj . y , roomObj . z ) ] if ( len ( vnums ) == 1 and REVERSE_DIRECTIONS [ direction ] in self . rooms [ vnums [ 0 ]] . exits and self . rooms [ vnums [ 0 ]] . exits [ REVERSE_DIRECTIONS [ direction ]] . to == \"undefined\" ): output . append ( self . rlink ( f \"add { vnums [ 0 ] } { direction } \" )) roomExit : Exit = self . currentRoom . exits [ direction ] if door and \"door\" not in roomExit . exitFlags : output . append ( self . exitflags ( f \"add door { direction } \" )) if road and \"road\" not in roomExit . exitFlags : output . append ( self . exitflags ( f \"add road { direction } \" )) if climb and \"climb\" not in roomExit . exitFlags : output . append ( self . exitflags ( f \"add climb { direction } \" )) if exitsOutput : exitsOutput . insert ( 0 , f \"Exit { direction } :\" ) output . extend ( exitsOutput ) exitsOutput . clear () if output : self . sendPlayer ( \" \\n \" . join ( output )) def autoMergeRoom ( self , movement : str , roomObj : Room ) -> None : output : list [ str ] = [] if ( self . autoLinking and REVERSE_DIRECTIONS [ movement ] in roomObj . exits and roomObj . exits [ REVERSE_DIRECTIONS [ movement ]] . to == \"undefined\" ): output . append ( self . rlink ( f \"add { roomObj . vnum } { movement } \" )) else : output . append ( self . rlink ( f \"add oneway { roomObj . vnum } { movement } \" )) output . append ( f \"Auto Merging ' { roomObj . vnum } ' with name ' { roomObj . name } '.\" ) self . sendPlayer ( \" \\n \" . join ( output )) def addNewRoom ( self , movement : str , name : str , description : str , dynamic : str ) -> None : vnum : str = self . getNewVnum () newRoom : Room = Room () newRoom . vnum = vnum newRoom . name = name newRoom . desc = description newRoom . dynamicDesc = dynamic newRoom . x , newRoom . y , newRoom . z = self . coordinatesAddDirection ( ( self . currentRoom . x , self . currentRoom . y , self . currentRoom . z ), movement ) self . rooms [ vnum ] = newRoom if movement not in self . currentRoom . exits : self . currentRoom . exits [ movement ] = self . getNewExit ( movement , to = vnum ) else : self . currentRoom . exits [ movement ] . to = vnum self . sendPlayer ( f \"Adding room ' { newRoom . name } ' with vnum ' { vnum } '\" ) def mud_event_gmcp_char_vitals ( self , text : str ) -> None : newValues : dict [ str , Any ] = json . loads ( text ) self . gmcpCharVitals . update ( newValues ) if self . autoMapping : self . updateRoomFlags () def mud_event_prompt ( self , text : str ) -> None : self . playerTelnetHandler . mpmEventSend ({ \"prompt\" : text }) self . prompt = text if self . isSynced : if self . autoMapping and self . moved : self . updateRoomFlags () elif self . roomName : self . sync ( self . roomName , self . description ) if self . isSynced and self . dynamic is not None : self . roomDetails () if self . autoWalkDirections and self . moved and self . autoWalk : # The player is auto-walking. Send the next direction to Mume. self . walkNextDirection () self . scouting = False self . movement = None self . moved = None self . roomName = None self . description = None self . dynamic = None def mud_event_movement ( self , text : str ) -> None : self . movement = text self . scouting = False def mud_event_line ( self , text : str ) -> None : if text . startswith ( \"You quietly scout \" ): self . scouting = True return None elif text == \"A huge clock is standing here.\" : self . sendGame ( \"look at clock\" ) elif text == ( \"Wet, cold and filled with mud you drop down into a dark \" + \"and moist cave, while you notice the mud above you moving \" + \"to close the hole you left in the cave ceiling.\" ): self . sync ( vnum = \"17189\" ) elif text == ( \"The gravel below your feet loosens, shifting slightly.. \" + \"Suddenly, you lose your balance and crash to the cave floor below.\" ): self . sync ( vnum = \"15324\" ) elif not self . timeSynchronized : self . syncTime ( text ) if MOVEMENT_FORCED_REGEX . search ( text ) or MOVEMENT_PREVENTED_REGEX . search ( text ): self . stopRun () if self . isSynced and self . autoMapping : if text == \"It's too difficult to ride here.\" and self . currentRoom . ridable != \"not_ridable\" : self . sendPlayer ( self . rridable ( \"not_ridable\" )) elif text == \"You are already riding.\" and self . currentRoom . ridable != \"ridable\" : self . sendPlayer ( self . rridable ( \"ridable\" )) def syncTime ( self , text : str ) -> None : clockMatch : REGEX_MATCH = CLOCK_REGEX . match ( text ) timeMatch : REGEX_MATCH = TIME_REGEX . match ( text ) if self . timeEvent is None : if clockMatch is not None : hour : int = int ( clockMatch . group ( \"hour\" )) minutes : int = int ( clockMatch . group ( \"minutes\" )) amPm : str = clockMatch . group ( \"am_pm\" ) # parsedHour should be 0 - 23. self . parsedHour = hour % 12 + ( 12 if amPm == \"pm\" else 0 ) self . parsedMinutes = minutes if self . parsedHour == 23 and self . parsedMinutes == 59 : OneShot ( 1.0 , self . sendGame , \"look at clock\" ) else : self . timeEvent = \"clock\" self . sendGame ( \"time\" ) elif DAWN_REGEX . match ( text ) is not None : self . timeEvent = \"dawn\" self . timeEventOffset = 0 self . sendGame ( \"time\" ) elif DAY_REGEX . match ( text ) is not None : self . timeEvent = \"dawn\" self . timeEventOffset = 1 self . sendGame ( \"time\" ) elif DUSK_REGEX . match ( text ) is not None : self . timeEvent = \"dusk\" self . timeEventOffset = 0 self . sendGame ( \"time\" ) elif NIGHT_REGEX . match ( text ) is not None : self . timeEvent = \"dusk\" self . timeEventOffset = 1 self . sendGame ( \"time\" ) elif timeMatch is not None : day : int = int ( timeMatch . group ( \"day\" )) year : int = int ( timeMatch . group ( \"year\" )) month : int = 0 for i , m in enumerate ( MONTHS ): if timeMatch . group ( \"month\" ) in ( m [ \"westron\" ], m [ \"sindarin\" ]): month = i break if self . timeEvent in ( \"dawn\" , \"dusk\" ): self . parsedHour = int ( MONTHS [ month ][ self . timeEvent ]) + self . timeEventOffset self . parsedMinutes = 0 self . clock . setTime ( year , month , day , self . parsedHour , self . parsedMinutes ) self . timeEvent = None self . timeEventOffset = 0 self . timeSynchronized = True self . sendPlayer ( f \"Synchronized with epoch { self . clock . epoch } .\" , showPrompt = False ) def mud_event_room ( self , text : str ) -> None : self . xmlRoomAttributes . clear () self . xmlRoomAttributes . update ( getXMLAttributes ( text )) def mud_event_name ( self , text : str ) -> None : if text not in ( \"You just see a dense fog around you...\" , \"It is pitch black...\" ): self . roomName = simplified ( text ) else : self . roomName = \"\" def mud_event_description ( self , text : str ) -> None : self . description = simplified ( text ) def validateMovement ( self , movement : str ) -> bool : if not movement : # The player was forcibly moved in an unknown direction. self . sendPlayer ( \"Forced movement, no longer synced.\" ) elif movement not in DIRECTIONS : self . sendPlayer ( f \"Error: Invalid direction ' { movement } '. Map no longer synced!\" ) elif not self . autoMapping and movement not in self . currentRoom . exits : self . sendPlayer ( f \"Error: direction ' { movement } ' not in database. Map no longer synced!\" ) elif not self . autoMapping and self . currentRoom . exits [ movement ] . to not in self . rooms : self . sendPlayer ( f \"Error: vnum ( { self . currentRoom . exits [ movement ] . to } ) in direction ( { movement } ) \" + \"is not in the database. Map no longer synced!\" ) else : return True self . isSynced = False return False def updateRooms ( self ) -> None : if self . roomName and self . currentRoom . name != self . roomName : self . currentRoom . name = self . roomName self . sendPlayer ( \"Updating room name.\" ) if self . description and self . currentRoom . desc != self . description : self . currentRoom . desc = self . description self . sendPlayer ( \"Updating room description.\" ) if self . dynamic and self . currentRoom . dynamicDesc != self . dynamic : self . currentRoom . dynamicDesc = self . dynamic self . sendPlayer ( \"Updating room dynamic description.\" ) terrain : Union [ str , None ] = self . xmlRoomAttributes . get ( \"terrain\" ) if terrain is not None and self . currentRoom . terrain != terrain : self . sendPlayer ( self . rterrain ( terrain )) area : Union [ str , None ] = self . xmlRoomAttributes . get ( \"area\" ) if area is not None and self . currentRoom . area != area : self . currentRoom . area = area self . sendPlayer ( f \"Setting room area to ' { area } '.\" ) serverID : Union [ str , None ] = self . xmlRoomAttributes . get ( \"id\" ) if serverID is not None and serverID . isdigit () and self . currentRoom . serverID != serverID : self . currentRoom . serverID = serverID self . sendPlayer ( f \"Setting room server ID to ' { serverID } '.\" ) def mud_event_dynamic ( self , text : str ) -> None : self . dynamic = text . lstrip () self . moved = None addedNewRoomFrom : Union [ str , None ] = None if not self . isSynced or self . movement is None : return None elif self . validateMovement ( self . movement ): if self . autoMapping and ( self . movement not in self . currentRoom . exits or self . currentRoom . exits [ self . movement ] . to not in self . rooms ): # Player has moved in a direction that either doesn't exist in the database # or links to an invalid vnum (E.G. undefined). duplicates : Union [ list [ Room ], None ] if self . autoMerging and self . roomName and self . description : duplicates = self . searchRooms ( exactMatch = True , name = self . roomName , desc = self . description ) else : duplicates = None if not self . roomName : self . sendPlayer ( \"Unable to add new room: empty room name.\" ) elif not self . description : self . sendPlayer ( \"Unable to add new room: empty room description.\" ) elif duplicates is not None and len ( duplicates ) == 1 : self . autoMergeRoom ( self . movement , duplicates [ 0 ]) else : # Create new room. addedNewRoomFrom = self . currentRoom . vnum self . addNewRoom ( self . movement , self . roomName , self . description , self . dynamic ) self . currentRoom = self . rooms [ self . currentRoom . exits [ self . movement ] . to ] self . moved = self . movement self . movement = None if self . autoMapping and self . autoUpdateRooms : self . updateRooms () if self . autoMapping and self . isSynced and self . moved and self . exits : if addedNewRoomFrom and REVERSE_DIRECTIONS [ self . moved ] in self . exits : self . currentRoom . exits [ REVERSE_DIRECTIONS [ self . moved ]] = self . getNewExit ( REVERSE_DIRECTIONS [ self . moved ], to = addedNewRoomFrom ) self . updateExitFlags ( self . exits ) self . exits = None def mud_event_exits ( self , text : str ) -> None : self . exits = text def handleUserInput ( self , text : str ) -> None : text = text . strip () if not text : return None elif self . isEmulatingOffline : self . user_command_emu ( text ) else : userCommand : str = text . split ()[ 0 ] args : str = removePrefix ( text , userCommand ) . strip () getattr ( self , f \"user_command_ { userCommand } \" )( args ) def handleMudEvent ( self , event : str , text : str ) -> None : text = stripAnsi ( text ) if event in self . mudEventHandlers : if not self . scouting or event in ( \"prompt\" , \"movement\" ): for handler in self . mudEventHandlers [ event ]: handler ( text ) elif event not in self . unknownMudEvents : self . unknownMudEvents . append ( event ) logger . debug ( f \"received data with an unknown event type of { event } \" ) def registerMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () if event in self . unknownMudEvents : self . unknownMudEvents . remove ( event ) self . mudEventHandlers [ event ] . add ( handler ) def deregisterMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) if not self . mudEventHandlers [ event ]: del self . mudEventHandlers [ event ] def run ( self ) -> None : for item in iter ( self . queue . get , None ): try : event , data = item text = decodeBytes ( data ) if event == \"userInput\" : self . handleUserInput ( text ) else : self . handleMudEvent ( event , text ) except Exception : self . output ( f \"Error in mapper thread: \\n { traceback . format_exc () . strip () } \" ) logger . exception ( \"Error in mapper thread\" ) self . sendPlayer ( \"Exiting mapper thread.\" )","title":"Mapper"},{"location":"api/mapper/#mapper.mapper.Mapper.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/mapper/#mapper.mapper.Mapper.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/mapper/#mapper.mapper.Mapper.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/mapper/#mapper.mapper.Mapper.native_id","text":"Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"native_id"},{"location":"api/mapper/#mapper.mapper.Mapper.GUIRefresh","text":"Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\mapper.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_guiRefresh\" ,))","title":"GUIRefresh()"},{"location":"api/mapper/#mapper.mapper.Mapper.createSpeedWalk","text":"Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\mapper.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> list [ str ]: speedWalkDirs : list [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : list [ str ] = [] directionsBuffer : list [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \"","title":"createSpeedWalk()"},{"location":"api/mapper/#mapper.mapper.Mapper.deregisterMudEventHandler","text":"Deregisters mud event handlers. params: same as registerMudEventHandler. Source code in mapper\\mapper.py def deregisterMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) if not self . mudEventHandlers [ event ]: del self . mudEventHandlers [ event ]","title":"deregisterMudEventHandler()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulate_leave","text":"emulates leaving the room into a neighbouring room Source code in mapper\\mapper.py def emulate_leave ( self , direction : str , * args : str ) -> tuple [ str , ... ]: \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return args vnum : str = self . emulationRoom . exits [ direction ] . to if vnum == \"death\" : self . output ( \"deathtrap!\" ) elif vnum == \"undefined\" : self . output ( \"undefined\" ) else : self . emulation_command_go ( vnum , isJump = False ) return args","title":"emulate_leave()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_at","text":"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_at ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"mimic the /at command that the ainur use. Syntax: at (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () command : str = \" \" . join ( args [ 1 :]) . strip () if not label : self . sendPlayer ( \"Please provide a room in which to execute commands.\" ) else : room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is None : pass # Alternative suggestions were sent by the call to `getRoomFromLabel`. elif not command : self . sendPlayer ( f \"What do you want to do at { label } ?\" ) else : # Execute command at room. oldRoom : Room = self . emulationRoom self . emulationRoom = room self . user_command_emu ( command ) self . emulationRoom = oldRoom return ()","title":"emulation_command_at()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_brief","text":"toggles brief mode. Source code in mapper\\mapper.py def emulation_command_brief ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) return args","title":"emulation_command_brief()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_dynamic","text":"toggles automatic speaking of dynamic descs. Source code in mapper\\mapper.py def emulation_command_dynamic ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"toggles automatic speaking of dynamic descs.\"\"\" self . isEmulatingDynamicDescs = not self . isEmulatingDynamicDescs self . sendPlayer ( f \"dynamic descs { 'on' if self . isEmulatingDynamicDescs else 'off' } \" ) return args","title":"emulation_command_dynamic()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_examine","text":"shows the room's description. Source code in mapper\\mapper.py def emulation_command_examine ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) return args","title":"emulation_command_examine()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_exits","text":"shows the exits in the room. Source code in mapper\\mapper.py def emulation_command_exits ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"shows the exits in the room.\"\"\" exits : list [ str ] = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) return args","title":"emulation_command_exits()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_go","text":"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command) Source code in mapper\\mapper.py def emulation_command_go ( self , * args : str , isJump : bool = True ) -> tuple [ str , ... ]: \"\"\"mimic the /go command that the ainur use. Syntax: go (room label|room number) (command)\"\"\" label : str = \"\" . join ( args [: 1 ]) . strip () args = args [ 1 :] room : Union [ Room , None ] = self . getRoomFromLabel ( label ) if room is not None : self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room . vnum return args","title":"emulation_command_go()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_help","text":"Shows documentation for mapper's emulation commands. Source code in mapper\\mapper.py def emulation_command_help ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) return args","title":"emulation_command_help()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_look","text":"looks at the room. Source code in mapper\\mapper.py def emulation_command_look ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) if self . isEmulatingDynamicDescs : self . sendPlayer ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) return args","title":"emulation_command_look()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_quit","text":"Exits the program. Source code in mapper\\mapper.py def emulation_command_quit ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) return args","title":"emulation_command_quit()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_rename","text":"changes the room name. (useful for exploring places with many similar names) Source code in mapper\\mapper.py def emulation_command_rename ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"changes the room name. (useful for exploring places with many similar names)\"\"\" name : str = \" \" . join ( args ) . strip () if name : self . emulationRoom . name = name self . sendPlayer ( f \"Room name set to ' { name } '.\" ) else : self . sendPlayer ( \"Error: You must specify a new room name.\" ) return ()","title":"emulation_command_rename()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_return","text":"returns to the last room jumped to with the go command. Source code in mapper\\mapper.py def emulation_command_return ( self , * args : str ) -> tuple [ str , ... ]: \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump is not None : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) return args","title":"emulation_command_return()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_sync","text":"When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. Source code in mapper\\mapper.py def emulation_command_sync ( self , * args : str ) -> tuple [ str , ... ]: \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom . vnum ) return args","title":"emulation_command_sync()"},{"location":"api/mapper/#mapper.mapper.Mapper.getName","text":"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. Source code in mapper\\mapper.py def getName ( self ): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'getName() is deprecated, get the name attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . name","title":"getName()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNeighborsFromCoordinates","text":"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromCoordinates()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNeighborsFromRoom","text":"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromRoom()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNewExit","text":"Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\mapper.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit","title":"getNewExit()"},{"location":"api/mapper/#mapper.mapper.Mapper.isBidirectional","text":"Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\mapper.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False","title":"isBidirectional()"},{"location":"api/mapper/#mapper.mapper.Mapper.isDaemon","text":"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. Source code in mapper\\mapper.py def isDaemon ( self ): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings . warn ( 'isDaemon() is deprecated, get the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) return self . daemon","title":"isDaemon()"},{"location":"api/mapper/#mapper.mapper.Mapper.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). Source code in mapper\\mapper.py def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/mapper/#mapper.mapper.Mapper.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\mapper.py def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/mapper/#mapper.mapper.Mapper.pathFind","text":"Find the path Source code in mapper\\mapper.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> list [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : frozenset [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : frozenset [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"pathFind()"},{"location":"api/mapper/#mapper.mapper.Mapper.registerMudEventHandler","text":"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. Source code in mapper\\mapper.py def registerMudEventHandler ( self , event : str , handler : MUD_EVENT_HANDLER_TYPE ) -> None : \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, text, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () if event in self . unknownMudEvents : self . unknownMudEvents . remove ( event ) self . mudEventHandlers [ event ] . add ( handler )","title":"registerMudEventHandler()"},{"location":"api/mapper/#mapper.mapper.Mapper.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\mapper.py def run ( self ) -> None : for item in iter ( self . queue . get , None ): try : event , data = item text = decodeBytes ( data ) if event == \"userInput\" : self . handleUserInput ( text ) else : self . handleMudEvent ( event , text ) except Exception : self . output ( f \"Error in mapper thread: \\n { traceback . format_exc () . strip () } \" ) logger . exception ( \"Error in mapper thread\" ) self . sendPlayer ( \"Exiting mapper thread.\" )","title":"run()"},{"location":"api/mapper/#mapper.mapper.Mapper.setDaemon","text":"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. Source code in mapper\\mapper.py def setDaemon ( self , daemonic ): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings . warn ( 'setDaemon() is deprecated, set the daemon attribute instead' , DeprecationWarning , stacklevel = 2 ) self . daemon = daemonic","title":"setDaemon()"},{"location":"api/mapper/#mapper.mapper.Mapper.setName","text":"Set the name string for this thread. This method is deprecated, use the name attribute instead. Source code in mapper\\mapper.py def setName ( self , name ): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings . warn ( 'setName() is deprecated, set the name attribute instead' , DeprecationWarning , stacklevel = 2 ) self . name = name","title":"setName()"},{"location":"api/mapper/#mapper.mapper.Mapper.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\mapper.py def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_maphelp","text":"Shows documentation for mapper commands Source code in mapper\\mapper.py def user_command_maphelp ( self , * args : str ) -> None : \"\"\"Shows documentation for mapper commands\"\"\" helpTexts : list [ tuple [ str , str ]] = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs : list [ tuple [ str , str ]] = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs : list [ tuple [ str , str ]] = [ text for text in helpTexts if not text [ 1 ] . strip ()] result : list [ str ] = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result ))","title":"user_command_maphelp()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_tvnum","text":"tells a given char the vnum of your room Source code in mapper\\mapper.py def user_command_tvnum ( self , * args : str ) -> None : \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" )","title":"user_command_tvnum()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_vnum","text":"states the vnum of the current room Source code in mapper\\mapper.py def user_command_vnum ( self , * args : str ) -> None : \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" )","title":"user_command_vnum()"},{"location":"api/mudevents/","text":"Module mapper.mudevents \u00b6 Class Handler( ABC ) \u00b6 Source code in mapper\\mudevents.py class Handler ( ABC ): def __init__ ( self , mapper : Mapper , event : Optional [ str ] = None ) -> None : \"\"\" Initialises a mud event handler in the given mapper instance. Args: mapper: An instance of mapper.mapper.Mapper that dispatches events. event: The event name. May be omitted if the subclass defines an event attribute. \"\"\" self . mapper = mapper if event : self . event = event elif not hasattr ( self , \"event\" ): raise ValueError ( \"Tried to initialise handler without an event type.\" + \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) self . mapper . registerMudEventHandler ( self . event , self . handle ) def __del__ ( self ) -> None : \"\"\"Deregisters the event handler after the object is deleted and garbage collected.\"\"\" if hasattr ( self , \"event\" ): self . mapper . deregisterMudEventHandler ( self . event , self . handle ) @abstractmethod def handle ( self , text : str ) -> None : \"\"\"Called when the event is dispatched.\"\"\" Method __init__ ( self , mapper , event = None ) special \u00b6 Initialises a mud event handler in the given mapper instance. Parameters: Name Type Description Default mapper Mapper An instance of mapper.mapper.Mapper that dispatches events. required event Optional[str] The event name. May be omitted if the subclass defines an event attribute. None Source code in mapper\\mudevents.py def __init__ ( self , mapper : Mapper , event : Optional [ str ] = None ) -> None : \"\"\" Initialises a mud event handler in the given mapper instance. Args: mapper: An instance of mapper.mapper.Mapper that dispatches events. event: The event name. May be omitted if the subclass defines an event attribute. \"\"\" self . mapper = mapper if event : self . event = event elif not hasattr ( self , \"event\" ): raise ValueError ( \"Tried to initialise handler without an event type.\" + \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) self . mapper . registerMudEventHandler ( self . event , self . handle ) Method handle ( self , text ) \u00b6 Called when the event is dispatched. Source code in mapper\\mudevents.py @abstractmethod def handle ( self , text : str ) -> None : \"\"\"Called when the event is dispatched.\"\"\"","title":"mudevents.py"},{"location":"api/mudevents/#mapper.mudevents","text":"","title":"mudevents"},{"location":"api/mudevents/#mapper.mudevents.Handler","text":"Source code in mapper\\mudevents.py class Handler ( ABC ): def __init__ ( self , mapper : Mapper , event : Optional [ str ] = None ) -> None : \"\"\" Initialises a mud event handler in the given mapper instance. Args: mapper: An instance of mapper.mapper.Mapper that dispatches events. event: The event name. May be omitted if the subclass defines an event attribute. \"\"\" self . mapper = mapper if event : self . event = event elif not hasattr ( self , \"event\" ): raise ValueError ( \"Tried to initialise handler without an event type.\" + \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) self . mapper . registerMudEventHandler ( self . event , self . handle ) def __del__ ( self ) -> None : \"\"\"Deregisters the event handler after the object is deleted and garbage collected.\"\"\" if hasattr ( self , \"event\" ): self . mapper . deregisterMudEventHandler ( self . event , self . handle ) @abstractmethod def handle ( self , text : str ) -> None : \"\"\"Called when the event is dispatched.\"\"\"","title":"Handler"},{"location":"api/mudevents/#mapper.mudevents.Handler.__init__","text":"Initialises a mud event handler in the given mapper instance. Parameters: Name Type Description Default mapper Mapper An instance of mapper.mapper.Mapper that dispatches events. required event Optional[str] The event name. May be omitted if the subclass defines an event attribute. None Source code in mapper\\mudevents.py def __init__ ( self , mapper : Mapper , event : Optional [ str ] = None ) -> None : \"\"\" Initialises a mud event handler in the given mapper instance. Args: mapper: An instance of mapper.mapper.Mapper that dispatches events. event: The event name. May be omitted if the subclass defines an event attribute. \"\"\" self . mapper = mapper if event : self . event = event elif not hasattr ( self , \"event\" ): raise ValueError ( \"Tried to initialise handler without an event type.\" + \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) self . mapper . registerMudEventHandler ( self . event , self . handle )","title":"__init__()"},{"location":"api/mudevents/#mapper.mudevents.Handler.handle","text":"Called when the event is dispatched. Source code in mapper\\mudevents.py @abstractmethod def handle ( self , text : str ) -> None : \"\"\"Called when the event is dispatched.\"\"\"","title":"handle()"},{"location":"api/utils/","text":"Module mapper.utils \u00b6 Class ContainerEmptyMixin \u00b6 A mixin class to be used in unit tests. Source code in mapper\\utils.py class ContainerEmptyMixin : \"\"\" A mixin class to be used in unit tests. \"\"\" assertIsInstance : Callable [ ... , Any ] assertTrue : Callable [ ... , Any ] assertFalse : Callable [ ... , Any ] def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj ) def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj ) Method assertContainerEmpty ( self , obj ) \u00b6 Asserts whether the given object is an empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in mapper\\utils.py def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj ) Method assertContainerNotEmpty ( self , obj ) \u00b6 Asserts whether the given object is a non-empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in mapper\\utils.py def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj ) Function average ( items ) \u00b6 Calculates the average item length of an iterable. Parameters: Name Type Description Default items Iterable[float] The iterable of items. required Returns: Type Description float The average item length. Source code in mapper\\utils.py def average ( items : Iterable [ float ]) -> float : \"\"\" Calculates the average item length of an iterable. Args: items: The iterable of items. Returns: The average item length. \"\"\" try : return statistics . mean ( items ) except statistics . StatisticsError : # No items. return 0 Function camelCase ( text , delimiter ) \u00b6 converts text to camel case. Parameters: Name Type Description Default text str The text to be converted. required delimiter str The delimiter between words. required Returns: Type Description str The text in camel case. Source code in mapper\\utils.py def camelCase ( text : str , delimiter : str ) -> str : \"\"\" converts text to camel case. Args: text: The text to be converted. delimiter: The delimiter between words. Returns: The text in camel case. \"\"\" words = text . split ( delimiter ) return \"\" . join (( * map ( str . lower , words [: 1 ]), * map ( str . title , words [ 1 :]))) Function clamp ( value , minimum , maximum ) \u00b6 Clamps the given value between the given minimum and maximum values. Parameters: Name Type Description Default value float The value to restrict inside the range defined by minimum and maximum. required minimum float The minimum value to compare against. required maximum float The maximum value to compare against. required Returns: Type Description float The result between minimum and maximum. Source code in mapper\\utils.py def clamp ( value : float , minimum : float , maximum : float ) -> float : \"\"\" Clamps the given value between the given minimum and maximum values. Args: value: The value to restrict inside the range defined by minimum and maximum. minimum: The minimum value to compare against. maximum: The maximum value to compare against. Returns: The result between minimum and maximum. \"\"\" return minimum if value < minimum else maximum if value > maximum else value Function decodeBytes ( data ) \u00b6 Decodes bytes into a string. If data contains Latin-1 characters, they will be replaced with ASCII equivalents. Parameters: Name Type Description Default data bytes The data to be decoded. required Returns: Type Description str The decoded string. Source code in mapper\\utils.py def decodeBytes ( data : bytes ) -> str : \"\"\" Decodes bytes into a string. If data contains Latin-1 characters, they will be replaced with ASCII equivalents. Args: data: The data to be decoded. Returns: The decoded string. \"\"\" if not isinstance ( data , ( bytes , bytearray )): raise TypeError ( \"Data must be a bytes-like object.\" ) with suppress ( UnicodeDecodeError ): return str ( data , \"us-ascii\" ) try : # If UTF-8, re-encode the data before decoding because of multi-byte code points. return data . decode ( \"utf-8\" ) . encode ( \"us-ascii\" , \"latin2ascii\" ) . decode ( \"us-ascii\" ) except UnicodeDecodeError : # Assume data is Latin-1. return str ( data , \"us-ascii\" , \"latin2ascii\" ) Function formatDocString ( functionOrString , width = 79 , prefix = None ) \u00b6 Formats a docstring for displaying. Parameters: Name Type Description Default functionOrString Union[str, Callable[..., Any]] The function containing the docstring, or the docstring its self. required width int The number of characters to word wrap each line to. 79 prefix Optional[str] One or more characters to use for indention. None Returns: Type Description str The formatted docstring. Source code in mapper\\utils.py def formatDocString ( functionOrString : Union [ str , Callable [ ... , Any ]], width : int = 79 , prefix : Optional [ str ] = None ) -> str : \"\"\" Formats a docstring for displaying. Args: functionOrString: The function containing the docstring, or the docstring its self. width: The number of characters to word wrap each line to. prefix: One or more characters to use for indention. Returns: The formatted docstring. \"\"\" if callable ( functionOrString ): # It's a function. docString = getattr ( functionOrString , \"__doc__\" ) or \"\" else : # It's a string. docString = functionOrString # Remove any empty lines from the beginning, while keeping indention. docString = docString . lstrip ( \" \\r\\n \" ) match = INDENT_REGEX . search ( docString ) if match is not None and not match . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): match = INDENT_REGEX . search ( line ) if match is None : # pragma: no cover continue indent , text = match . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix if prefix is not None else \"\" ) # Indent docstring lines with the prefix. return docString Function getDataPath ( * args ) \u00b6 Retrieves the path of the data directory. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the data path. () Returns: Type Description str The path. Source code in mapper\\utils.py def getDataPath ( * args : str ) -> str : \"\"\" Retrieves the path of the data directory. Args: *args: Positional arguments to be passed to os.join after the data path. Returns: The path. \"\"\" return os . path . realpath ( os . path . join ( getDirectoryPath ( DATA_DIRECTORY ), * args )) Function getDirectoryPath ( * args ) \u00b6 Retrieves the path of the directory where the program is located. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the directory path. () Returns: Type Description str The path. Source code in mapper\\utils.py def getDirectoryPath ( * args : str ) -> str : \"\"\" Retrieves the path of the directory where the program is located. Args: *args: Positional arguments to be passed to os.join after the directory path. Returns: The path. \"\"\" if isFrozen (): path = os . path . dirname ( sys . executable ) else : path = os . path . join ( os . path . dirname ( __file__ ), os . path . pardir ) return os . path . realpath ( os . path . join ( path , * args )) Function getFreezer () \u00b6 Determines the name of the library used to freeze the code. Note https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: Type Description Union[str, None] The name of the library or None. Source code in mapper\\utils.py def getFreezer () -> Union [ str , None ]: \"\"\" Determines the name of the library used to freeze the code. Note: https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: The name of the library or None. \"\"\" frozen : Union [ str , bool , None ] = getattr ( sys , \"frozen\" , None ) if frozen and hasattr ( sys , \"_MEIPASS\" ): return \"pyinstaller\" elif frozen is True : return \"cx_freeze\" elif frozen in ( \"windows_exe\" , \"console_exe\" , \"dll\" ): return \"py2exe\" elif frozen == \"macosx_app\" : return \"py2app\" elif hasattr ( sys , \"importers\" ): return \"old_py2exe\" elif _imp . is_frozen ( \"__main__\" ): return \"tools/freeze\" elif isinstance ( frozen , str ): return f \"unknown { frozen } \" return None Function getXMLAttributes ( text ) \u00b6 Extracts XML attributes from a tag. The supplied string must only contain attributes, not the tag name. !!! note Adapted from the html.parser module of the Python standard library. Parameters: Name Type Description Default text str The text to be parsed. required Returns: Type Description dict[str, Union[str, None]] The extracted attributes. Source code in mapper\\utils.py def getXMLAttributes ( text : str ) -> dict [ str , Union [ str , None ]]: \"\"\" Extracts XML attributes from a tag. The supplied string must only contain attributes, not the tag name. Note: Adapted from the html.parser module of the Python standard library. Args: text: The text to be parsed. Returns: The extracted attributes. \"\"\" attributes : dict [ str , Union [ str , None ]] = {} for name , rest , value in XML_ATTRIBUTE_REGEX . findall ( text ): if not rest : value = None elif value [: 1 ] == \"'\" == value [ - 1 :] or value [: 1 ] == '\"' == value [ - 1 :]: value = value [ 1 : - 1 ] attributes [ name . lower ()] = value return attributes Function humanSort ( lst ) \u00b6 Sorts a list of strings, with numbers sorted according to their numeric value. Parameters: Name Type Description Default lst Sequence[str] The list of strings to be sorted. required Returns: Type Description list[str] The items of the list, with strings containing numbers sorted according to their numeric value. Source code in mapper\\utils.py def humanSort ( lst : Sequence [ str ]) -> list [ str ]: \"\"\" Sorts a list of strings, with numbers sorted according to their numeric value. Args: lst: The list of strings to be sorted. Returns: The items of the list, with strings containing numbers sorted according to their numeric value. \"\"\" return sorted ( lst , key = lambda item : [ int ( text ) if text . isdigit () else text for text in re . split ( r \"(\\d+)\" , item , re . UNICODE ) ], ) Function isFrozen () \u00b6 Determines whether the program is running from a frozen copy or from source. Returns: Type Description bool True if frozen, False otherwise. Source code in mapper\\utils.py def isFrozen () -> bool : \"\"\" Determines whether the program is running from a frozen copy or from source. Returns: True if frozen, False otherwise. \"\"\" return bool ( getFreezer ()) Function lpadList ( lst , padding , count , fixed = False ) \u00b6 Pad the left side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in mapper\\utils.py def lpadList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the left side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * [ padding ] * ( count - len ( lst )), * lst ][: count ] else : return [ * [ padding ] * ( count - len ( lst )), * lst ] Function minIndent ( text ) \u00b6 Retrieves the indention characters from the line with the least indention. Parameters: Name Type Description Default text str the text to process. required Returns: Type Description str The indention characters of the line with the least amount of indention. Source code in mapper\\utils.py def minIndent ( text : str ) -> str : \"\"\" Retrieves the indention characters from the line with the least indention. Args: text: the text to process. Returns: The indention characters of the line with the least amount of indention. \"\"\" lines = [] for line in text . splitlines (): if line . strip ( \" \\r\\n \" ): match = INDENT_REGEX . search ( line ) if match is not None : lines . append ( match . group ( \"indent\" )) return min ( lines , default = \"\" , key = len ) Function padList ( lst , padding , count , fixed = False ) \u00b6 Pad the right side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in mapper\\utils.py def padList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the right side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * lst , * [ padding ] * ( count - len ( lst ))][: count ] else : return [ * lst , * [ padding ] * ( count - len ( lst ))] Function page ( lines ) \u00b6 Displays lines using the pager if necessary. Parameters: Name Type Description Default lines Sequence[str] The lines to be displayed. required Source code in mapper\\utils.py def page ( lines : Sequence [ str ]) -> None : \"\"\" Displays lines using the pager if necessary. Args: lines: The lines to be displayed. \"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text ) Function regexFuzzy ( text ) \u00b6 Creates a regular expression matching all or part of a string or sequence. Parameters: Name Type Description Default text Union[str, Sequence[str]] The text to be converted. required Returns: Type Description str A regular expression string matching all or part of the text. Source code in mapper\\utils.py def regexFuzzy ( text : Union [ str , Sequence [ str ]]) -> str : \"\"\" Creates a regular expression matching all or part of a string or sequence. Args: text: The text to be converted. Returns: A regular expression string matching all or part of the text. \"\"\" if not isinstance ( text , ( str , Sequence )): raise TypeError ( \"Text must be either a string or sequence of strings.\" ) elif not text : return \"\" elif isinstance ( text , str ): return \"(\" . join ( list ( text )) + \")?\" * ( len ( text ) - 1 ) else : return \"|\" . join ( \"(\" . join ( list ( item )) + \")?\" * ( len ( item ) - 1 ) for item in text ) Function removePrefix ( text , prefix ) \u00b6 Backport of removeprefix from PEP-616 (Python 3.9+) Source code in mapper\\utils.py def removePrefix ( text : BytesOrStr , prefix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removeprefix` from PEP-616 (Python 3.9+)\"\"\" if text . startswith ( prefix ): return text [ len ( prefix ) :] else : return text Function removeSuffix ( text , suffix ) \u00b6 Backport of removesuffix from PEP-616 (Python 3.9+) Source code in mapper\\utils.py def removeSuffix ( text : BytesOrStr , suffix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removesuffix` from PEP-616 (Python 3.9+)\"\"\" if suffix and text . endswith ( suffix ): return text [: - len ( suffix )] else : return text Function roundHalfAwayFromZero ( number , decimals = 0 ) \u00b6 Rounds a float away from 0 if the fractional is 5 or more. Note https://realpython.com/python-rounding Parameters: Name Type Description Default number float The number to round. required decimals int The number of fractional decimal places to round to. 0 Returns: Type Description float The number after rounding. Source code in mapper\\utils.py def roundHalfAwayFromZero ( number : float , decimals : int = 0 ) -> float : \"\"\" Rounds a float away from 0 if the fractional is 5 or more. Note: https://realpython.com/python-rounding Args: number: The number to round. decimals: The number of fractional decimal places to round to. Returns: The number after rounding. \"\"\" multiplier = 10 ** decimals return math . copysign ( math . floor ( abs ( number ) * multiplier + 0.5 ) / multiplier , number ) Function simplified ( text ) \u00b6 Replaces one or more consecutive white space characters with a single space. Parameters: Name Type Description Default text str The text to process. required Returns: Type Description str The simplified version of the text. Source code in mapper\\utils.py def simplified ( text : str ) -> str : \"\"\" Replaces one or more consecutive white space characters with a single space. Args: text: The text to process. Returns: The simplified version of the text. \"\"\" return WHITE_SPACE_REGEX . sub ( \" \" , text ) . strip () Function stripAnsi ( text ) \u00b6 Strips ANSI escape sequences from text. Parameters: Name Type Description Default text str The text to strip ANSI sequences from. required Returns: Type Description str The text with ANSI escape sequences stripped. Source code in mapper\\utils.py def stripAnsi ( text : str ) -> str : \"\"\" Strips ANSI escape sequences from text. Args: text: The text to strip ANSI sequences from. Returns: The text with ANSI escape sequences stripped. \"\"\" return ANSI_COLOR_REGEX . sub ( \"\" , text ) Function touch ( name ) \u00b6 Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Parameters: Name Type Description Default name str the file name to touch. required Source code in mapper\\utils.py def touch ( name : str ) -> None : \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Args: name: the file name to touch. \"\"\" with open ( name , \"a\" ): os . utime ( name , None )","title":"utils.py"},{"location":"api/utils/#mapper.utils","text":"","title":"utils"},{"location":"api/utils/#mapper.utils.ContainerEmptyMixin","text":"A mixin class to be used in unit tests. Source code in mapper\\utils.py class ContainerEmptyMixin : \"\"\" A mixin class to be used in unit tests. \"\"\" assertIsInstance : Callable [ ... , Any ] assertTrue : Callable [ ... , Any ] assertFalse : Callable [ ... , Any ] def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj ) def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj )","title":"ContainerEmptyMixin"},{"location":"api/utils/#mapper.utils.ContainerEmptyMixin.assertContainerEmpty","text":"Asserts whether the given object is an empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in mapper\\utils.py def assertContainerEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is an empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertFalse ( obj )","title":"assertContainerEmpty()"},{"location":"api/utils/#mapper.utils.ContainerEmptyMixin.assertContainerNotEmpty","text":"Asserts whether the given object is a non-empty container. Parameters: Name Type Description Default obj Container[Any] The object to test. required Source code in mapper\\utils.py def assertContainerNotEmpty ( self , obj : Container [ Any ]) -> None : \"\"\" Asserts whether the given object is a non-empty container. Args: obj: The object to test. \"\"\" self . assertIsInstance ( obj , Container ) self . assertTrue ( obj )","title":"assertContainerNotEmpty()"},{"location":"api/utils/#mapper.utils.average","text":"Calculates the average item length of an iterable. Parameters: Name Type Description Default items Iterable[float] The iterable of items. required Returns: Type Description float The average item length. Source code in mapper\\utils.py def average ( items : Iterable [ float ]) -> float : \"\"\" Calculates the average item length of an iterable. Args: items: The iterable of items. Returns: The average item length. \"\"\" try : return statistics . mean ( items ) except statistics . StatisticsError : # No items. return 0","title":"average()"},{"location":"api/utils/#mapper.utils.camelCase","text":"converts text to camel case. Parameters: Name Type Description Default text str The text to be converted. required delimiter str The delimiter between words. required Returns: Type Description str The text in camel case. Source code in mapper\\utils.py def camelCase ( text : str , delimiter : str ) -> str : \"\"\" converts text to camel case. Args: text: The text to be converted. delimiter: The delimiter between words. Returns: The text in camel case. \"\"\" words = text . split ( delimiter ) return \"\" . join (( * map ( str . lower , words [: 1 ]), * map ( str . title , words [ 1 :])))","title":"camelCase()"},{"location":"api/utils/#mapper.utils.clamp","text":"Clamps the given value between the given minimum and maximum values. Parameters: Name Type Description Default value float The value to restrict inside the range defined by minimum and maximum. required minimum float The minimum value to compare against. required maximum float The maximum value to compare against. required Returns: Type Description float The result between minimum and maximum. Source code in mapper\\utils.py def clamp ( value : float , minimum : float , maximum : float ) -> float : \"\"\" Clamps the given value between the given minimum and maximum values. Args: value: The value to restrict inside the range defined by minimum and maximum. minimum: The minimum value to compare against. maximum: The maximum value to compare against. Returns: The result between minimum and maximum. \"\"\" return minimum if value < minimum else maximum if value > maximum else value","title":"clamp()"},{"location":"api/utils/#mapper.utils.decodeBytes","text":"Decodes bytes into a string. If data contains Latin-1 characters, they will be replaced with ASCII equivalents. Parameters: Name Type Description Default data bytes The data to be decoded. required Returns: Type Description str The decoded string. Source code in mapper\\utils.py def decodeBytes ( data : bytes ) -> str : \"\"\" Decodes bytes into a string. If data contains Latin-1 characters, they will be replaced with ASCII equivalents. Args: data: The data to be decoded. Returns: The decoded string. \"\"\" if not isinstance ( data , ( bytes , bytearray )): raise TypeError ( \"Data must be a bytes-like object.\" ) with suppress ( UnicodeDecodeError ): return str ( data , \"us-ascii\" ) try : # If UTF-8, re-encode the data before decoding because of multi-byte code points. return data . decode ( \"utf-8\" ) . encode ( \"us-ascii\" , \"latin2ascii\" ) . decode ( \"us-ascii\" ) except UnicodeDecodeError : # Assume data is Latin-1. return str ( data , \"us-ascii\" , \"latin2ascii\" )","title":"decodeBytes()"},{"location":"api/utils/#mapper.utils.formatDocString","text":"Formats a docstring for displaying. Parameters: Name Type Description Default functionOrString Union[str, Callable[..., Any]] The function containing the docstring, or the docstring its self. required width int The number of characters to word wrap each line to. 79 prefix Optional[str] One or more characters to use for indention. None Returns: Type Description str The formatted docstring. Source code in mapper\\utils.py def formatDocString ( functionOrString : Union [ str , Callable [ ... , Any ]], width : int = 79 , prefix : Optional [ str ] = None ) -> str : \"\"\" Formats a docstring for displaying. Args: functionOrString: The function containing the docstring, or the docstring its self. width: The number of characters to word wrap each line to. prefix: One or more characters to use for indention. Returns: The formatted docstring. \"\"\" if callable ( functionOrString ): # It's a function. docString = getattr ( functionOrString , \"__doc__\" ) or \"\" else : # It's a string. docString = functionOrString # Remove any empty lines from the beginning, while keeping indention. docString = docString . lstrip ( \" \\r\\n \" ) match = INDENT_REGEX . search ( docString ) if match is not None and not match . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): match = INDENT_REGEX . search ( line ) if match is None : # pragma: no cover continue indent , text = match . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix if prefix is not None else \"\" ) # Indent docstring lines with the prefix. return docString","title":"formatDocString()"},{"location":"api/utils/#mapper.utils.getDataPath","text":"Retrieves the path of the data directory. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the data path. () Returns: Type Description str The path. Source code in mapper\\utils.py def getDataPath ( * args : str ) -> str : \"\"\" Retrieves the path of the data directory. Args: *args: Positional arguments to be passed to os.join after the data path. Returns: The path. \"\"\" return os . path . realpath ( os . path . join ( getDirectoryPath ( DATA_DIRECTORY ), * args ))","title":"getDataPath()"},{"location":"api/utils/#mapper.utils.getDirectoryPath","text":"Retrieves the path of the directory where the program is located. Parameters: Name Type Description Default *args str Positional arguments to be passed to os.join after the directory path. () Returns: Type Description str The path. Source code in mapper\\utils.py def getDirectoryPath ( * args : str ) -> str : \"\"\" Retrieves the path of the directory where the program is located. Args: *args: Positional arguments to be passed to os.join after the directory path. Returns: The path. \"\"\" if isFrozen (): path = os . path . dirname ( sys . executable ) else : path = os . path . join ( os . path . dirname ( __file__ ), os . path . pardir ) return os . path . realpath ( os . path . join ( path , * args ))","title":"getDirectoryPath()"},{"location":"api/utils/#mapper.utils.getFreezer","text":"Determines the name of the library used to freeze the code. Note https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: Type Description Union[str, None] The name of the library or None. Source code in mapper\\utils.py def getFreezer () -> Union [ str , None ]: \"\"\" Determines the name of the library used to freeze the code. Note: https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py Returns: The name of the library or None. \"\"\" frozen : Union [ str , bool , None ] = getattr ( sys , \"frozen\" , None ) if frozen and hasattr ( sys , \"_MEIPASS\" ): return \"pyinstaller\" elif frozen is True : return \"cx_freeze\" elif frozen in ( \"windows_exe\" , \"console_exe\" , \"dll\" ): return \"py2exe\" elif frozen == \"macosx_app\" : return \"py2app\" elif hasattr ( sys , \"importers\" ): return \"old_py2exe\" elif _imp . is_frozen ( \"__main__\" ): return \"tools/freeze\" elif isinstance ( frozen , str ): return f \"unknown { frozen } \" return None","title":"getFreezer()"},{"location":"api/utils/#mapper.utils.getXMLAttributes","text":"Extracts XML attributes from a tag. The supplied string must only contain attributes, not the tag name. !!! note Adapted from the html.parser module of the Python standard library. Parameters: Name Type Description Default text str The text to be parsed. required Returns: Type Description dict[str, Union[str, None]] The extracted attributes. Source code in mapper\\utils.py def getXMLAttributes ( text : str ) -> dict [ str , Union [ str , None ]]: \"\"\" Extracts XML attributes from a tag. The supplied string must only contain attributes, not the tag name. Note: Adapted from the html.parser module of the Python standard library. Args: text: The text to be parsed. Returns: The extracted attributes. \"\"\" attributes : dict [ str , Union [ str , None ]] = {} for name , rest , value in XML_ATTRIBUTE_REGEX . findall ( text ): if not rest : value = None elif value [: 1 ] == \"'\" == value [ - 1 :] or value [: 1 ] == '\"' == value [ - 1 :]: value = value [ 1 : - 1 ] attributes [ name . lower ()] = value return attributes","title":"getXMLAttributes()"},{"location":"api/utils/#mapper.utils.humanSort","text":"Sorts a list of strings, with numbers sorted according to their numeric value. Parameters: Name Type Description Default lst Sequence[str] The list of strings to be sorted. required Returns: Type Description list[str] The items of the list, with strings containing numbers sorted according to their numeric value. Source code in mapper\\utils.py def humanSort ( lst : Sequence [ str ]) -> list [ str ]: \"\"\" Sorts a list of strings, with numbers sorted according to their numeric value. Args: lst: The list of strings to be sorted. Returns: The items of the list, with strings containing numbers sorted according to their numeric value. \"\"\" return sorted ( lst , key = lambda item : [ int ( text ) if text . isdigit () else text for text in re . split ( r \"(\\d+)\" , item , re . UNICODE ) ], )","title":"humanSort()"},{"location":"api/utils/#mapper.utils.isFrozen","text":"Determines whether the program is running from a frozen copy or from source. Returns: Type Description bool True if frozen, False otherwise. Source code in mapper\\utils.py def isFrozen () -> bool : \"\"\" Determines whether the program is running from a frozen copy or from source. Returns: True if frozen, False otherwise. \"\"\" return bool ( getFreezer ())","title":"isFrozen()"},{"location":"api/utils/#mapper.utils.lpadList","text":"Pad the left side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in mapper\\utils.py def lpadList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the left side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * [ padding ] * ( count - len ( lst )), * lst ][: count ] else : return [ * [ padding ] * ( count - len ( lst )), * lst ]","title":"lpadList()"},{"location":"api/utils/#mapper.utils.minIndent","text":"Retrieves the indention characters from the line with the least indention. Parameters: Name Type Description Default text str the text to process. required Returns: Type Description str The indention characters of the line with the least amount of indention. Source code in mapper\\utils.py def minIndent ( text : str ) -> str : \"\"\" Retrieves the indention characters from the line with the least indention. Args: text: the text to process. Returns: The indention characters of the line with the least amount of indention. \"\"\" lines = [] for line in text . splitlines (): if line . strip ( \" \\r\\n \" ): match = INDENT_REGEX . search ( line ) if match is not None : lines . append ( match . group ( \"indent\" )) return min ( lines , default = \"\" , key = len )","title":"minIndent()"},{"location":"api/utils/#mapper.utils.padList","text":"Pad the right side of a list. Parameters: Name Type Description Default lst Sequence[Any] The list to be padded. required padding Any The item to use for padding. required count int The minimum size of the returned list. required fixed bool True if the maximum size of the returned list should be restricted to count, False otherwise. False Returns: Type Description list[Any] A padded copy of the list. Source code in mapper\\utils.py def padList ( lst : Sequence [ Any ], padding : Any , count : int , fixed : bool = False ) -> list [ Any ]: \"\"\" Pad the right side of a list. Args: lst: The list to be padded. padding: The item to use for padding. count: The minimum size of the returned list. fixed: True if the maximum size of the returned list should be restricted to count, False otherwise. Returns: A padded copy of the list. \"\"\" if fixed : return [ * lst , * [ padding ] * ( count - len ( lst ))][: count ] else : return [ * lst , * [ padding ] * ( count - len ( lst ))]","title":"padList()"},{"location":"api/utils/#mapper.utils.page","text":"Displays lines using the pager if necessary. Parameters: Name Type Description Default lines Sequence[str] The lines to be displayed. required Source code in mapper\\utils.py def page ( lines : Sequence [ str ]) -> None : \"\"\" Displays lines using the pager if necessary. Args: lines: The lines to be displayed. \"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text )","title":"page()"},{"location":"api/utils/#mapper.utils.regexFuzzy","text":"Creates a regular expression matching all or part of a string or sequence. Parameters: Name Type Description Default text Union[str, Sequence[str]] The text to be converted. required Returns: Type Description str A regular expression string matching all or part of the text. Source code in mapper\\utils.py def regexFuzzy ( text : Union [ str , Sequence [ str ]]) -> str : \"\"\" Creates a regular expression matching all or part of a string or sequence. Args: text: The text to be converted. Returns: A regular expression string matching all or part of the text. \"\"\" if not isinstance ( text , ( str , Sequence )): raise TypeError ( \"Text must be either a string or sequence of strings.\" ) elif not text : return \"\" elif isinstance ( text , str ): return \"(\" . join ( list ( text )) + \")?\" * ( len ( text ) - 1 ) else : return \"|\" . join ( \"(\" . join ( list ( item )) + \")?\" * ( len ( item ) - 1 ) for item in text )","title":"regexFuzzy()"},{"location":"api/utils/#mapper.utils.removePrefix","text":"Backport of removeprefix from PEP-616 (Python 3.9+) Source code in mapper\\utils.py def removePrefix ( text : BytesOrStr , prefix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removeprefix` from PEP-616 (Python 3.9+)\"\"\" if text . startswith ( prefix ): return text [ len ( prefix ) :] else : return text","title":"removePrefix()"},{"location":"api/utils/#mapper.utils.removeSuffix","text":"Backport of removesuffix from PEP-616 (Python 3.9+) Source code in mapper\\utils.py def removeSuffix ( text : BytesOrStr , suffix : BytesOrStr ) -> BytesOrStr : \"\"\"Backport of `removesuffix` from PEP-616 (Python 3.9+)\"\"\" if suffix and text . endswith ( suffix ): return text [: - len ( suffix )] else : return text","title":"removeSuffix()"},{"location":"api/utils/#mapper.utils.roundHalfAwayFromZero","text":"Rounds a float away from 0 if the fractional is 5 or more. Note https://realpython.com/python-rounding Parameters: Name Type Description Default number float The number to round. required decimals int The number of fractional decimal places to round to. 0 Returns: Type Description float The number after rounding. Source code in mapper\\utils.py def roundHalfAwayFromZero ( number : float , decimals : int = 0 ) -> float : \"\"\" Rounds a float away from 0 if the fractional is 5 or more. Note: https://realpython.com/python-rounding Args: number: The number to round. decimals: The number of fractional decimal places to round to. Returns: The number after rounding. \"\"\" multiplier = 10 ** decimals return math . copysign ( math . floor ( abs ( number ) * multiplier + 0.5 ) / multiplier , number )","title":"roundHalfAwayFromZero()"},{"location":"api/utils/#mapper.utils.simplified","text":"Replaces one or more consecutive white space characters with a single space. Parameters: Name Type Description Default text str The text to process. required Returns: Type Description str The simplified version of the text. Source code in mapper\\utils.py def simplified ( text : str ) -> str : \"\"\" Replaces one or more consecutive white space characters with a single space. Args: text: The text to process. Returns: The simplified version of the text. \"\"\" return WHITE_SPACE_REGEX . sub ( \" \" , text ) . strip ()","title":"simplified()"},{"location":"api/utils/#mapper.utils.stripAnsi","text":"Strips ANSI escape sequences from text. Parameters: Name Type Description Default text str The text to strip ANSI sequences from. required Returns: Type Description str The text with ANSI escape sequences stripped. Source code in mapper\\utils.py def stripAnsi ( text : str ) -> str : \"\"\" Strips ANSI escape sequences from text. Args: text: The text to strip ANSI sequences from. Returns: The text with ANSI escape sequences stripped. \"\"\" return ANSI_COLOR_REGEX . sub ( \"\" , text )","title":"stripAnsi()"},{"location":"api/utils/#mapper.utils.touch","text":"Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Parameters: Name Type Description Default name str the file name to touch. required Source code in mapper\\utils.py def touch ( name : str ) -> None : \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Args: name: the file name to touch. \"\"\" with open ( name , \"a\" ): os . utime ( name , None )","title":"touch()"},{"location":"api/world/","text":"Module mapper.world \u00b6 Class World \u00b6 Source code in mapper\\world.py class World ( object ): def __init__ ( self , interface : str = \"text\" ) -> None : self . roomsLock = threading . Lock () self . isSynced : bool = False self . rooms : dict [ str , Room ] = {} self . labels : dict [ str , str ] = {} self . _interface : str = interface if interface != \"text\" : self . _gui_queue : GUI_QUEUE_TYPE = SimpleQueue () self . window : pyglet . window . Window # type: ignore[no-any-unimported] if interface == \"hc\" : from .gui import hc self . window = hc . Window ( self ) elif interface == \"sighted\" : from .gui import sighted self . window = sighted . Window ( self ) self . _currentRoom : Room = Room () self . loadRooms () self . loadLabels () @property def currentRoom ( self ) -> Room : return self . _currentRoom @currentRoom . setter def currentRoom ( self , value : Room ) -> None : self . _currentRoom = value if self . _interface != \"text\" : self . _gui_queue . put (( \"on_mapSync\" , value )) @currentRoom . deleter def currentRoom ( self ) -> None : self . _currentRoom = Room () def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_guiRefresh\" ,)) def output ( self , text : str ) -> None : print ( text ) def loadRoomsV0 ( self , db : dict [ str , dict [ str , Any ]]) -> None : terrainReplacements : dict [ str , str ] = { \"indoors\" : \"building\" , \"random\" : \"undefined\" , \"shallow\" : \"shallows\" , \"shallowwater\" : \"shallows\" , } loadFlagReplacements : dict [ str , str ] = { \"packhorse\" : \"pack_horse\" , \"trainedhorse\" : \"trained_horse\" , } mobFlagReplacements : dict [ str , str ] = { \"any\" : \"passive_mob\" , \"smob\" : \"aggressive_mob\" , \"quest\" : \"quest_mob\" , \"scoutguild\" : \"scout_guild\" , \"mageguild\" : \"mage_guild\" , \"clericguild\" : \"cleric_guild\" , \"warriorguild\" : \"warrior_guild\" , \"rangerguild\" : \"ranger_guild\" , \"armourshop\" : \"armour_shop\" , \"foodshop\" : \"food_shop\" , \"petshop\" : \"pet_shop\" , \"weaponshop\" : \"weapon_shop\" , } doorFlagReplacements : dict [ str , str ] = { \"noblock\" : \"no_block\" , \"nobreak\" : \"no_break\" , \"nopick\" : \"no_pick\" , \"needkey\" : \"need_key\" , } portableReplacements : dict [ str , str ] = { \"notportable\" : \"not_portable\" , } ridableReplacements : dict [ str , str ] = { \"notridable\" : \"not_ridable\" , } for vnum , roomDict in db . items (): if not vnum . isdigit (): # This should never happen, but safe to ignore if it does. # Todo: add a warning to alert the user here. continue elif roomDict [ \"terrain\" ] . startswith ( \"death\" ): # handles \"death\" and \"deathtrap\". # This should never happen, but safe to ignore if it does. # Todo: add a warning to alert the user here. continue newRoom : Room = Room () newRoom . vnum = vnum newRoom . align = roomDict [ \"align\" ] with suppress ( KeyError ): newRoom . avoid = roomDict [ \"avoid\" ] newRoom . desc = roomDict [ \"desc\" ] newRoom . dynamicDesc = roomDict [ \"dynamicDesc\" ] . lstrip () for direction , exitDict in roomDict [ \"exits\" ] . items (): newExit : Exit = self . getNewExit ( direction , exitDict [ \"to\" ], vnum ) newExit . door = exitDict [ \"door\" ] newExit . doorFlags = { doorFlagReplacements . get ( flag , flag ) for flag in exitDict [ \"doorFlags\" ]} newExit . exitFlags = set ( exitDict [ \"exitFlags\" ]) newRoom . exits [ direction ] = newExit exitDict . clear () newRoom . light = roomDict [ \"light\" ] newRoom . loadFlags = { loadFlagReplacements . get ( flag , flag ) for flag in roomDict [ \"loadFlags\" ]} newRoom . mobFlags = { mobFlagReplacements . get ( flag , flag ) for flag in roomDict [ \"mobFlags\" ]} newRoom . name = roomDict [ \"name\" ] newRoom . note = roomDict [ \"note\" ] portable : str = roomDict [ \"portable\" ] newRoom . portable = portableReplacements . get ( portable , portable ) ridable : str = roomDict [ \"ridable\" ] newRoom . ridable = ridableReplacements . get ( ridable , ridable ) with suppress ( KeyError ): newRoom . sundeath = roomDict [ \"sundeath\" ] terrain : str = roomDict [ \"terrain\" ] newRoom . terrain = terrainReplacements . get ( terrain , terrain ) newRoom . x = roomDict [ \"x\" ] newRoom . y = roomDict [ \"y\" ] newRoom . z = roomDict [ \"z\" ] newRoom . calculateCost () self . rooms [ vnum ] = newRoom roomDict . clear () def loadRoomsV1Through2 ( self , db : dict [ str , dict [ str , Any ]], schemaVersion : int ) -> None : for vnum , roomDict in db . items (): newRoom : Room = Room () newRoom . vnum = vnum newRoom . align = roomDict [ \"alignment\" ] newRoom . avoid = roomDict [ \"avoid\" ] newRoom . desc = roomDict [ \"description\" ] newRoom . dynamicDesc = roomDict [ \"contents\" ] . lstrip () for direction , exitDict in roomDict [ \"exits\" ] . items (): newExit : Exit = self . getNewExit ( direction , exitDict [ \"to\" ], vnum ) newExit . door = exitDict [ \"door\" ] newExit . doorFlags = set ( exitDict [ \"door_flags\" ]) newExit . exitFlags = set ( exitDict [ \"exit_flags\" ]) newRoom . exits [ direction ] = newExit exitDict . clear () newRoom . light = roomDict [ \"light\" ] newRoom . loadFlags = set ( roomDict [ \"load_flags\" ]) newRoom . mobFlags = set ( roomDict [ \"mob_flags\" ]) newRoom . name = roomDict [ \"name\" ] newRoom . note = roomDict [ \"note\" ] newRoom . portable = roomDict [ \"portable\" ] newRoom . ridable = roomDict [ \"ridable\" ] newRoom . sundeath = roomDict [ \"sundeath\" ] newRoom . terrain = roomDict [ \"terrain\" ] newRoom . coordinates = roomDict [ \"coordinates\" ] if schemaVersion >= 2 : newRoom . area = roomDict [ \"area\" ] newRoom . serverID = roomDict [ \"server_id\" ] newRoom . calculateCost () self . rooms [ vnum ] = newRoom roomDict . clear () def loadRooms ( self ) -> None : startTime : float = defaultTimer () if gc . isenabled (): gc . disable () self . output ( \"Loading the database file.\" ) errors : Union [ str , None ] db : Union [ dict [ str , dict [ str , Any ]], None ] errors , db , schemaVersion = loadRooms () if db is None : if errors is not None : self . output ( errors ) return None schemaVersionOutput : str = \"latest\" if schemaVersion == MAP_SCHEMA_VERSION else f \"V { schemaVersion } \" self . output ( f \"Creating room objects with { schemaVersionOutput } schema.\" ) with self . roomsLock : if schemaVersion < 1 : self . loadRoomsV0 ( db ) else : self . loadRoomsV1Through2 ( db , schemaVersion ) db . clear () self . currentRoom = self . rooms [ \"0\" ] if not gc . isenabled (): gc . enable () gc . collect () elapsedTime : float = defaultTimer () - startTime self . output ( f \"Map database loaded in { elapsedTime : .1f } seconds.\" ) def saveRooms ( self ) -> None : startTime : float = defaultTimer () if gc . isenabled (): gc . disable () self . output ( \"Creating dict from room objects.\" ) db : dict [ str , dict [ str , Any ]] = {} with self . roomsLock : for vnum , roomObj in self . rooms . items (): newRoom : dict [ str , Any ] = {} newRoom [ \"alignment\" ] = roomObj . align newRoom [ \"area\" ] = roomObj . area newRoom [ \"avoid\" ] = roomObj . avoid newRoom [ \"contents\" ] = roomObj . dynamicDesc newRoom [ \"coordinates\" ] = roomObj . coordinates newRoom [ \"description\" ] = roomObj . desc newRoom [ \"exits\" ] = {} for direction , exitObj in roomObj . exits . items (): newExit : dict [ str , Any ] = {} newExit [ \"door\" ] = exitObj . door newExit [ \"door_flags\" ] = sorted ( exitObj . doorFlags ) newExit [ \"exit_flags\" ] = sorted ( exitObj . exitFlags ) newExit [ \"to\" ] = exitObj . to newRoom [ \"exits\" ][ direction ] = newExit newRoom [ \"light\" ] = roomObj . light newRoom [ \"load_flags\" ] = sorted ( roomObj . loadFlags ) newRoom [ \"mob_flags\" ] = sorted ( roomObj . mobFlags ) newRoom [ \"name\" ] = roomObj . name newRoom [ \"note\" ] = roomObj . note newRoom [ \"portable\" ] = roomObj . portable newRoom [ \"ridable\" ] = roomObj . ridable newRoom [ \"server_id\" ] = roomObj . serverID newRoom [ \"sundeath\" ] = roomObj . sundeath newRoom [ \"terrain\" ] = roomObj . terrain db [ vnum ] = newRoom self . output ( \"Saving the database.\" ) dumpRooms ( db ) if not gc . isenabled (): gc . enable () gc . collect () elapsedTime : float = defaultTimer () - startTime self . output ( f \"Map Database saved in { elapsedTime : .1f } seconds.\" ) def loadLabels ( self ) -> None : errors : Union [ str , None ] labels : Union [ dict [ str , str ], None ] schemaVersion : int errors , labels , schemaVersion = loadLabels () if labels is None : if errors is not None : self . output ( errors ) return None self . labels . update ( labels ) schemaVersionOutput : str = \"latest\" if schemaVersion == LABELS_SCHEMA_VERSION else f \"V { schemaVersion } \" self . output ( f \"Loaded room labels with { schemaVersionOutput } schema.\" ) orphans : list [ str ] = [ label for label , vnum in self . labels . items () if vnum not in self . rooms ] if orphans : for label in orphans : del self . labels [ label ] self . output ( f \"Detected orphan labels: { ', ' . join ( orphans ) } \" ) self . output ( f \" { len ( orphans ) } orphan labels removed.\" ) def saveLabels ( self ) -> None : dumpLabels ( self . labels ) def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) def getVnum ( self , roomObj : Room ) -> Union [ str , None ]: result : Union [ str , None ] = None for vnum , obj in self . rooms . items (): if obj is roomObj : result = vnum break return result def coordinatesSubtract ( self , first : Sequence [ int ], second : Sequence [ int ]) -> tuple [ int , ... ]: return tuple ( a - b for a , b in zip ( first , second )) def coordinatesAdd ( self , first : Sequence [ int ], second : Sequence [ int ]) -> tuple [ int , ... ]: return tuple ( a + b for a , b in zip ( first , second )) def coordinatesAddDirection ( self , coordinates : Sequence [ int ], direction : str ) -> tuple [ int , ... ]: if direction not in DIRECTIONS : raise ValueError ( f \"Direction must be one of { DIRECTIONS } .\" ) return self . coordinatesAdd ( coordinates , DIRECTION_COORDINATES [ direction ]) def getNewVnum ( self ) -> str : return str ( max ( int ( i ) for i in self . rooms ) + 1 ) def revnum ( self , text : str = \"\" ) -> None : text = text . strip () . lower () match : REGEX_MATCH = re . match ( r \"^(?:(?P<origin>\\d+)\\s+)?(?:\\s*(?P<destination>\\d+)\\s*)$\" , text ) if match is None : self . output ( \"Syntax: 'revnum [Origin VNum] [Destination VNum]'.\" ) return None matchDict : dict [ str , str ] = match . groupdict () if not matchDict [ \"destination\" ]: self . output ( \"Error: you need to supply a destination VNum.\" ) return None destination = matchDict [ \"destination\" ] if not matchDict [ \"origin\" ]: origin = self . currentRoom . vnum self . output ( f \"Changing the VNum of the current room to ' { destination } '.\" ) else : origin = matchDict [ \"origin\" ] self . output ( f \"Changing the Vnum ' { origin } ' to ' { destination } '.\" ) for roomVnum , roomObj in self . rooms . items (): for direction , exitObj in roomObj . exits . items (): if roomVnum == origin : exitObj . vnum = destination if exitObj . to == origin : self . rooms [ roomVnum ] . exits [ direction ] . to = destination self . rooms [ origin ] . vnum = destination self . rooms [ destination ] = self . rooms [ origin ] del self . rooms [ origin ] def rdelete ( self , text : str ) -> str : text = text . strip () . lower () vnum : str if text . isdigit (): vnum = text if self . currentRoom . vnum == vnum : self . isSynced = False self . currentRoom = self . rooms . get ( \"0\" , Room ()) elif vnum not in self . rooms : return f \"Error: the vnum ' { vnum } ' does not exist.\" elif self . isSynced : vnum = self . currentRoom . vnum self . isSynced = False self . currentRoom = self . rooms . get ( \"0\" , Room ()) else : return \"Syntax: rdelete [vnum]\" output = f \"Deleting room ' { vnum } ' with name ' { self . rooms [ vnum ] . name } '.\" with self . roomsLock : for roomVnum , roomObj in self . rooms . items (): for direction , exitObj in roomObj . exits . items (): if exitObj . to == vnum : self . rooms [ roomVnum ] . exits [ direction ] . to = \"undefined\" del self . rooms [ vnum ] self . GUIRefresh () return output def searchRooms ( self , exactMatch : bool = False , ** kwargs : str ) -> list [ Room ]: validArgs : tuple [ str , ... ] = ( \"area\" , \"serverID\" , \"name\" , \"desc\" , \"dynamicDesc\" , \"note\" , \"terrain\" , \"light\" , \"align\" , \"portable\" , \"ridable\" , \"sundeath\" , \"x\" , \"y\" , \"z\" , \"mobFlags\" , \"loadFlags\" , \"exitFlags\" , \"doorFlags\" , \"to\" , \"door\" , ) observeExactMatch : tuple [ str , ... ] = ( \"area\" , \"name\" , \"desc\" , \"dynamicDesc\" , \"note\" ) alwaysExactMatch : tuple [ str , ... ] = ( \"serverID\" , \"terrain\" , \"light\" , \"align\" , \"portable\" , \"ridable\" , \"sundeath\" , \"x\" , \"y\" , \"z\" , ) kwargs = { key : value . strip () . lower () for key , value in kwargs . items () if key . strip () in validArgs and value . strip () } results : list [ Room ] = [] if not kwargs : return results for vnum , roomObj in self . rooms . items (): keysMatched = 0 for key , value in kwargs . items (): if key in observeExactMatch : roomData = getattr ( roomObj , key ) . strip () . lower () if not exactMatch and value in roomData or roomData == value : keysMatched += 1 elif key in alwaysExactMatch and getattr ( roomObj , key ) . strip () . lower () == value : keysMatched += 1 elif key in ( \"mobFlags\" , \"loadFlags\" ) and getattr ( roomObj , key , set ()) . intersection ( value ): keysMatched += 1 else : for direction , exitObj in roomObj . exits . items (): if key in ( \"exitFlags\" , \"doorFlags\" ) and getattr ( exitObj , key , set ()) . intersection ( value ): keysMatched += 1 elif key in ( \"to\" , \"door\" ) and getattr ( exitObj , key , \"\" ) . strip () . lower () == value : keysMatched += 1 if len ( kwargs ) == keysMatched : results . append ( roomObj ) return results def fdoor ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fdoor [text]'.\" results : list [ Room ] = self . searchRooms ( door = text ) if not results : return \"Nothing found.\" currentRoom : Room = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = \", \" . join ( exitDir + \": \" + exitObj . door for exitDir , exitObj in roomObj . exits . items () if text . strip () in exitObj . door ), direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def fdynamic ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fdynamic [text]'.\" results : list [ Room ] = self . searchRooms ( dynamicDesc = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . dynamicDesc , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def flabel ( self , findFormat : str , text : str = \"\" ) -> str : if not self . labels : return \"No labels defined.\" text = text . strip () . lower () results : set [ Room ] = { self . rooms [ vnum ] for label , vnum in self . labels . items () if text and text in label . strip () . lower () or not text } if not results : return \"Nothing found.\" currentRoom = self . currentRoom return \" \\n \" . join ( findFormat . format ( attribute = self . getlabel ( roomObj . vnum ), direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( sorted ( results , key = lambda r : r . manhattanDistance ( currentRoom ))[: 20 ]) ) def fname ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fname [text]'.\" results : list [ Room ] = self . searchRooms ( name = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = \"\" if \" {name} \" in findFormat and \" {attribute} \" in findFormat else roomObj . name , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def fnote ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fnote [text]'.\" results : list [ Room ] = self . searchRooms ( note = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . note , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def farea ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'farea [text]'.\" results : list [ Room ] = self . searchRooms ( area = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . area , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def fsid ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip () . isdigit (): return \"Usage: 'fsid [number]'.\" results : list [ Room ] = self . searchRooms ( serverID = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . serverID , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def rnote ( self , text : str = \"\" ) -> str : text = text . strip () if not text : return ( f \"Room note set to ' { self . currentRoom . note } '. Use 'rnote [text]' to change it, \" + \"'rnote -a [text]' to append to it, or 'rnote -r' to remove it.\" ) if text . lower () . startswith ( \"-r\" ): if len ( text ) > 2 : return \"Error: '-r' requires no extra arguments. Change aborted.\" self . currentRoom . note = \"\" return \"Note removed.\" elif text . lower () . startswith ( \"-a\" ): if len ( text ) == 2 : return \"Error: '-a' requires text to be appended. Change aborted.\" self . currentRoom . note = f \" { self . currentRoom . note . strip () } { text [ 2 :] . strip () } \" else : self . currentRoom . note = text return f \"Room note now set to ' { self . currentRoom . note } '.\" def ralign ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"good\" , \"neutral\" , \"evil\" , \"undefined\" ) if text not in validValues : return ( f \"Room alignment set to ' { self . currentRoom . align } '. \" + f \"Use 'ralign [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . align = text return f \"Setting room align to ' { self . currentRoom . align } '.\" def rlight ( self , text : str = \"\" ) -> str : text = text . strip () if not text : return ( f \"Room light set to ' { self . currentRoom . light } '. \" + f \"Use 'rlight [ { ' | ' . join ( set ( LIGHT_SYMBOLS . values ())) } ]' to change it.\" ) elif text not in LIGHT_SYMBOLS and text . lower () not in LIGHT_SYMBOLS . values (): return ( f \"Invalid value for room light ( { text } ). \" + f \"Valid values are [ { ' | ' . join ( set ( LIGHT_SYMBOLS . values ())) } ].\" ) try : self . currentRoom . light = LIGHT_SYMBOLS [ text ] except KeyError : self . currentRoom . light = text . lower () return f \"Setting room light to ' { self . currentRoom . light } '.\" def rportable ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"portable\" , \"not_portable\" , \"undefined\" ) if text not in validValues : return ( f \"Room portable set to ' { self . currentRoom . portable } '. \" + f \"Use 'rportable [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . portable = text return f \"Setting room portable to ' { self . currentRoom . portable } '.\" def rridable ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"ridable\" , \"not_ridable\" , \"undefined\" , ) if text not in validValues : return ( f \"Room ridable set to ' { self . currentRoom . ridable } '. \" + f \"Use 'rridable [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . ridable = text self . currentRoom . calculateCost () return f \"Setting room ridable to ' { self . currentRoom . ridable } '.\" def rsundeath ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"sundeath\" , \"no_sundeath\" , \"undefined\" ) if text not in validValues : return ( f \"Room sundeath set to ' { self . currentRoom . sundeath } '. \" + f \"Use 'rsundeath [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . sundeath = text return f \"Setting room sundeath to ' { self . currentRoom . sundeath } '.\" def ravoid ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"+\" , \"-\" ) if text not in validValues : return ( f \"Room avoid { 'enabled' if self . currentRoom . avoid else 'disabled' } . \" + f \"Use 'ravoid [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . avoid = text == \"+\" self . currentRoom . calculateCost () return f \" { 'Enabling' if self . currentRoom . avoid else 'Disabling' } room avoid.\" def rterrain ( self , text : str = \"\" ) -> str : text = text . strip () if not text : return ( f \"Room terrain set to ' { self . currentRoom . terrain } '. \" + f \"Use 'rterrain [ { ' | ' . join ( sorted ( TERRAIN_SYMBOLS . values ())) } ]' to change it.\" ) elif text not in TERRAIN_SYMBOLS and text . lower () not in TERRAIN_SYMBOLS . values (): return ( f \"Invalid value for room terrain ( { text } ). \" + f \"Valid values are [ { ' | ' . join ( sorted ( TERRAIN_SYMBOLS . values ())) } ].\" ) try : self . currentRoom . terrain = TERRAIN_SYMBOLS [ text ] except KeyError : self . currentRoom . terrain = text . lower () self . currentRoom . calculateCost () self . GUIRefresh () return f \"Setting room terrain to ' { self . currentRoom . terrain } '.\" def rx ( self , text : str = \"\" ) -> str : text = text . strip () . lower () if not text : return f \"Room coordinate X set to ' { self . currentRoom . x } '. Use 'rx [digit]' to change it.\" try : self . currentRoom . x = int ( text ) self . GUIRefresh () return f \"Setting room X coordinate to ' { self . currentRoom . x } '.\" except ValueError : return \"Error: room coordinates must be comprised of digits only.\" def ry ( self , text : str = \"\" ) -> str : text = text . strip () . lower () if not text : return f \"Room coordinate Y set to ' { self . currentRoom . y } '. Use 'ry [digit]' to change it.\" try : self . currentRoom . y = int ( text ) self . GUIRefresh () return f \"Setting room Y coordinate to ' { self . currentRoom . y } '.\" except ValueError : return \"Error: room coordinates must be comprised of digits only.\" def rz ( self , text : str = \"\" ) -> str : text = text . strip () . lower () if not text : return f \"Room coordinate Z set to ' { self . currentRoom . z } '. Use 'rz [digit]' to change it.\" try : self . currentRoom . z = int ( text ) self . GUIRefresh () return f \"Setting room Z coordinate to ' { self . currentRoom . z } '.\" except ValueError : return \"Error: room coordinates must be comprised of digits only.\" def rmobflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^(?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\" + rf \"\\s+(?P<flag> { '|' . join ( VALID_MOB_FLAGS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () if \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . mobFlags : self . currentRoom . mobFlags . remove ( matchDict [ \"flag\" ]) return f \"Mob flag ' { matchDict [ 'flag' ] } ' removed.\" else : return f \"Mob flag ' { matchDict [ 'flag' ] } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . mobFlags : return f \"Mob flag ' { matchDict [ 'flag' ] } ' already set.\" else : self . currentRoom . mobFlags . add ( matchDict [ \"flag\" ]) return f \"Mob flag ' { matchDict [ 'flag' ] } ' added.\" return ( f \"Mob flags set to ' { ', ' . join ( self . currentRoom . mobFlags ) } '. \" + f \"Use 'rmobflags [add | remove] [ { ' | ' . join ( VALID_MOB_FLAGS ) } ]' to change them.\" ) def rloadflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^(?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\" + rf \"\\s+(?P<flag> { '|' . join ( VALID_LOAD_FLAGS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () if \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . loadFlags : self . currentRoom . loadFlags . remove ( matchDict [ \"flag\" ]) return f \"Load flag ' { matchDict [ 'flag' ] } ' removed.\" else : return f \"Load flag ' { matchDict [ 'flag' ] } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . loadFlags : return f \"Load flag ' { matchDict [ 'flag' ] } ' already set.\" else : self . currentRoom . loadFlags . add ( matchDict [ \"flag\" ]) return f \"Load flag ' { matchDict [ 'flag' ] } ' added.\" return ( f \"Load flags set to ' { ', ' . join ( self . currentRoom . loadFlags ) } '. \" + f \"Use 'rloadflags [add | remove] [ { ' | ' . join ( VALID_LOAD_FLAGS ) } ]' to change them.\" ) def exitflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<flag> { '|' . join ( VALID_EXIT_FLAGS ) } )\\s+)?(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not matchDict [ \"mode\" ]: return ( f \"Exit flags ' { direction } ' set to ' { ', ' . join ( self . currentRoom . exits [ direction ] . exitFlags ) } '.\" ) elif \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . exitFlags : self . currentRoom . exits [ direction ] . exitFlags . remove ( matchDict [ \"flag\" ]) return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' removed.\" else : return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . exitFlags : return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' already set.\" else : self . currentRoom . exits [ direction ] . exitFlags . add ( matchDict [ \"flag\" ]) return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' added.\" return ( f \"Syntax: 'exitflags [add | remove] [ { ' | ' . join ( VALID_EXIT_FLAGS ) } ] \" + f \"[ { ' | ' . join ( DIRECTIONS ) } ]'.\" ) def doorflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<flag> { '|' . join ( VALID_DOOR_FLAGS ) } )\\s+)?(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not matchDict [ \"mode\" ]: return ( f \"Door flags ' { direction } ' set to ' { ', ' . join ( self . currentRoom . exits [ direction ] . doorFlags ) } '.\" ) elif \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . doorFlags : self . currentRoom . exits [ direction ] . doorFlags . remove ( matchDict [ \"flag\" ]) return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' removed.\" else : return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . doorFlags : return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' already set.\" else : self . currentRoom . exits [ direction ] . doorFlags . add ( matchDict [ \"flag\" ]) return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' added.\" return ( f \"Syntax: 'doorflags [add | remove] [ { ' | ' . join ( VALID_DOOR_FLAGS ) } ] \" + f \"[ { ' | ' . join ( DIRECTIONS ) } ]'.\" ) def secret ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<name>[A-Za-z]+)\\s+)?(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if matchDict [ \"mode\" ] and \"add\" . startswith ( matchDict [ \"mode\" ]): if not matchDict [ \"name\" ]: return \"Error: 'add' expects a name for the secret.\" elif direction not in self . currentRoom . exits : self . currentRoom . exits [ direction ] = self . getNewExit ( direction ) self . currentRoom . exits [ direction ] . exitFlags . add ( \"door\" ) self . currentRoom . exits [ direction ] . doorFlags . add ( \"hidden\" ) self . currentRoom . exits [ direction ] . door = matchDict [ \"name\" ] self . GUIRefresh () return f \"Adding secret ' { matchDict [ 'name' ] } ' to direction ' { direction } '.\" elif direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not self . currentRoom . exits [ direction ] . door : return f \"No secret { direction } of here.\" elif not matchDict [ \"mode\" ]: return f \"Exit ' { direction } ' has secret ' { self . currentRoom . exits [ direction ] . door } '.\" elif \"remove\" . startswith ( matchDict [ \"mode\" ]): if \"hidden\" in self . currentRoom . exits [ direction ] . doorFlags : self . currentRoom . exits [ direction ] . doorFlags . remove ( \"hidden\" ) self . currentRoom . exits [ direction ] . door = \"\" self . GUIRefresh () return f \"Secret { direction } removed.\" return f \"Syntax: 'secret [add | remove] [name] [ { ' | ' . join ( DIRECTIONS ) } ]'.\" def rlink ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<oneway> { regexFuzzy ( 'oneway' ) } )\\s+)?\" + r \"((?P<vnum>\\d+|undefined)\\s+)?\" + rf \"(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if matchDict [ \"mode\" ] and \"add\" . startswith ( matchDict [ \"mode\" ]): reversedDirection : str = REVERSE_DIRECTIONS [ direction ] if not matchDict [ \"vnum\" ]: return \"Error: 'add' expects a vnum or 'undefined'.\" elif matchDict [ \"vnum\" ] != \"undefined\" and matchDict [ \"vnum\" ] not in self . rooms : return f \"Error: vnum { matchDict [ 'vnum' ] } not in database.\" elif direction not in self . currentRoom . exits : self . currentRoom . exits [ direction ] = self . getNewExit ( direction ) self . currentRoom . exits [ direction ] . to = matchDict [ \"vnum\" ] if matchDict [ \"vnum\" ] == \"undefined\" : self . GUIRefresh () return f \"Direction { direction } now undefined.\" elif not matchDict [ \"oneway\" ]: if ( reversedDirection not in self . rooms [ matchDict [ \"vnum\" ]] . exits or self . rooms [ matchDict [ \"vnum\" ]] . exits [ reversedDirection ] . to == \"undefined\" ): self . rooms [ matchDict [ \"vnum\" ]] . exits [ reversedDirection ] = self . getNewExit ( reversedDirection , self . currentRoom . vnum ) self . GUIRefresh () return ( f \"Linking direction { direction } to { matchDict [ 'vnum' ] } \" + f \"with name ' { self . rooms [ matchDict [ 'vnum' ]] . name if matchDict [ 'vnum' ] in self . rooms else '' } '. \\n \" + f \"Linked exit { reversedDirection } in second room with this room.\" ) else : self . GUIRefresh () return ( f \"Linking direction { direction } to { matchDict [ 'vnum' ] } \" + f \"with name ' { self . rooms [ matchDict [ 'vnum' ]] . name if matchDict [ 'vnum' ] in self . rooms else '' } '. \\n \" + f \"Unable to link exit { reversedDirection } in second room with this room: exit already defined.\" ) else : self . GUIRefresh () return ( f \"Linking direction { direction } one way to { matchDict [ 'vnum' ] } \" + f \"with name ' { self . rooms [ matchDict [ 'vnum' ]] . name if matchDict [ 'vnum' ] in self . rooms else '' } '.\" ) elif direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not matchDict [ \"mode\" ]: toName : str if self . currentRoom . exits [ direction ] . to in self . rooms : toName = self . rooms [ self . currentRoom . exits [ direction ] . to ] . name else : toName = \"\" return ( f \"Exit ' { direction } ' links to ' { self . currentRoom . exits [ direction ] . to } ' with name ' { toName } '.\" ) elif \"remove\" . startswith ( matchDict [ \"mode\" ]): del self . currentRoom . exits [ direction ] self . GUIRefresh () return f \"Exit { direction } removed.\" return f \"Syntax: 'rlink [add | remove] [oneway] [vnum] [ { ' | ' . join ( DIRECTIONS ) } ]'.\" def getlabel ( self , text : str = \"\" ) -> str : text = text . strip () . lower () findVnum : str = self . currentRoom . vnum if not text . isdigit () else text result : str = \", \" . join ( sorted ( label for label , vnum in self . labels . items () if vnum == findVnum )) if not result : return \"Room not labeled.\" return f \"Room labels: { result } \" def rlabel ( self , text : str = \"\" ) -> None : text = text . strip () . lower () matchPattern : str = r \"^(?P<action>add|delete|info|search)(?:\\s+(?P<label>\\S+))?(?:\\s+(?P<vnum>\\d+))?$\" match : REGEX_MATCH = re . match ( matchPattern , text ) if match is None : self . output ( \"Syntax: 'rlabel [add|info|delete] [label] [vnum]'. Vnum is only used when adding a room. \" + \"Leave it blank to use the current room's vnum. Use '_label info all' to get a list of all labels.\" ) return None matchDict : dict [ str , str ] = match . groupdict () if not matchDict [ \"label\" ]: self . output ( \"Error: you need to supply a label.\" ) return None elif matchDict [ \"label\" ] == \"schema_version\" : self . output ( \"Error: 'schema_version' not allowed as label.\" ) return None label : str = matchDict [ \"label\" ] if label . isdecimal (): self . output ( \"labels cannot be decimal values.\" ) elif matchDict [ \"action\" ] == \"add\" : vnum : str if not matchDict [ \"vnum\" ]: vnum = self . currentRoom . vnum self . output ( f \"adding the label ' { label } ' to current room with VNum ' { vnum } '.\" ) else : vnum = matchDict [ \"vnum\" ] self . output ( f \"adding the label ' { label } ' with VNum ' { vnum } '.\" ) self . labels [ label ] = vnum self . saveLabels () elif matchDict [ \"action\" ] == \"delete\" : if label not in self . labels : self . output ( f \"There aren't any labels matching ' { label } ' in the database.\" ) return None self . output ( f \"Deleting label ' { label } '.\" ) del self . labels [ label ] self . saveLabels () elif matchDict [ \"action\" ] == \"info\" : if not self . labels : self . output ( \"There aren't any labels in the database yet.\" ) elif \"all\" . startswith ( label ): self . output ( \" \\n \" . join ( f \" { labelString } - { vnum } \" for labelString , vnum in sorted ( self . labels . items ())) ) elif label not in self . labels : self . output ( f \"There aren't any labels matching ' { label } ' in the database.\" ) else : self . output ( f \"Label ' { label } ' points to room ' { self . labels [ label ] } '.\" ) elif matchDict [ \"action\" ] == \"search\" : results : list [ str ] = sorted ( f \" { name } - { self . rooms [ vnum ] . name if vnum in self . rooms else 'VNum not in map' } - { vnum } \" for name , vnum in self . labels . items () if label in name ) if not results : self . output ( \"Nothing found.\" ) else : self . output ( \" \\n \" . join ( results )) def rinfo ( self , text : str = \"\" ) -> str : text = text . strip () . lower () vnum : str = self . currentRoom . vnum if not text else text if vnum in self . labels : vnum = self . labels [ vnum ] if vnum not in self . rooms : return f \"Error: No such vnum or label, ' { vnum } '\" return self . rooms [ vnum ] . info def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> list [ str ]: speedWalkDirs : list [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : list [ str ] = [] directionsBuffer : list [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" def path ( self , text : str = \"\" ) -> None : text = text . strip () . lower () match : REGEX_MATCH = RUN_DESTINATION_REGEX . match ( text ) if match is None : self . output ( \"Usage: path [label|vnum]\" ) return None destination : str = match . group ( \"destination\" ) flags : str = match . group ( \"flags\" ) result : list [ str ] = self . pathFind ( destination = destination , flags = flags . split ( \"|\" ) if flags else None ) if result : self . output ( self . createSpeedWalk ( result )) def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> list [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : frozenset [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : frozenset [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc ) def _pathFind ( self , origin : Room , isDestinationFunc : Optional [ Callable [[ Room ], bool ]] = None , exitIgnoreFunc : Optional [ Callable [[ Exit ], bool ]] = None , exitCostFunc : Optional [ Callable [[ Exit , Room ], int ]] = None , exitDestinationFunc : Optional [ Callable [[ Exit , Room ], bool ]] = None , ) -> list [ str ]: # Each key-value pare that gets added to this dict will be a parent room and child room respectively. parents : dict [ Room , tuple [ Room , str ]] = { origin : ( origin , \"\" )} # unprocessed rooms. opened : list [ tuple [ float , Room ]] = [] # Using a binary heap for storing unvisited rooms significantly increases performance. # https://en.wikipedia.org/wiki/Binary_heap heapq . heapify ( opened ) # Put the origin cost and origin room on the opened rooms heap to be processed first. heapq . heappush ( opened , ( origin . cost , origin )) # previously processed rooms. closed : dict [ Room , float ] = {} # Ignore the origin from the search by adding it to the closed rooms dict. closed [ origin ] = origin . cost # Search while there are rooms left in the opened heap. currentRoomCost : float currentRoomObj : Room neighborRoomCost : float neighborRoomObj : Room direction : str while opened : # Pop the last room cost and room object reference off the opened heap for processing. currentRoomCost , currentRoomObj = heapq . heappop ( opened ) if isDestinationFunc and isDestinationFunc ( currentRoomObj ): # We successfully found a path from the origin to the destination. break # Loop through the exits, and process each room linked to the current room. for exitDirection , exitObj in currentRoomObj . exits . items (): if exitIgnoreFunc and exitIgnoreFunc ( exitObj ): continue # Get a reference to the room object that the exit leads to using the room's vnum. neighborRoomObj = self . rooms [ exitObj . to ] # The neighbor room cost should be the sum of all movement costs # to get to the neighbor room from the origin room. neighborRoomCost = ( currentRoomCost + neighborRoomObj . cost + ( exitCostFunc ( exitObj , neighborRoomObj ) if exitCostFunc else 0 ) ) # We're only interested in the neighbor room if it hasn't been encountered yet, # or if the cost of moving from the current room to the neighbor room is less than # the cost of moving to the neighbor room from a previously discovered room. if neighborRoomObj not in closed or closed [ neighborRoomObj ] > neighborRoomCost : # Add the room object and room cost to the dict of closed rooms, # and put it on the opened rooms heap to be processed. closed [ neighborRoomObj ] = neighborRoomCost heapq . heappush ( opened , ( neighborRoomCost , neighborRoomObj )) # Since the current room is so far the most optimal way into the neighbor room, # set it as the parent of the neighbor room. parents [ neighborRoomObj ] = ( currentRoomObj , exitDirection ) if exitDestinationFunc and exitDestinationFunc ( exitObj , neighborRoomObj ): break else : # The while loop terminated normally (I.E. without encountering a break statement), # and the destination was *not* found. self . output ( \"No routes found.\" ) return [] # The while statement was broken prematurely, meaning that the destination was found. # Find the path from the origin to the destination by traversing the hierarchy # of room parents, starting with the current room. results : list [ str ] = [] while currentRoomObj is not origin : currentRoomObj , direction = parents [ currentRoomObj ] if ( currentRoomObj . vnum in LEAD_BEFORE_ENTERING_VNUMS and currentRoomObj . exits [ direction ] . to not in LEAD_BEFORE_ENTERING_VNUMS and currentRoomObj is not origin ): results . append ( \"ride\" ) results . append ( direction ) if currentRoomObj . exits [ direction ] . to in LEAD_BEFORE_ENTERING_VNUMS and ( currentRoomObj . vnum not in LEAD_BEFORE_ENTERING_VNUMS or currentRoomObj is origin ): results . append ( \"lead\" ) if \"door\" in currentRoomObj . exits [ direction ] . exitFlags : results . append ( f \"open { currentRoomObj . exits [ direction ] . door if currentRoomObj . exits [ direction ] . door else 'exit' } \" + f \" { direction } \" ) return results def getRoomFromLabel ( self , text : str ) -> Union [ Room , None ]: text = text . strip () . lower () vnum : str if not text : self . output ( \"No label or room vnum specified.\" ) elif text . isdecimal (): # The text is a vnum. vnum = text if vnum in self . rooms : return self . rooms [ vnum ] self . output ( f \"No room with vnum { vnum } .\" ) elif text in self . labels : # The text is an existing label. vnum = self . labels [ text ] if vnum in self . rooms : return self . rooms [ vnum ] self . output ( f \" { text } is set to vnum { vnum } , but there is no room with that vnum\" ) else : # The text is *not* an existing label. similarLabels : list [ str ] = sorted ( self . labels , key = lambda l : fuzz . ratio ( l , text ), reverse = True ) self . output ( f \"Unknown label. Did you mean { ', ' . join ( similarLabels [ 0 : 4 ]) } ?\" ) return None def crawl ( self , start : str , borders : Iterable [ str ]) -> tuple [ str , ... ]: explored : set [ str ] = set () unexplored : set [ str ] = set () unexplored . add ( start ) while unexplored : vnum = unexplored . pop () for _ , exitObj in self . rooms [ vnum ] . exits . items (): if exitObj . to not in explored and exitObj . to not in borders and exitObj . to . isdigit (): unexplored . add ( exitObj . to ) explored . add ( vnum ) return tuple ( explored ) def overlapping ( self ) -> tuple [ tuple [ COORDINATES_TYPE , tuple [ str , ... ]], ... ]: results : dict [ COORDINATES_TYPE , list [ str ]] = {} for vnum , room in self . rooms . items (): results . setdefault ( room . coordinates , []) . append ( vnum ) return tuple (( coordinates , tuple ( vnums )) for coordinates , vnums in results . items () if len ( vnums ) > 1 ) Method GUIRefresh ( self ) \u00b6 Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\world.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_guiRefresh\" ,)) Method createSpeedWalk ( self , directionsList ) \u00b6 Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\world.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> list [ str ]: speedWalkDirs : list [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : list [ str ] = [] directionsBuffer : list [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" Method getNeighborsFromCoordinates ( self , start , radius ) \u00b6 A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNeighborsFromRoom ( self , start , radius ) \u00b6 A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNewExit ( self , direction , to = 'undefined' , vnum = None ) \u00b6 Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\world.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit Method isBidirectional ( self , exitObj ) \u00b6 Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\world.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False Method pathFind ( self , origin = None , destination = None , flags = None ) \u00b6 Find the path Source code in mapper\\world.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> list [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : frozenset [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : frozenset [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"world.py"},{"location":"api/world/#mapper.world","text":"","title":"world"},{"location":"api/world/#mapper.world.World","text":"Source code in mapper\\world.py class World ( object ): def __init__ ( self , interface : str = \"text\" ) -> None : self . roomsLock = threading . Lock () self . isSynced : bool = False self . rooms : dict [ str , Room ] = {} self . labels : dict [ str , str ] = {} self . _interface : str = interface if interface != \"text\" : self . _gui_queue : GUI_QUEUE_TYPE = SimpleQueue () self . window : pyglet . window . Window # type: ignore[no-any-unimported] if interface == \"hc\" : from .gui import hc self . window = hc . Window ( self ) elif interface == \"sighted\" : from .gui import sighted self . window = sighted . Window ( self ) self . _currentRoom : Room = Room () self . loadRooms () self . loadLabels () @property def currentRoom ( self ) -> Room : return self . _currentRoom @currentRoom . setter def currentRoom ( self , value : Room ) -> None : self . _currentRoom = value if self . _interface != \"text\" : self . _gui_queue . put (( \"on_mapSync\" , value )) @currentRoom . deleter def currentRoom ( self ) -> None : self . _currentRoom = Room () def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_guiRefresh\" ,)) def output ( self , text : str ) -> None : print ( text ) def loadRoomsV0 ( self , db : dict [ str , dict [ str , Any ]]) -> None : terrainReplacements : dict [ str , str ] = { \"indoors\" : \"building\" , \"random\" : \"undefined\" , \"shallow\" : \"shallows\" , \"shallowwater\" : \"shallows\" , } loadFlagReplacements : dict [ str , str ] = { \"packhorse\" : \"pack_horse\" , \"trainedhorse\" : \"trained_horse\" , } mobFlagReplacements : dict [ str , str ] = { \"any\" : \"passive_mob\" , \"smob\" : \"aggressive_mob\" , \"quest\" : \"quest_mob\" , \"scoutguild\" : \"scout_guild\" , \"mageguild\" : \"mage_guild\" , \"clericguild\" : \"cleric_guild\" , \"warriorguild\" : \"warrior_guild\" , \"rangerguild\" : \"ranger_guild\" , \"armourshop\" : \"armour_shop\" , \"foodshop\" : \"food_shop\" , \"petshop\" : \"pet_shop\" , \"weaponshop\" : \"weapon_shop\" , } doorFlagReplacements : dict [ str , str ] = { \"noblock\" : \"no_block\" , \"nobreak\" : \"no_break\" , \"nopick\" : \"no_pick\" , \"needkey\" : \"need_key\" , } portableReplacements : dict [ str , str ] = { \"notportable\" : \"not_portable\" , } ridableReplacements : dict [ str , str ] = { \"notridable\" : \"not_ridable\" , } for vnum , roomDict in db . items (): if not vnum . isdigit (): # This should never happen, but safe to ignore if it does. # Todo: add a warning to alert the user here. continue elif roomDict [ \"terrain\" ] . startswith ( \"death\" ): # handles \"death\" and \"deathtrap\". # This should never happen, but safe to ignore if it does. # Todo: add a warning to alert the user here. continue newRoom : Room = Room () newRoom . vnum = vnum newRoom . align = roomDict [ \"align\" ] with suppress ( KeyError ): newRoom . avoid = roomDict [ \"avoid\" ] newRoom . desc = roomDict [ \"desc\" ] newRoom . dynamicDesc = roomDict [ \"dynamicDesc\" ] . lstrip () for direction , exitDict in roomDict [ \"exits\" ] . items (): newExit : Exit = self . getNewExit ( direction , exitDict [ \"to\" ], vnum ) newExit . door = exitDict [ \"door\" ] newExit . doorFlags = { doorFlagReplacements . get ( flag , flag ) for flag in exitDict [ \"doorFlags\" ]} newExit . exitFlags = set ( exitDict [ \"exitFlags\" ]) newRoom . exits [ direction ] = newExit exitDict . clear () newRoom . light = roomDict [ \"light\" ] newRoom . loadFlags = { loadFlagReplacements . get ( flag , flag ) for flag in roomDict [ \"loadFlags\" ]} newRoom . mobFlags = { mobFlagReplacements . get ( flag , flag ) for flag in roomDict [ \"mobFlags\" ]} newRoom . name = roomDict [ \"name\" ] newRoom . note = roomDict [ \"note\" ] portable : str = roomDict [ \"portable\" ] newRoom . portable = portableReplacements . get ( portable , portable ) ridable : str = roomDict [ \"ridable\" ] newRoom . ridable = ridableReplacements . get ( ridable , ridable ) with suppress ( KeyError ): newRoom . sundeath = roomDict [ \"sundeath\" ] terrain : str = roomDict [ \"terrain\" ] newRoom . terrain = terrainReplacements . get ( terrain , terrain ) newRoom . x = roomDict [ \"x\" ] newRoom . y = roomDict [ \"y\" ] newRoom . z = roomDict [ \"z\" ] newRoom . calculateCost () self . rooms [ vnum ] = newRoom roomDict . clear () def loadRoomsV1Through2 ( self , db : dict [ str , dict [ str , Any ]], schemaVersion : int ) -> None : for vnum , roomDict in db . items (): newRoom : Room = Room () newRoom . vnum = vnum newRoom . align = roomDict [ \"alignment\" ] newRoom . avoid = roomDict [ \"avoid\" ] newRoom . desc = roomDict [ \"description\" ] newRoom . dynamicDesc = roomDict [ \"contents\" ] . lstrip () for direction , exitDict in roomDict [ \"exits\" ] . items (): newExit : Exit = self . getNewExit ( direction , exitDict [ \"to\" ], vnum ) newExit . door = exitDict [ \"door\" ] newExit . doorFlags = set ( exitDict [ \"door_flags\" ]) newExit . exitFlags = set ( exitDict [ \"exit_flags\" ]) newRoom . exits [ direction ] = newExit exitDict . clear () newRoom . light = roomDict [ \"light\" ] newRoom . loadFlags = set ( roomDict [ \"load_flags\" ]) newRoom . mobFlags = set ( roomDict [ \"mob_flags\" ]) newRoom . name = roomDict [ \"name\" ] newRoom . note = roomDict [ \"note\" ] newRoom . portable = roomDict [ \"portable\" ] newRoom . ridable = roomDict [ \"ridable\" ] newRoom . sundeath = roomDict [ \"sundeath\" ] newRoom . terrain = roomDict [ \"terrain\" ] newRoom . coordinates = roomDict [ \"coordinates\" ] if schemaVersion >= 2 : newRoom . area = roomDict [ \"area\" ] newRoom . serverID = roomDict [ \"server_id\" ] newRoom . calculateCost () self . rooms [ vnum ] = newRoom roomDict . clear () def loadRooms ( self ) -> None : startTime : float = defaultTimer () if gc . isenabled (): gc . disable () self . output ( \"Loading the database file.\" ) errors : Union [ str , None ] db : Union [ dict [ str , dict [ str , Any ]], None ] errors , db , schemaVersion = loadRooms () if db is None : if errors is not None : self . output ( errors ) return None schemaVersionOutput : str = \"latest\" if schemaVersion == MAP_SCHEMA_VERSION else f \"V { schemaVersion } \" self . output ( f \"Creating room objects with { schemaVersionOutput } schema.\" ) with self . roomsLock : if schemaVersion < 1 : self . loadRoomsV0 ( db ) else : self . loadRoomsV1Through2 ( db , schemaVersion ) db . clear () self . currentRoom = self . rooms [ \"0\" ] if not gc . isenabled (): gc . enable () gc . collect () elapsedTime : float = defaultTimer () - startTime self . output ( f \"Map database loaded in { elapsedTime : .1f } seconds.\" ) def saveRooms ( self ) -> None : startTime : float = defaultTimer () if gc . isenabled (): gc . disable () self . output ( \"Creating dict from room objects.\" ) db : dict [ str , dict [ str , Any ]] = {} with self . roomsLock : for vnum , roomObj in self . rooms . items (): newRoom : dict [ str , Any ] = {} newRoom [ \"alignment\" ] = roomObj . align newRoom [ \"area\" ] = roomObj . area newRoom [ \"avoid\" ] = roomObj . avoid newRoom [ \"contents\" ] = roomObj . dynamicDesc newRoom [ \"coordinates\" ] = roomObj . coordinates newRoom [ \"description\" ] = roomObj . desc newRoom [ \"exits\" ] = {} for direction , exitObj in roomObj . exits . items (): newExit : dict [ str , Any ] = {} newExit [ \"door\" ] = exitObj . door newExit [ \"door_flags\" ] = sorted ( exitObj . doorFlags ) newExit [ \"exit_flags\" ] = sorted ( exitObj . exitFlags ) newExit [ \"to\" ] = exitObj . to newRoom [ \"exits\" ][ direction ] = newExit newRoom [ \"light\" ] = roomObj . light newRoom [ \"load_flags\" ] = sorted ( roomObj . loadFlags ) newRoom [ \"mob_flags\" ] = sorted ( roomObj . mobFlags ) newRoom [ \"name\" ] = roomObj . name newRoom [ \"note\" ] = roomObj . note newRoom [ \"portable\" ] = roomObj . portable newRoom [ \"ridable\" ] = roomObj . ridable newRoom [ \"server_id\" ] = roomObj . serverID newRoom [ \"sundeath\" ] = roomObj . sundeath newRoom [ \"terrain\" ] = roomObj . terrain db [ vnum ] = newRoom self . output ( \"Saving the database.\" ) dumpRooms ( db ) if not gc . isenabled (): gc . enable () gc . collect () elapsedTime : float = defaultTimer () - startTime self . output ( f \"Map Database saved in { elapsedTime : .1f } seconds.\" ) def loadLabels ( self ) -> None : errors : Union [ str , None ] labels : Union [ dict [ str , str ], None ] schemaVersion : int errors , labels , schemaVersion = loadLabels () if labels is None : if errors is not None : self . output ( errors ) return None self . labels . update ( labels ) schemaVersionOutput : str = \"latest\" if schemaVersion == LABELS_SCHEMA_VERSION else f \"V { schemaVersion } \" self . output ( f \"Loaded room labels with { schemaVersionOutput } schema.\" ) orphans : list [ str ] = [ label for label , vnum in self . labels . items () if vnum not in self . rooms ] if orphans : for label in orphans : del self . labels [ label ] self . output ( f \"Detected orphan labels: { ', ' . join ( orphans ) } \" ) self . output ( f \" { len ( orphans ) } orphan labels removed.\" ) def saveLabels ( self ) -> None : dumpLabels ( self . labels ) def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) def getVnum ( self , roomObj : Room ) -> Union [ str , None ]: result : Union [ str , None ] = None for vnum , obj in self . rooms . items (): if obj is roomObj : result = vnum break return result def coordinatesSubtract ( self , first : Sequence [ int ], second : Sequence [ int ]) -> tuple [ int , ... ]: return tuple ( a - b for a , b in zip ( first , second )) def coordinatesAdd ( self , first : Sequence [ int ], second : Sequence [ int ]) -> tuple [ int , ... ]: return tuple ( a + b for a , b in zip ( first , second )) def coordinatesAddDirection ( self , coordinates : Sequence [ int ], direction : str ) -> tuple [ int , ... ]: if direction not in DIRECTIONS : raise ValueError ( f \"Direction must be one of { DIRECTIONS } .\" ) return self . coordinatesAdd ( coordinates , DIRECTION_COORDINATES [ direction ]) def getNewVnum ( self ) -> str : return str ( max ( int ( i ) for i in self . rooms ) + 1 ) def revnum ( self , text : str = \"\" ) -> None : text = text . strip () . lower () match : REGEX_MATCH = re . match ( r \"^(?:(?P<origin>\\d+)\\s+)?(?:\\s*(?P<destination>\\d+)\\s*)$\" , text ) if match is None : self . output ( \"Syntax: 'revnum [Origin VNum] [Destination VNum]'.\" ) return None matchDict : dict [ str , str ] = match . groupdict () if not matchDict [ \"destination\" ]: self . output ( \"Error: you need to supply a destination VNum.\" ) return None destination = matchDict [ \"destination\" ] if not matchDict [ \"origin\" ]: origin = self . currentRoom . vnum self . output ( f \"Changing the VNum of the current room to ' { destination } '.\" ) else : origin = matchDict [ \"origin\" ] self . output ( f \"Changing the Vnum ' { origin } ' to ' { destination } '.\" ) for roomVnum , roomObj in self . rooms . items (): for direction , exitObj in roomObj . exits . items (): if roomVnum == origin : exitObj . vnum = destination if exitObj . to == origin : self . rooms [ roomVnum ] . exits [ direction ] . to = destination self . rooms [ origin ] . vnum = destination self . rooms [ destination ] = self . rooms [ origin ] del self . rooms [ origin ] def rdelete ( self , text : str ) -> str : text = text . strip () . lower () vnum : str if text . isdigit (): vnum = text if self . currentRoom . vnum == vnum : self . isSynced = False self . currentRoom = self . rooms . get ( \"0\" , Room ()) elif vnum not in self . rooms : return f \"Error: the vnum ' { vnum } ' does not exist.\" elif self . isSynced : vnum = self . currentRoom . vnum self . isSynced = False self . currentRoom = self . rooms . get ( \"0\" , Room ()) else : return \"Syntax: rdelete [vnum]\" output = f \"Deleting room ' { vnum } ' with name ' { self . rooms [ vnum ] . name } '.\" with self . roomsLock : for roomVnum , roomObj in self . rooms . items (): for direction , exitObj in roomObj . exits . items (): if exitObj . to == vnum : self . rooms [ roomVnum ] . exits [ direction ] . to = \"undefined\" del self . rooms [ vnum ] self . GUIRefresh () return output def searchRooms ( self , exactMatch : bool = False , ** kwargs : str ) -> list [ Room ]: validArgs : tuple [ str , ... ] = ( \"area\" , \"serverID\" , \"name\" , \"desc\" , \"dynamicDesc\" , \"note\" , \"terrain\" , \"light\" , \"align\" , \"portable\" , \"ridable\" , \"sundeath\" , \"x\" , \"y\" , \"z\" , \"mobFlags\" , \"loadFlags\" , \"exitFlags\" , \"doorFlags\" , \"to\" , \"door\" , ) observeExactMatch : tuple [ str , ... ] = ( \"area\" , \"name\" , \"desc\" , \"dynamicDesc\" , \"note\" ) alwaysExactMatch : tuple [ str , ... ] = ( \"serverID\" , \"terrain\" , \"light\" , \"align\" , \"portable\" , \"ridable\" , \"sundeath\" , \"x\" , \"y\" , \"z\" , ) kwargs = { key : value . strip () . lower () for key , value in kwargs . items () if key . strip () in validArgs and value . strip () } results : list [ Room ] = [] if not kwargs : return results for vnum , roomObj in self . rooms . items (): keysMatched = 0 for key , value in kwargs . items (): if key in observeExactMatch : roomData = getattr ( roomObj , key ) . strip () . lower () if not exactMatch and value in roomData or roomData == value : keysMatched += 1 elif key in alwaysExactMatch and getattr ( roomObj , key ) . strip () . lower () == value : keysMatched += 1 elif key in ( \"mobFlags\" , \"loadFlags\" ) and getattr ( roomObj , key , set ()) . intersection ( value ): keysMatched += 1 else : for direction , exitObj in roomObj . exits . items (): if key in ( \"exitFlags\" , \"doorFlags\" ) and getattr ( exitObj , key , set ()) . intersection ( value ): keysMatched += 1 elif key in ( \"to\" , \"door\" ) and getattr ( exitObj , key , \"\" ) . strip () . lower () == value : keysMatched += 1 if len ( kwargs ) == keysMatched : results . append ( roomObj ) return results def fdoor ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fdoor [text]'.\" results : list [ Room ] = self . searchRooms ( door = text ) if not results : return \"Nothing found.\" currentRoom : Room = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = \", \" . join ( exitDir + \": \" + exitObj . door for exitDir , exitObj in roomObj . exits . items () if text . strip () in exitObj . door ), direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def fdynamic ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fdynamic [text]'.\" results : list [ Room ] = self . searchRooms ( dynamicDesc = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . dynamicDesc , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def flabel ( self , findFormat : str , text : str = \"\" ) -> str : if not self . labels : return \"No labels defined.\" text = text . strip () . lower () results : set [ Room ] = { self . rooms [ vnum ] for label , vnum in self . labels . items () if text and text in label . strip () . lower () or not text } if not results : return \"Nothing found.\" currentRoom = self . currentRoom return \" \\n \" . join ( findFormat . format ( attribute = self . getlabel ( roomObj . vnum ), direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( sorted ( results , key = lambda r : r . manhattanDistance ( currentRoom ))[: 20 ]) ) def fname ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fname [text]'.\" results : list [ Room ] = self . searchRooms ( name = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = \"\" if \" {name} \" in findFormat and \" {attribute} \" in findFormat else roomObj . name , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def fnote ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'fnote [text]'.\" results : list [ Room ] = self . searchRooms ( note = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . note , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def farea ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip (): return \"Usage: 'farea [text]'.\" results : list [ Room ] = self . searchRooms ( area = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . area , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def fsid ( self , findFormat : str , text : str = \"\" ) -> str : if not text . strip () . isdigit (): return \"Usage: 'fsid [number]'.\" results : list [ Room ] = self . searchRooms ( serverID = text ) if not results : return \"Nothing found.\" currentRoom = self . currentRoom results . sort ( key = lambda roomObj : roomObj . manhattanDistance ( currentRoom )) return \" \\n \" . join ( findFormat . format ( attribute = roomObj . serverID , direction = currentRoom . directionTo ( roomObj ), clockPosition = currentRoom . clockPositionTo ( roomObj ), distance = currentRoom . manhattanDistance ( roomObj ), ** { i : getattr ( roomObj , i ) for i in dir ( roomObj )}, ) for roomObj in reversed ( results [: 20 ]) ) def rnote ( self , text : str = \"\" ) -> str : text = text . strip () if not text : return ( f \"Room note set to ' { self . currentRoom . note } '. Use 'rnote [text]' to change it, \" + \"'rnote -a [text]' to append to it, or 'rnote -r' to remove it.\" ) if text . lower () . startswith ( \"-r\" ): if len ( text ) > 2 : return \"Error: '-r' requires no extra arguments. Change aborted.\" self . currentRoom . note = \"\" return \"Note removed.\" elif text . lower () . startswith ( \"-a\" ): if len ( text ) == 2 : return \"Error: '-a' requires text to be appended. Change aborted.\" self . currentRoom . note = f \" { self . currentRoom . note . strip () } { text [ 2 :] . strip () } \" else : self . currentRoom . note = text return f \"Room note now set to ' { self . currentRoom . note } '.\" def ralign ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"good\" , \"neutral\" , \"evil\" , \"undefined\" ) if text not in validValues : return ( f \"Room alignment set to ' { self . currentRoom . align } '. \" + f \"Use 'ralign [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . align = text return f \"Setting room align to ' { self . currentRoom . align } '.\" def rlight ( self , text : str = \"\" ) -> str : text = text . strip () if not text : return ( f \"Room light set to ' { self . currentRoom . light } '. \" + f \"Use 'rlight [ { ' | ' . join ( set ( LIGHT_SYMBOLS . values ())) } ]' to change it.\" ) elif text not in LIGHT_SYMBOLS and text . lower () not in LIGHT_SYMBOLS . values (): return ( f \"Invalid value for room light ( { text } ). \" + f \"Valid values are [ { ' | ' . join ( set ( LIGHT_SYMBOLS . values ())) } ].\" ) try : self . currentRoom . light = LIGHT_SYMBOLS [ text ] except KeyError : self . currentRoom . light = text . lower () return f \"Setting room light to ' { self . currentRoom . light } '.\" def rportable ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"portable\" , \"not_portable\" , \"undefined\" ) if text not in validValues : return ( f \"Room portable set to ' { self . currentRoom . portable } '. \" + f \"Use 'rportable [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . portable = text return f \"Setting room portable to ' { self . currentRoom . portable } '.\" def rridable ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"ridable\" , \"not_ridable\" , \"undefined\" , ) if text not in validValues : return ( f \"Room ridable set to ' { self . currentRoom . ridable } '. \" + f \"Use 'rridable [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . ridable = text self . currentRoom . calculateCost () return f \"Setting room ridable to ' { self . currentRoom . ridable } '.\" def rsundeath ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"sundeath\" , \"no_sundeath\" , \"undefined\" ) if text not in validValues : return ( f \"Room sundeath set to ' { self . currentRoom . sundeath } '. \" + f \"Use 'rsundeath [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . sundeath = text return f \"Setting room sundeath to ' { self . currentRoom . sundeath } '.\" def ravoid ( self , text : str = \"\" ) -> str : text = text . strip () . lower () validValues : tuple [ str , ... ] = ( \"+\" , \"-\" ) if text not in validValues : return ( f \"Room avoid { 'enabled' if self . currentRoom . avoid else 'disabled' } . \" + f \"Use 'ravoid [ { ' | ' . join ( validValues ) } ]' to change it.\" ) self . currentRoom . avoid = text == \"+\" self . currentRoom . calculateCost () return f \" { 'Enabling' if self . currentRoom . avoid else 'Disabling' } room avoid.\" def rterrain ( self , text : str = \"\" ) -> str : text = text . strip () if not text : return ( f \"Room terrain set to ' { self . currentRoom . terrain } '. \" + f \"Use 'rterrain [ { ' | ' . join ( sorted ( TERRAIN_SYMBOLS . values ())) } ]' to change it.\" ) elif text not in TERRAIN_SYMBOLS and text . lower () not in TERRAIN_SYMBOLS . values (): return ( f \"Invalid value for room terrain ( { text } ). \" + f \"Valid values are [ { ' | ' . join ( sorted ( TERRAIN_SYMBOLS . values ())) } ].\" ) try : self . currentRoom . terrain = TERRAIN_SYMBOLS [ text ] except KeyError : self . currentRoom . terrain = text . lower () self . currentRoom . calculateCost () self . GUIRefresh () return f \"Setting room terrain to ' { self . currentRoom . terrain } '.\" def rx ( self , text : str = \"\" ) -> str : text = text . strip () . lower () if not text : return f \"Room coordinate X set to ' { self . currentRoom . x } '. Use 'rx [digit]' to change it.\" try : self . currentRoom . x = int ( text ) self . GUIRefresh () return f \"Setting room X coordinate to ' { self . currentRoom . x } '.\" except ValueError : return \"Error: room coordinates must be comprised of digits only.\" def ry ( self , text : str = \"\" ) -> str : text = text . strip () . lower () if not text : return f \"Room coordinate Y set to ' { self . currentRoom . y } '. Use 'ry [digit]' to change it.\" try : self . currentRoom . y = int ( text ) self . GUIRefresh () return f \"Setting room Y coordinate to ' { self . currentRoom . y } '.\" except ValueError : return \"Error: room coordinates must be comprised of digits only.\" def rz ( self , text : str = \"\" ) -> str : text = text . strip () . lower () if not text : return f \"Room coordinate Z set to ' { self . currentRoom . z } '. Use 'rz [digit]' to change it.\" try : self . currentRoom . z = int ( text ) self . GUIRefresh () return f \"Setting room Z coordinate to ' { self . currentRoom . z } '.\" except ValueError : return \"Error: room coordinates must be comprised of digits only.\" def rmobflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^(?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\" + rf \"\\s+(?P<flag> { '|' . join ( VALID_MOB_FLAGS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () if \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . mobFlags : self . currentRoom . mobFlags . remove ( matchDict [ \"flag\" ]) return f \"Mob flag ' { matchDict [ 'flag' ] } ' removed.\" else : return f \"Mob flag ' { matchDict [ 'flag' ] } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . mobFlags : return f \"Mob flag ' { matchDict [ 'flag' ] } ' already set.\" else : self . currentRoom . mobFlags . add ( matchDict [ \"flag\" ]) return f \"Mob flag ' { matchDict [ 'flag' ] } ' added.\" return ( f \"Mob flags set to ' { ', ' . join ( self . currentRoom . mobFlags ) } '. \" + f \"Use 'rmobflags [add | remove] [ { ' | ' . join ( VALID_MOB_FLAGS ) } ]' to change them.\" ) def rloadflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^(?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\" + rf \"\\s+(?P<flag> { '|' . join ( VALID_LOAD_FLAGS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () if \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . loadFlags : self . currentRoom . loadFlags . remove ( matchDict [ \"flag\" ]) return f \"Load flag ' { matchDict [ 'flag' ] } ' removed.\" else : return f \"Load flag ' { matchDict [ 'flag' ] } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . loadFlags : return f \"Load flag ' { matchDict [ 'flag' ] } ' already set.\" else : self . currentRoom . loadFlags . add ( matchDict [ \"flag\" ]) return f \"Load flag ' { matchDict [ 'flag' ] } ' added.\" return ( f \"Load flags set to ' { ', ' . join ( self . currentRoom . loadFlags ) } '. \" + f \"Use 'rloadflags [add | remove] [ { ' | ' . join ( VALID_LOAD_FLAGS ) } ]' to change them.\" ) def exitflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<flag> { '|' . join ( VALID_EXIT_FLAGS ) } )\\s+)?(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not matchDict [ \"mode\" ]: return ( f \"Exit flags ' { direction } ' set to ' { ', ' . join ( self . currentRoom . exits [ direction ] . exitFlags ) } '.\" ) elif \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . exitFlags : self . currentRoom . exits [ direction ] . exitFlags . remove ( matchDict [ \"flag\" ]) return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' removed.\" else : return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . exitFlags : return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' already set.\" else : self . currentRoom . exits [ direction ] . exitFlags . add ( matchDict [ \"flag\" ]) return f \"Exit flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' added.\" return ( f \"Syntax: 'exitflags [add | remove] [ { ' | ' . join ( VALID_EXIT_FLAGS ) } ] \" + f \"[ { ' | ' . join ( DIRECTIONS ) } ]'.\" ) def doorflags ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<flag> { '|' . join ( VALID_DOOR_FLAGS ) } )\\s+)?(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not matchDict [ \"mode\" ]: return ( f \"Door flags ' { direction } ' set to ' { ', ' . join ( self . currentRoom . exits [ direction ] . doorFlags ) } '.\" ) elif \"remove\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . doorFlags : self . currentRoom . exits [ direction ] . doorFlags . remove ( matchDict [ \"flag\" ]) return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' removed.\" else : return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' not set.\" elif \"add\" . startswith ( matchDict [ \"mode\" ]): if matchDict [ \"flag\" ] in self . currentRoom . exits [ direction ] . doorFlags : return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' already set.\" else : self . currentRoom . exits [ direction ] . doorFlags . add ( matchDict [ \"flag\" ]) return f \"Door flag ' { matchDict [ 'flag' ] } ' in direction ' { direction } ' added.\" return ( f \"Syntax: 'doorflags [add | remove] [ { ' | ' . join ( VALID_DOOR_FLAGS ) } ] \" + f \"[ { ' | ' . join ( DIRECTIONS ) } ]'.\" ) def secret ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<name>[A-Za-z]+)\\s+)?(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if matchDict [ \"mode\" ] and \"add\" . startswith ( matchDict [ \"mode\" ]): if not matchDict [ \"name\" ]: return \"Error: 'add' expects a name for the secret.\" elif direction not in self . currentRoom . exits : self . currentRoom . exits [ direction ] = self . getNewExit ( direction ) self . currentRoom . exits [ direction ] . exitFlags . add ( \"door\" ) self . currentRoom . exits [ direction ] . doorFlags . add ( \"hidden\" ) self . currentRoom . exits [ direction ] . door = matchDict [ \"name\" ] self . GUIRefresh () return f \"Adding secret ' { matchDict [ 'name' ] } ' to direction ' { direction } '.\" elif direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not self . currentRoom . exits [ direction ] . door : return f \"No secret { direction } of here.\" elif not matchDict [ \"mode\" ]: return f \"Exit ' { direction } ' has secret ' { self . currentRoom . exits [ direction ] . door } '.\" elif \"remove\" . startswith ( matchDict [ \"mode\" ]): if \"hidden\" in self . currentRoom . exits [ direction ] . doorFlags : self . currentRoom . exits [ direction ] . doorFlags . remove ( \"hidden\" ) self . currentRoom . exits [ direction ] . door = \"\" self . GUIRefresh () return f \"Secret { direction } removed.\" return f \"Syntax: 'secret [add | remove] [name] [ { ' | ' . join ( DIRECTIONS ) } ]'.\" def rlink ( self , text : str = \"\" ) -> str : text = text . strip () . lower () matchPattern : str = ( rf \"^((?P<mode> { regexFuzzy ( 'add' ) } | { regexFuzzy ( 'remove' ) } )\\s+)?\" + rf \"((?P<oneway> { regexFuzzy ( 'oneway' ) } )\\s+)?\" + r \"((?P<vnum>\\d+|undefined)\\s+)?\" + rf \"(?P<direction> { regexFuzzy ( DIRECTIONS ) } )\" ) match : REGEX_MATCH = re . match ( matchPattern , text ) if match is not None : matchDict : dict [ str , str ] = match . groupdict () direction : str = \"\" . join ( dir for dir in DIRECTIONS if dir . startswith ( matchDict [ \"direction\" ])) if matchDict [ \"mode\" ] and \"add\" . startswith ( matchDict [ \"mode\" ]): reversedDirection : str = REVERSE_DIRECTIONS [ direction ] if not matchDict [ \"vnum\" ]: return \"Error: 'add' expects a vnum or 'undefined'.\" elif matchDict [ \"vnum\" ] != \"undefined\" and matchDict [ \"vnum\" ] not in self . rooms : return f \"Error: vnum { matchDict [ 'vnum' ] } not in database.\" elif direction not in self . currentRoom . exits : self . currentRoom . exits [ direction ] = self . getNewExit ( direction ) self . currentRoom . exits [ direction ] . to = matchDict [ \"vnum\" ] if matchDict [ \"vnum\" ] == \"undefined\" : self . GUIRefresh () return f \"Direction { direction } now undefined.\" elif not matchDict [ \"oneway\" ]: if ( reversedDirection not in self . rooms [ matchDict [ \"vnum\" ]] . exits or self . rooms [ matchDict [ \"vnum\" ]] . exits [ reversedDirection ] . to == \"undefined\" ): self . rooms [ matchDict [ \"vnum\" ]] . exits [ reversedDirection ] = self . getNewExit ( reversedDirection , self . currentRoom . vnum ) self . GUIRefresh () return ( f \"Linking direction { direction } to { matchDict [ 'vnum' ] } \" + f \"with name ' { self . rooms [ matchDict [ 'vnum' ]] . name if matchDict [ 'vnum' ] in self . rooms else '' } '. \\n \" + f \"Linked exit { reversedDirection } in second room with this room.\" ) else : self . GUIRefresh () return ( f \"Linking direction { direction } to { matchDict [ 'vnum' ] } \" + f \"with name ' { self . rooms [ matchDict [ 'vnum' ]] . name if matchDict [ 'vnum' ] in self . rooms else '' } '. \\n \" + f \"Unable to link exit { reversedDirection } in second room with this room: exit already defined.\" ) else : self . GUIRefresh () return ( f \"Linking direction { direction } one way to { matchDict [ 'vnum' ] } \" + f \"with name ' { self . rooms [ matchDict [ 'vnum' ]] . name if matchDict [ 'vnum' ] in self . rooms else '' } '.\" ) elif direction not in self . currentRoom . exits : return f \"Exit { direction } does not exist.\" elif not matchDict [ \"mode\" ]: toName : str if self . currentRoom . exits [ direction ] . to in self . rooms : toName = self . rooms [ self . currentRoom . exits [ direction ] . to ] . name else : toName = \"\" return ( f \"Exit ' { direction } ' links to ' { self . currentRoom . exits [ direction ] . to } ' with name ' { toName } '.\" ) elif \"remove\" . startswith ( matchDict [ \"mode\" ]): del self . currentRoom . exits [ direction ] self . GUIRefresh () return f \"Exit { direction } removed.\" return f \"Syntax: 'rlink [add | remove] [oneway] [vnum] [ { ' | ' . join ( DIRECTIONS ) } ]'.\" def getlabel ( self , text : str = \"\" ) -> str : text = text . strip () . lower () findVnum : str = self . currentRoom . vnum if not text . isdigit () else text result : str = \", \" . join ( sorted ( label for label , vnum in self . labels . items () if vnum == findVnum )) if not result : return \"Room not labeled.\" return f \"Room labels: { result } \" def rlabel ( self , text : str = \"\" ) -> None : text = text . strip () . lower () matchPattern : str = r \"^(?P<action>add|delete|info|search)(?:\\s+(?P<label>\\S+))?(?:\\s+(?P<vnum>\\d+))?$\" match : REGEX_MATCH = re . match ( matchPattern , text ) if match is None : self . output ( \"Syntax: 'rlabel [add|info|delete] [label] [vnum]'. Vnum is only used when adding a room. \" + \"Leave it blank to use the current room's vnum. Use '_label info all' to get a list of all labels.\" ) return None matchDict : dict [ str , str ] = match . groupdict () if not matchDict [ \"label\" ]: self . output ( \"Error: you need to supply a label.\" ) return None elif matchDict [ \"label\" ] == \"schema_version\" : self . output ( \"Error: 'schema_version' not allowed as label.\" ) return None label : str = matchDict [ \"label\" ] if label . isdecimal (): self . output ( \"labels cannot be decimal values.\" ) elif matchDict [ \"action\" ] == \"add\" : vnum : str if not matchDict [ \"vnum\" ]: vnum = self . currentRoom . vnum self . output ( f \"adding the label ' { label } ' to current room with VNum ' { vnum } '.\" ) else : vnum = matchDict [ \"vnum\" ] self . output ( f \"adding the label ' { label } ' with VNum ' { vnum } '.\" ) self . labels [ label ] = vnum self . saveLabels () elif matchDict [ \"action\" ] == \"delete\" : if label not in self . labels : self . output ( f \"There aren't any labels matching ' { label } ' in the database.\" ) return None self . output ( f \"Deleting label ' { label } '.\" ) del self . labels [ label ] self . saveLabels () elif matchDict [ \"action\" ] == \"info\" : if not self . labels : self . output ( \"There aren't any labels in the database yet.\" ) elif \"all\" . startswith ( label ): self . output ( \" \\n \" . join ( f \" { labelString } - { vnum } \" for labelString , vnum in sorted ( self . labels . items ())) ) elif label not in self . labels : self . output ( f \"There aren't any labels matching ' { label } ' in the database.\" ) else : self . output ( f \"Label ' { label } ' points to room ' { self . labels [ label ] } '.\" ) elif matchDict [ \"action\" ] == \"search\" : results : list [ str ] = sorted ( f \" { name } - { self . rooms [ vnum ] . name if vnum in self . rooms else 'VNum not in map' } - { vnum } \" for name , vnum in self . labels . items () if label in name ) if not results : self . output ( \"Nothing found.\" ) else : self . output ( \" \\n \" . join ( results )) def rinfo ( self , text : str = \"\" ) -> str : text = text . strip () . lower () vnum : str = self . currentRoom . vnum if not text else text if vnum in self . labels : vnum = self . labels [ vnum ] if vnum not in self . rooms : return f \"Error: No such vnum or label, ' { vnum } '\" return self . rooms [ vnum ] . info def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> list [ str ]: speedWalkDirs : list [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : list [ str ] = [] directionsBuffer : list [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" def path ( self , text : str = \"\" ) -> None : text = text . strip () . lower () match : REGEX_MATCH = RUN_DESTINATION_REGEX . match ( text ) if match is None : self . output ( \"Usage: path [label|vnum]\" ) return None destination : str = match . group ( \"destination\" ) flags : str = match . group ( \"flags\" ) result : list [ str ] = self . pathFind ( destination = destination , flags = flags . split ( \"|\" ) if flags else None ) if result : self . output ( self . createSpeedWalk ( result )) def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> list [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : frozenset [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : frozenset [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc ) def _pathFind ( self , origin : Room , isDestinationFunc : Optional [ Callable [[ Room ], bool ]] = None , exitIgnoreFunc : Optional [ Callable [[ Exit ], bool ]] = None , exitCostFunc : Optional [ Callable [[ Exit , Room ], int ]] = None , exitDestinationFunc : Optional [ Callable [[ Exit , Room ], bool ]] = None , ) -> list [ str ]: # Each key-value pare that gets added to this dict will be a parent room and child room respectively. parents : dict [ Room , tuple [ Room , str ]] = { origin : ( origin , \"\" )} # unprocessed rooms. opened : list [ tuple [ float , Room ]] = [] # Using a binary heap for storing unvisited rooms significantly increases performance. # https://en.wikipedia.org/wiki/Binary_heap heapq . heapify ( opened ) # Put the origin cost and origin room on the opened rooms heap to be processed first. heapq . heappush ( opened , ( origin . cost , origin )) # previously processed rooms. closed : dict [ Room , float ] = {} # Ignore the origin from the search by adding it to the closed rooms dict. closed [ origin ] = origin . cost # Search while there are rooms left in the opened heap. currentRoomCost : float currentRoomObj : Room neighborRoomCost : float neighborRoomObj : Room direction : str while opened : # Pop the last room cost and room object reference off the opened heap for processing. currentRoomCost , currentRoomObj = heapq . heappop ( opened ) if isDestinationFunc and isDestinationFunc ( currentRoomObj ): # We successfully found a path from the origin to the destination. break # Loop through the exits, and process each room linked to the current room. for exitDirection , exitObj in currentRoomObj . exits . items (): if exitIgnoreFunc and exitIgnoreFunc ( exitObj ): continue # Get a reference to the room object that the exit leads to using the room's vnum. neighborRoomObj = self . rooms [ exitObj . to ] # The neighbor room cost should be the sum of all movement costs # to get to the neighbor room from the origin room. neighborRoomCost = ( currentRoomCost + neighborRoomObj . cost + ( exitCostFunc ( exitObj , neighborRoomObj ) if exitCostFunc else 0 ) ) # We're only interested in the neighbor room if it hasn't been encountered yet, # or if the cost of moving from the current room to the neighbor room is less than # the cost of moving to the neighbor room from a previously discovered room. if neighborRoomObj not in closed or closed [ neighborRoomObj ] > neighborRoomCost : # Add the room object and room cost to the dict of closed rooms, # and put it on the opened rooms heap to be processed. closed [ neighborRoomObj ] = neighborRoomCost heapq . heappush ( opened , ( neighborRoomCost , neighborRoomObj )) # Since the current room is so far the most optimal way into the neighbor room, # set it as the parent of the neighbor room. parents [ neighborRoomObj ] = ( currentRoomObj , exitDirection ) if exitDestinationFunc and exitDestinationFunc ( exitObj , neighborRoomObj ): break else : # The while loop terminated normally (I.E. without encountering a break statement), # and the destination was *not* found. self . output ( \"No routes found.\" ) return [] # The while statement was broken prematurely, meaning that the destination was found. # Find the path from the origin to the destination by traversing the hierarchy # of room parents, starting with the current room. results : list [ str ] = [] while currentRoomObj is not origin : currentRoomObj , direction = parents [ currentRoomObj ] if ( currentRoomObj . vnum in LEAD_BEFORE_ENTERING_VNUMS and currentRoomObj . exits [ direction ] . to not in LEAD_BEFORE_ENTERING_VNUMS and currentRoomObj is not origin ): results . append ( \"ride\" ) results . append ( direction ) if currentRoomObj . exits [ direction ] . to in LEAD_BEFORE_ENTERING_VNUMS and ( currentRoomObj . vnum not in LEAD_BEFORE_ENTERING_VNUMS or currentRoomObj is origin ): results . append ( \"lead\" ) if \"door\" in currentRoomObj . exits [ direction ] . exitFlags : results . append ( f \"open { currentRoomObj . exits [ direction ] . door if currentRoomObj . exits [ direction ] . door else 'exit' } \" + f \" { direction } \" ) return results def getRoomFromLabel ( self , text : str ) -> Union [ Room , None ]: text = text . strip () . lower () vnum : str if not text : self . output ( \"No label or room vnum specified.\" ) elif text . isdecimal (): # The text is a vnum. vnum = text if vnum in self . rooms : return self . rooms [ vnum ] self . output ( f \"No room with vnum { vnum } .\" ) elif text in self . labels : # The text is an existing label. vnum = self . labels [ text ] if vnum in self . rooms : return self . rooms [ vnum ] self . output ( f \" { text } is set to vnum { vnum } , but there is no room with that vnum\" ) else : # The text is *not* an existing label. similarLabels : list [ str ] = sorted ( self . labels , key = lambda l : fuzz . ratio ( l , text ), reverse = True ) self . output ( f \"Unknown label. Did you mean { ', ' . join ( similarLabels [ 0 : 4 ]) } ?\" ) return None def crawl ( self , start : str , borders : Iterable [ str ]) -> tuple [ str , ... ]: explored : set [ str ] = set () unexplored : set [ str ] = set () unexplored . add ( start ) while unexplored : vnum = unexplored . pop () for _ , exitObj in self . rooms [ vnum ] . exits . items (): if exitObj . to not in explored and exitObj . to not in borders and exitObj . to . isdigit (): unexplored . add ( exitObj . to ) explored . add ( vnum ) return tuple ( explored ) def overlapping ( self ) -> tuple [ tuple [ COORDINATES_TYPE , tuple [ str , ... ]], ... ]: results : dict [ COORDINATES_TYPE , list [ str ]] = {} for vnum , room in self . rooms . items (): results . setdefault ( room . coordinates , []) . append ( vnum ) return tuple (( coordinates , tuple ( vnums )) for coordinates , vnums in results . items () if len ( vnums ) > 1 )","title":"World"},{"location":"api/world/#mapper.world.World.GUIRefresh","text":"Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\world.py def GUIRefresh ( self ) -> None : \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_guiRefresh\" ,))","title":"GUIRefresh()"},{"location":"api/world/#mapper.world.World.createSpeedWalk","text":"Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\world.py def createSpeedWalk ( self , directionsList : MutableSequence [ str ]) -> str : \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer : Sequence [ str ]) -> list [ str ]: speedWalkDirs : list [ str ] = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup : int = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections : int = len ([ d for d in directionsList if d in DIRECTIONS ]) result : list [ str ] = [] directionsBuffer : list [ str ] = [] while directionsList : item : str = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer . clear () result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \"","title":"createSpeedWalk()"},{"location":"api/world/#mapper.world.World.getNeighborsFromCoordinates","text":"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromCoordinates ( self , start : Sequence [ int ], radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromCoordinates()"},{"location":"api/world/#mapper.world.World.getNeighborsFromRoom","text":"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py def getNeighborsFromRoom ( self , start : Room , radius : Sequence [ int ] ) -> Generator [ tuple [ str , Room , int , int , int ], None , None ]: \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" x , y , z = start . x , start . y , start . z radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromRoom()"},{"location":"api/world/#mapper.world.World.getNewExit","text":"Creates a new exit object for a given direction. Parameters: Name Type Description Default direction str The direction of movement (north, east, south, west, up, down). required to str The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. 'undefined' vnum Optional[str] The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. None Returns: Type Description Exit The new exit object. Source code in mapper\\world.py def getNewExit ( self , direction : str , to : str = \"undefined\" , vnum : Optional [ str ] = None ) -> Exit : \"\"\" Creates a new exit object for a given direction. Args: direction: The direction of movement (north, east, south, west, up, down). to: The destination that the exit points to. Can be a vnum, 'undefined', or 'death'. vnum: The vnum of the room that the exit belongs to, defaults to self.currentRoom.vnum. Returns: The new exit object. \"\"\" newExit : Exit = Exit () newExit . direction = direction newExit . to = to newExit . vnum = self . currentRoom . vnum if vnum is None else vnum return newExit","title":"getNewExit()"},{"location":"api/world/#mapper.world.World.isBidirectional","text":"Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\world.py def isBidirectional ( self , exitObj : Exit ) -> bool : \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest : Room = self . rooms [ exitObj . to ] except KeyError : return False revdir : str = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False","title":"isBidirectional()"},{"location":"api/world/#mapper.world.World.pathFind","text":"Find the path Source code in mapper\\world.py def pathFind ( self , origin : Optional [ Room ] = None , destination : Optional [ str ] = None , flags : Optional [ Sequence [ str ]] = None , ) -> list [ str ]: \"\"\"Find the path\"\"\" if origin is None : if self . currentRoom . vnum == \"-1\" : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) return [] origin = self . currentRoom destinationRoom : Union [ Room , None ] = self . getRoomFromLabel ( str ( destination )) if destinationRoom is None : return [] elif destinationRoom is origin : self . output ( \"You are already there!\" ) return [] avoidTerrains : frozenset [ str ] if flags : avoidTerrains = frozenset ( terrain for terrain in TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums : frozenset [ str ] = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc : Callable [[ Room ], bool ] = lambda currentRoomObj : ( # NOQA: E731 currentRoomObj is destinationRoom ) exitIgnoreFunc : Callable [[ Exit ], bool ] = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc : Callable [[ Exit , Room ], int ] = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc : None = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"pathFind()"},{"location":"api/roomdata/database/","text":"Module mapper.roomdata.database \u00b6 Function dumpLabels ( labels ) \u00b6 Saves the labels database to disk. Parameters: Name Type Description Default labels Mapping[str, str] The labels database to be saved. required Source code in mapper\\roomdata\\database.py def dumpLabels ( labels : Mapping [ str , str ]) -> None : \"\"\" Saves the labels database to disk. Args: labels: The labels database to be saved. \"\"\" output : dict [ str , Any ] = { \"schema_version\" : LABELS_SCHEMA_VERSION , \"labels\" : dict ( labels ), # Shallow copy. } _dump ( output , LABELS_FILE_PATH , getSchemaPath ( LABELS_FILE_PATH , LABELS_SCHEMA_VERSION )) Function dumpRooms ( rooms ) \u00b6 Saves the rooms database to disk. Parameters: Name Type Description Default rooms Mapping[str, Mapping[str, Any]] The rooms database to be saved. required Source code in mapper\\roomdata\\database.py def dumpRooms ( rooms : Mapping [ str , Mapping [ str , Any ]]) -> None : \"\"\" Saves the rooms database to disk. Args: rooms: The rooms database to be saved. \"\"\" output : dict [ str , Any ] = dict ( rooms ) # Shallow copy. output [ \"schema_version\" ] = MAP_SCHEMA_VERSION _dump ( output , MAP_FILE_PATH , getSchemaPath ( MAP_FILE_PATH , MAP_SCHEMA_VERSION )) Function getSchemaPath ( databasePath , schemaVersion ) \u00b6 Determines the schema file path from a schema version. Parameters: Name Type Description Default databasePath str The path of the database file. required schemaVersion int The schema version. required Returns: Type Description str The schema file path. Source code in mapper\\roomdata\\database.py def getSchemaPath ( databasePath : str , schemaVersion : int ) -> str : \"\"\" Determines the schema file path from a schema version. Args: databasePath: The path of the database file. schemaVersion: The schema version. Returns: The schema file path. \"\"\" databasePath = removeSuffix ( databasePath , \".sample\" ) return \" {} _v {ver}{} .schema\" . format ( * os . path . splitext ( databasePath ), ver = schemaVersion ) Function loadLabels () \u00b6 Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: Type Description Union[tuple[str, None, int], tuple[None, dict[str, str], int]] An error message or None, the labels database or None, and the schema version. Source code in mapper\\roomdata\\database.py def loadLabels () -> Union [ tuple [ str , None , int ], tuple [ None , dict [ str , str ], int ]]: \"\"\" Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: An error message or None, the labels database or None, and the schema version. \"\"\" errorMessages : list [ str ] = [] labels : dict [ str , str ] = {} for path in ( SAMPLE_LABELS_FILE_PATH , LABELS_FILE_PATH ): if not os . path . exists ( path ) or os . path . isdir ( path ): continue errors , result , schemaVersion = _load ( path ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } labels: { errors } \" ) else : labels . update ( result if schemaVersion < 1 else result [ \"labels\" ]) if labels : return None , labels , schemaVersion else : return \" \\n \" . join ( errorMessages ), None , 0 Function loadRooms () \u00b6 Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: Type Description Union[tuple[str, None, int], tuple[None, dict[str, dict[str, Any]], int]] An error message or None, the rooms database or None, and the schema version. Source code in mapper\\roomdata\\database.py def loadRooms () -> Union [ tuple [ str , None , int ], tuple [ None , dict [ str , dict [ str , Any ]], int ]]: \"\"\" Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: An error message or None, the rooms database or None, and the schema version. \"\"\" errorMessages : list [ str ] = [] for path in ( MAP_FILE_PATH , SAMPLE_MAP_FILE_PATH ): errors , result , schemaVersion = _load ( path ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } map: { errors } \" ) else : return None , result , schemaVersion return \" \\n \" . join ( errorMessages ), None , 0","title":"database.py"},{"location":"api/roomdata/database/#mapper.roomdata.database","text":"","title":"database"},{"location":"api/roomdata/database/#mapper.roomdata.database.dumpLabels","text":"Saves the labels database to disk. Parameters: Name Type Description Default labels Mapping[str, str] The labels database to be saved. required Source code in mapper\\roomdata\\database.py def dumpLabels ( labels : Mapping [ str , str ]) -> None : \"\"\" Saves the labels database to disk. Args: labels: The labels database to be saved. \"\"\" output : dict [ str , Any ] = { \"schema_version\" : LABELS_SCHEMA_VERSION , \"labels\" : dict ( labels ), # Shallow copy. } _dump ( output , LABELS_FILE_PATH , getSchemaPath ( LABELS_FILE_PATH , LABELS_SCHEMA_VERSION ))","title":"dumpLabels()"},{"location":"api/roomdata/database/#mapper.roomdata.database.dumpRooms","text":"Saves the rooms database to disk. Parameters: Name Type Description Default rooms Mapping[str, Mapping[str, Any]] The rooms database to be saved. required Source code in mapper\\roomdata\\database.py def dumpRooms ( rooms : Mapping [ str , Mapping [ str , Any ]]) -> None : \"\"\" Saves the rooms database to disk. Args: rooms: The rooms database to be saved. \"\"\" output : dict [ str , Any ] = dict ( rooms ) # Shallow copy. output [ \"schema_version\" ] = MAP_SCHEMA_VERSION _dump ( output , MAP_FILE_PATH , getSchemaPath ( MAP_FILE_PATH , MAP_SCHEMA_VERSION ))","title":"dumpRooms()"},{"location":"api/roomdata/database/#mapper.roomdata.database.getSchemaPath","text":"Determines the schema file path from a schema version. Parameters: Name Type Description Default databasePath str The path of the database file. required schemaVersion int The schema version. required Returns: Type Description str The schema file path. Source code in mapper\\roomdata\\database.py def getSchemaPath ( databasePath : str , schemaVersion : int ) -> str : \"\"\" Determines the schema file path from a schema version. Args: databasePath: The path of the database file. schemaVersion: The schema version. Returns: The schema file path. \"\"\" databasePath = removeSuffix ( databasePath , \".sample\" ) return \" {} _v {ver}{} .schema\" . format ( * os . path . splitext ( databasePath ), ver = schemaVersion )","title":"getSchemaPath()"},{"location":"api/roomdata/database/#mapper.roomdata.database.loadLabels","text":"Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: Type Description Union[tuple[str, None, int], tuple[None, dict[str, str], int]] An error message or None, the labels database or None, and the schema version. Source code in mapper\\roomdata\\database.py def loadLabels () -> Union [ tuple [ str , None , int ], tuple [ None , dict [ str , str ], int ]]: \"\"\" Loads the labels database into memory. The default label definitions are first loaded, then the user's label definitions are merged in. Returns: An error message or None, the labels database or None, and the schema version. \"\"\" errorMessages : list [ str ] = [] labels : dict [ str , str ] = {} for path in ( SAMPLE_LABELS_FILE_PATH , LABELS_FILE_PATH ): if not os . path . exists ( path ) or os . path . isdir ( path ): continue errors , result , schemaVersion = _load ( path ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } labels: { errors } \" ) else : labels . update ( result if schemaVersion < 1 else result [ \"labels\" ]) if labels : return None , labels , schemaVersion else : return \" \\n \" . join ( errorMessages ), None , 0","title":"loadLabels()"},{"location":"api/roomdata/database/#mapper.roomdata.database.loadRooms","text":"Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: Type Description Union[tuple[str, None, int], tuple[None, dict[str, dict[str, Any]], int]] An error message or None, the rooms database or None, and the schema version. Source code in mapper\\roomdata\\database.py def loadRooms () -> Union [ tuple [ str , None , int ], tuple [ None , dict [ str , dict [ str , Any ]], int ]]: \"\"\" Loads the rooms database into memory. An attempt to load the user's database is made first, otherwise the sample database is loaded. Returns: An error message or None, the rooms database or None, and the schema version. \"\"\" errorMessages : list [ str ] = [] for path in ( MAP_FILE_PATH , SAMPLE_MAP_FILE_PATH ): errors , result , schemaVersion = _load ( path ) if result is None : dataType : str = \"sample\" if path . endswith ( \"sample\" ) else \"user\" errorMessages . append ( f \"While loading { dataType } map: { errors } \" ) else : return None , result , schemaVersion return \" \\n \" . join ( errorMessages ), None , 0","title":"loadRooms()"},{"location":"api/roomdata/objects/","text":"Module mapper.roomdata.objects \u00b6 Class Exit dataclass \u00b6 An exit. Source code in mapper\\roomdata\\objects.py @dataclass ( ** DATACLASS_KWARGS ) class Exit ( object ): \"\"\" An exit. \"\"\" _direction : str = \"\" vnum : Union [ str , None ] = None to : str = \"undefined\" exitFlags : set [ str ] = field ( default_factory = set ) door : str = \"\" doorFlags : set [ str ] = field ( default_factory = set ) def __post_init__ ( self ) -> None : \"\"\"Called after __init__.\"\"\" self . exitFlags . add ( \"exit\" ) def __str__ ( self ) -> str : return self . _direction @property def direction ( self ) -> str : \"\"\"The direction of movement.\"\"\" if not self . _direction : raise ValueError ( \"Direction undefined.\" ) return self . _direction @direction . setter def direction ( self , value : str ) -> None : if value not in DIRECTIONS : raise ValueError ( f \"Direction must be one of { DIRECTIONS } .\" ) self . _direction = value Attribute direction : str property writable \u00b6 The direction of movement. Class Room dataclass \u00b6 A room. Source code in mapper\\roomdata\\objects.py @dataclass ( ** DATACLASS_KWARGS ) class Room ( object ): \"\"\" A room. \"\"\" # Cost needs to be defined first for correct sorting. cost : float = field ( init = False , repr = False , default = TERRAIN_COSTS [ \"undefined\" ]) vnum : str = \"-1\" serverID : str = \"0\" # Server room IDs are in range 1-0x7fffffff. area : str = \"\" name : str = \"\" desc : str = \"\" dynamicDesc : str = \"\" note : str = \"\" terrain : str = \"undefined\" light : str = \"undefined\" align : str = \"undefined\" portable : str = \"undefined\" ridable : str = \"undefined\" sundeath : str = \"undefined\" avoid : bool = False mobFlags : set [ str ] = field ( default_factory = set ) loadFlags : set [ str ] = field ( default_factory = set ) x : int = 0 y : int = 0 z : int = 0 exits : dict [ str , Exit ] = field ( default_factory = dict ) def __str__ ( self ) -> str : return self . vnum def __lt__ ( self , other : Room ) -> bool : # Unlike in Python 2 where most objects are sortable by default, our # Room class isn't automatically sortable in Python 3. # If we don't override this method, the path finder will throw an # exception in Python 3 because heapq.heappush requires that any object # passed to it be sortable. # We'll return False because we want heapq.heappush to sort the tuples # of movement cost and room object by the first item in the tuple (room cost), # and the order of rooms with the same movement cost is irrelevant. # Note that this is much faster than passing the 'order' keyword to the dataclass decorator. return False @property def coordinates ( self ) -> COORDINATES_TYPE : \"\"\"The room coordinates.\"\"\" return ( self . x , self . y , self . z ) @coordinates . setter def coordinates ( self , value : Sequence [ int ]) -> None : if len ( value ) != 3 : raise ValueError ( \"Expected sequence of length 3.\" ) self . x , self . y , self . z = value @property def sortedExits ( self ) -> list [ tuple [ str , Exit ]]: \"\"\"The room exits, sorted by direction.\"\"\" return sorted ( self . exits . items (), key = lambda item : ( DIRECTIONS . index ( item [ 0 ]) if item [ 0 ] in DIRECTIONS else len ( DIRECTIONS )), ) @property def info ( self ) -> str : \"\"\"A summery of the room info.\"\"\" output : list [ str ] = [] output . append ( f \"vnum: ' { self . vnum } '\" ) output . append ( f \"Name: ' { self . name } '\" ) output . append ( f \"Server ID: ' { self . serverID } '\" ) output . append ( \"Description:\" ) output . append ( \"-\" * 5 ) output . extend ( self . desc . splitlines ()) output . append ( \"-\" * 5 ) output . append ( \"Dynamic Desc:\" ) output . append ( \"-\" * 5 ) output . extend ( self . dynamicDesc . splitlines ()) output . append ( \"-\" * 5 ) output . append ( f \"Note: ' { self . note } '\" ) output . append ( f \"Area: ' { self . area } '\" ) output . append ( f \"Terrain: ' { self . terrain } '\" ) output . append ( f \"Cost: ' { self . cost } '\" ) output . append ( f \"Light: ' { self . light } '\" ) output . append ( f \"Align: ' { self . align } '\" ) output . append ( f \"Portable: ' { self . portable } '\" ) output . append ( f \"Ridable: ' { self . ridable } '\" ) output . append ( f \"Sundeath: ' { self . sundeath } '\" ) output . append ( f \"Mob Flags: ' { ', ' . join ( self . mobFlags ) } '\" ) output . append ( f \"Load Flags: ' { ', ' . join ( self . loadFlags ) } '\" ) output . append ( f \"Coordinates (X, Y, Z): ' { self . coordinates } '\" ) output . append ( \"Exits:\" ) for direction , exitObj in self . sortedExits : output . append ( \"-\" * 5 ) output . append ( f \"Direction: ' { direction } '\" ) output . append ( f \"To: ' { exitObj . to } '\" ) output . append ( f \"Exit Flags: ' { ', ' . join ( exitObj . exitFlags ) } '\" ) output . append ( f \"Door Name: ' { exitObj . door } '\" ) output . append ( f \"Door Flags: ' { ', ' . join ( exitObj . doorFlags ) } '\" ) return \" \\n \" . join ( output ) def calculateCost ( self ) -> None : \"\"\"Calculates the movement cost for the room.\"\"\" self . cost = TERRAIN_COSTS [ self . terrain ] if self . avoid or AVOID_DYNAMIC_DESC_REGEX . search ( self . dynamicDesc ): self . cost += 1000.0 if self . ridable == \"not_ridable\" : self . cost += 5.0 def manhattanDistance ( self , other : Room ) -> int : \"\"\" Returns the Manhattan distance between this room and another. Note: https://en.wikipedia.org/wiki/Taxicab_geometry Args: other: The other room to calculate the Manhattan distance between. Returns: The Manhattan distance between this room and the other. \"\"\" return abs ( other . x - self . x ) + abs ( other . y - self . y ) + abs ( other . z - self . z ) def clockPositionTo ( self , other : Room ) -> str : \"\"\" Returns the clock position of another room from this one. Note: https://en.wikipedia.org/wiki/Clock_position Args: other: The other room to calculate the clock position of. Returns: The clock position of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : position = int ( round (( 90 - delta . angle_degrees + 360 ) % 360 / 30 )) or 12 return f \" { position } o'clock\" def directionTo ( self , other : Room ) -> str : \"\"\" Returns the compass direction of another room from this one. Note: https://en.wikipedia.org/wiki/Points_of_the_compass Args: other: The other room to calculate the compass direction of. Returns: The compass direction of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : return COMPASS_DIRECTIONS [ round (( 90 - delta . angle_degrees + 360 ) % 360 / 45 ) % 8 ] def isOrphan ( self ) -> bool : \"\"\" Determines if room is an orphan, based on the existence of undefined exits. Returns: True if room contains no exits or only undefined exits, False otherwise. \"\"\" return all ( exitObj . to == \"undefined\" for exitObj in self . exits . values ()) def hasUndefinedExits ( self ) -> bool : \"\"\" Determines if room contains one or more undefined exits. Returns: True if room contains at least one undefined exit, False otherwise. \"\"\" return any ( exitObj . to == \"undefined\" for exitObj in self . exits . values ()) Attribute coordinates : COORDINATES_TYPE property writable \u00b6 The room coordinates. Attribute info : str property readonly \u00b6 A summery of the room info. Attribute sortedExits : list [ tuple [ str , Exit ]] property readonly \u00b6 The room exits, sorted by direction. Method calculateCost ( self ) \u00b6 Calculates the movement cost for the room. Source code in mapper\\roomdata\\objects.py def calculateCost ( self ) -> None : \"\"\"Calculates the movement cost for the room.\"\"\" self . cost = TERRAIN_COSTS [ self . terrain ] if self . avoid or AVOID_DYNAMIC_DESC_REGEX . search ( self . dynamicDesc ): self . cost += 1000.0 if self . ridable == \"not_ridable\" : self . cost += 5.0 Method clockPositionTo ( self , other ) \u00b6 Returns the clock position of another room from this one. Note https://en.wikipedia.org/wiki/Clock_position Parameters: Name Type Description Default other Room The other room to calculate the clock position of. required Returns: Type Description str The clock position of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def clockPositionTo ( self , other : Room ) -> str : \"\"\" Returns the clock position of another room from this one. Note: https://en.wikipedia.org/wiki/Clock_position Args: other: The other room to calculate the clock position of. Returns: The clock position of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : position = int ( round (( 90 - delta . angle_degrees + 360 ) % 360 / 30 )) or 12 return f \" { position } o'clock\" Method directionTo ( self , other ) \u00b6 Returns the compass direction of another room from this one. Note https://en.wikipedia.org/wiki/Points_of_the_compass Parameters: Name Type Description Default other Room The other room to calculate the compass direction of. required Returns: Type Description str The compass direction of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def directionTo ( self , other : Room ) -> str : \"\"\" Returns the compass direction of another room from this one. Note: https://en.wikipedia.org/wiki/Points_of_the_compass Args: other: The other room to calculate the compass direction of. Returns: The compass direction of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : return COMPASS_DIRECTIONS [ round (( 90 - delta . angle_degrees + 360 ) % 360 / 45 ) % 8 ] Method hasUndefinedExits ( self ) \u00b6 Determines if room contains one or more undefined exits. Returns: Type Description bool True if room contains at least one undefined exit, False otherwise. Source code in mapper\\roomdata\\objects.py def hasUndefinedExits ( self ) -> bool : \"\"\" Determines if room contains one or more undefined exits. Returns: True if room contains at least one undefined exit, False otherwise. \"\"\" return any ( exitObj . to == \"undefined\" for exitObj in self . exits . values ()) Method isOrphan ( self ) \u00b6 Determines if room is an orphan, based on the existence of undefined exits. Returns: Type Description bool True if room contains no exits or only undefined exits, False otherwise. Source code in mapper\\roomdata\\objects.py def isOrphan ( self ) -> bool : \"\"\" Determines if room is an orphan, based on the existence of undefined exits. Returns: True if room contains no exits or only undefined exits, False otherwise. \"\"\" return all ( exitObj . to == \"undefined\" for exitObj in self . exits . values ()) Method manhattanDistance ( self , other ) \u00b6 Returns the Manhattan distance between this room and another. Note https://en.wikipedia.org/wiki/Taxicab_geometry Parameters: Name Type Description Default other Room The other room to calculate the Manhattan distance between. required Returns: Type Description int The Manhattan distance between this room and the other. Source code in mapper\\roomdata\\objects.py def manhattanDistance ( self , other : Room ) -> int : \"\"\" Returns the Manhattan distance between this room and another. Note: https://en.wikipedia.org/wiki/Taxicab_geometry Args: other: The other room to calculate the Manhattan distance between. Returns: The Manhattan distance between this room and the other. \"\"\" return abs ( other . x - self . x ) + abs ( other . y - self . y ) + abs ( other . z - self . z )","title":"objects.py"},{"location":"api/roomdata/objects/#mapper.roomdata.objects","text":"","title":"objects"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Exit","text":"An exit. Source code in mapper\\roomdata\\objects.py @dataclass ( ** DATACLASS_KWARGS ) class Exit ( object ): \"\"\" An exit. \"\"\" _direction : str = \"\" vnum : Union [ str , None ] = None to : str = \"undefined\" exitFlags : set [ str ] = field ( default_factory = set ) door : str = \"\" doorFlags : set [ str ] = field ( default_factory = set ) def __post_init__ ( self ) -> None : \"\"\"Called after __init__.\"\"\" self . exitFlags . add ( \"exit\" ) def __str__ ( self ) -> str : return self . _direction @property def direction ( self ) -> str : \"\"\"The direction of movement.\"\"\" if not self . _direction : raise ValueError ( \"Direction undefined.\" ) return self . _direction @direction . setter def direction ( self , value : str ) -> None : if value not in DIRECTIONS : raise ValueError ( f \"Direction must be one of { DIRECTIONS } .\" ) self . _direction = value","title":"Exit"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Exit.direction","text":"The direction of movement.","title":"direction"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room","text":"A room. Source code in mapper\\roomdata\\objects.py @dataclass ( ** DATACLASS_KWARGS ) class Room ( object ): \"\"\" A room. \"\"\" # Cost needs to be defined first for correct sorting. cost : float = field ( init = False , repr = False , default = TERRAIN_COSTS [ \"undefined\" ]) vnum : str = \"-1\" serverID : str = \"0\" # Server room IDs are in range 1-0x7fffffff. area : str = \"\" name : str = \"\" desc : str = \"\" dynamicDesc : str = \"\" note : str = \"\" terrain : str = \"undefined\" light : str = \"undefined\" align : str = \"undefined\" portable : str = \"undefined\" ridable : str = \"undefined\" sundeath : str = \"undefined\" avoid : bool = False mobFlags : set [ str ] = field ( default_factory = set ) loadFlags : set [ str ] = field ( default_factory = set ) x : int = 0 y : int = 0 z : int = 0 exits : dict [ str , Exit ] = field ( default_factory = dict ) def __str__ ( self ) -> str : return self . vnum def __lt__ ( self , other : Room ) -> bool : # Unlike in Python 2 where most objects are sortable by default, our # Room class isn't automatically sortable in Python 3. # If we don't override this method, the path finder will throw an # exception in Python 3 because heapq.heappush requires that any object # passed to it be sortable. # We'll return False because we want heapq.heappush to sort the tuples # of movement cost and room object by the first item in the tuple (room cost), # and the order of rooms with the same movement cost is irrelevant. # Note that this is much faster than passing the 'order' keyword to the dataclass decorator. return False @property def coordinates ( self ) -> COORDINATES_TYPE : \"\"\"The room coordinates.\"\"\" return ( self . x , self . y , self . z ) @coordinates . setter def coordinates ( self , value : Sequence [ int ]) -> None : if len ( value ) != 3 : raise ValueError ( \"Expected sequence of length 3.\" ) self . x , self . y , self . z = value @property def sortedExits ( self ) -> list [ tuple [ str , Exit ]]: \"\"\"The room exits, sorted by direction.\"\"\" return sorted ( self . exits . items (), key = lambda item : ( DIRECTIONS . index ( item [ 0 ]) if item [ 0 ] in DIRECTIONS else len ( DIRECTIONS )), ) @property def info ( self ) -> str : \"\"\"A summery of the room info.\"\"\" output : list [ str ] = [] output . append ( f \"vnum: ' { self . vnum } '\" ) output . append ( f \"Name: ' { self . name } '\" ) output . append ( f \"Server ID: ' { self . serverID } '\" ) output . append ( \"Description:\" ) output . append ( \"-\" * 5 ) output . extend ( self . desc . splitlines ()) output . append ( \"-\" * 5 ) output . append ( \"Dynamic Desc:\" ) output . append ( \"-\" * 5 ) output . extend ( self . dynamicDesc . splitlines ()) output . append ( \"-\" * 5 ) output . append ( f \"Note: ' { self . note } '\" ) output . append ( f \"Area: ' { self . area } '\" ) output . append ( f \"Terrain: ' { self . terrain } '\" ) output . append ( f \"Cost: ' { self . cost } '\" ) output . append ( f \"Light: ' { self . light } '\" ) output . append ( f \"Align: ' { self . align } '\" ) output . append ( f \"Portable: ' { self . portable } '\" ) output . append ( f \"Ridable: ' { self . ridable } '\" ) output . append ( f \"Sundeath: ' { self . sundeath } '\" ) output . append ( f \"Mob Flags: ' { ', ' . join ( self . mobFlags ) } '\" ) output . append ( f \"Load Flags: ' { ', ' . join ( self . loadFlags ) } '\" ) output . append ( f \"Coordinates (X, Y, Z): ' { self . coordinates } '\" ) output . append ( \"Exits:\" ) for direction , exitObj in self . sortedExits : output . append ( \"-\" * 5 ) output . append ( f \"Direction: ' { direction } '\" ) output . append ( f \"To: ' { exitObj . to } '\" ) output . append ( f \"Exit Flags: ' { ', ' . join ( exitObj . exitFlags ) } '\" ) output . append ( f \"Door Name: ' { exitObj . door } '\" ) output . append ( f \"Door Flags: ' { ', ' . join ( exitObj . doorFlags ) } '\" ) return \" \\n \" . join ( output ) def calculateCost ( self ) -> None : \"\"\"Calculates the movement cost for the room.\"\"\" self . cost = TERRAIN_COSTS [ self . terrain ] if self . avoid or AVOID_DYNAMIC_DESC_REGEX . search ( self . dynamicDesc ): self . cost += 1000.0 if self . ridable == \"not_ridable\" : self . cost += 5.0 def manhattanDistance ( self , other : Room ) -> int : \"\"\" Returns the Manhattan distance between this room and another. Note: https://en.wikipedia.org/wiki/Taxicab_geometry Args: other: The other room to calculate the Manhattan distance between. Returns: The Manhattan distance between this room and the other. \"\"\" return abs ( other . x - self . x ) + abs ( other . y - self . y ) + abs ( other . z - self . z ) def clockPositionTo ( self , other : Room ) -> str : \"\"\" Returns the clock position of another room from this one. Note: https://en.wikipedia.org/wiki/Clock_position Args: other: The other room to calculate the clock position of. Returns: The clock position of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : position = int ( round (( 90 - delta . angle_degrees + 360 ) % 360 / 30 )) or 12 return f \" { position } o'clock\" def directionTo ( self , other : Room ) -> str : \"\"\" Returns the compass direction of another room from this one. Note: https://en.wikipedia.org/wiki/Points_of_the_compass Args: other: The other room to calculate the compass direction of. Returns: The compass direction of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : return COMPASS_DIRECTIONS [ round (( 90 - delta . angle_degrees + 360 ) % 360 / 45 ) % 8 ] def isOrphan ( self ) -> bool : \"\"\" Determines if room is an orphan, based on the existence of undefined exits. Returns: True if room contains no exits or only undefined exits, False otherwise. \"\"\" return all ( exitObj . to == \"undefined\" for exitObj in self . exits . values ()) def hasUndefinedExits ( self ) -> bool : \"\"\" Determines if room contains one or more undefined exits. Returns: True if room contains at least one undefined exit, False otherwise. \"\"\" return any ( exitObj . to == \"undefined\" for exitObj in self . exits . values ())","title":"Room"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.coordinates","text":"The room coordinates.","title":"coordinates"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.info","text":"A summery of the room info.","title":"info"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.sortedExits","text":"The room exits, sorted by direction.","title":"sortedExits"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.calculateCost","text":"Calculates the movement cost for the room. Source code in mapper\\roomdata\\objects.py def calculateCost ( self ) -> None : \"\"\"Calculates the movement cost for the room.\"\"\" self . cost = TERRAIN_COSTS [ self . terrain ] if self . avoid or AVOID_DYNAMIC_DESC_REGEX . search ( self . dynamicDesc ): self . cost += 1000.0 if self . ridable == \"not_ridable\" : self . cost += 5.0","title":"calculateCost()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.clockPositionTo","text":"Returns the clock position of another room from this one. Note https://en.wikipedia.org/wiki/Clock_position Parameters: Name Type Description Default other Room The other room to calculate the clock position of. required Returns: Type Description str The clock position of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def clockPositionTo ( self , other : Room ) -> str : \"\"\" Returns the clock position of another room from this one. Note: https://en.wikipedia.org/wiki/Clock_position Args: other: The other room to calculate the clock position of. Returns: The clock position of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : position = int ( round (( 90 - delta . angle_degrees + 360 ) % 360 / 30 )) or 12 return f \" { position } o'clock\"","title":"clockPositionTo()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.directionTo","text":"Returns the compass direction of another room from this one. Note https://en.wikipedia.org/wiki/Points_of_the_compass Parameters: Name Type Description Default other Room The other room to calculate the compass direction of. required Returns: Type Description str The compass direction of the other room, relative to this one. Source code in mapper\\roomdata\\objects.py def directionTo ( self , other : Room ) -> str : \"\"\" Returns the compass direction of another room from this one. Note: https://en.wikipedia.org/wiki/Points_of_the_compass Args: other: The other room to calculate the compass direction of. Returns: The compass direction of the other room, relative to this one. \"\"\" delta = Vec2d ( other . x , other . y ) - ( self . x , self . y ) if self . vnum == other . vnum : return \"here\" elif delta . get_length_sqrd () == 0 : return \"same X-Y\" else : return COMPASS_DIRECTIONS [ round (( 90 - delta . angle_degrees + 360 ) % 360 / 45 ) % 8 ]","title":"directionTo()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.hasUndefinedExits","text":"Determines if room contains one or more undefined exits. Returns: Type Description bool True if room contains at least one undefined exit, False otherwise. Source code in mapper\\roomdata\\objects.py def hasUndefinedExits ( self ) -> bool : \"\"\" Determines if room contains one or more undefined exits. Returns: True if room contains at least one undefined exit, False otherwise. \"\"\" return any ( exitObj . to == \"undefined\" for exitObj in self . exits . values ())","title":"hasUndefinedExits()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.isOrphan","text":"Determines if room is an orphan, based on the existence of undefined exits. Returns: Type Description bool True if room contains no exits or only undefined exits, False otherwise. Source code in mapper\\roomdata\\objects.py def isOrphan ( self ) -> bool : \"\"\" Determines if room is an orphan, based on the existence of undefined exits. Returns: True if room contains no exits or only undefined exits, False otherwise. \"\"\" return all ( exitObj . to == \"undefined\" for exitObj in self . exits . values ())","title":"isOrphan()"},{"location":"api/roomdata/objects/#mapper.roomdata.objects.Room.manhattanDistance","text":"Returns the Manhattan distance between this room and another. Note https://en.wikipedia.org/wiki/Taxicab_geometry Parameters: Name Type Description Default other Room The other room to calculate the Manhattan distance between. required Returns: Type Description int The Manhattan distance between this room and the other. Source code in mapper\\roomdata\\objects.py def manhattanDistance ( self , other : Room ) -> int : \"\"\" Returns the Manhattan distance between this room and another. Note: https://en.wikipedia.org/wiki/Taxicab_geometry Args: other: The other room to calculate the Manhattan distance between. Returns: The Manhattan distance between this room and the other. \"\"\" return abs ( other . x - self . x ) + abs ( other . y - self . y ) + abs ( other . z - self . z )","title":"manhattanDistance()"},{"location":"api/sockets/bufferedsocket/","text":"Module mapper.sockets.bufferedsocket \u00b6 Class BufferedSocket( BufferedSocket ) \u00b6 Source code in mapper\\sockets\\bufferedsocket.py class BufferedSocket ( socketutils . BufferedSocket ): _recv_lock : AbstractContextManager [ None ] _send_lock : AbstractContextManager [ None ] def __init__ ( self , sock : Union [ socket . socket , FakeSocket ], * args : Any , encrypt : bool = False , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: sock: The connected socket to be wrapped. *args: Positional arguments to be passed to the parent constructor. encrypt: True if the socket should be wrapped in an [SSL context][1], False otherwise. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> **kwargs: Key-word only arguments to be passed to the parent constructor. Additional key-word only arguments will be passed to the [wrapSSL][mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL] method. \"\"\" parentExtraArgs : tuple [ str , ... ] = ( \"timeout\" , \"maxsize\" , \"recvsize\" ) parentKWArgs : dict [ str , Any ] = { arg : kwargs . pop ( arg ) for arg in parentExtraArgs if arg in kwargs } super () . __init__ ( cast ( socket . socket , sock ), * args , ** parentKWArgs ) if encrypt and isinstance ( self . sock , socket . socket ): self . sock = self . wrapSSL ( self . sock , ** kwargs ) def wrapSSL ( self , sock : socket . socket , ** kwargs : Any ) -> ssl . SSLSocket : \"\"\" Wraps a socket in an SSL context. Args: sock: The unencrypted socket. **kwargs: Key-word only arguments to be passed to the [`SSLContext.wrap_socket`][1] method. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext.wrap_socket> Returns: The socket wrapped in an [SSL context.][1] [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> \"\"\" kwargs [ \"do_handshake_on_connect\" ] = False # Avoid race condition. with self . _recv_lock , self . _send_lock : originalTimeout : Union [ float , None ] = sock . gettimeout () sock . settimeout ( None ) try : context : ssl . SSLContext = ssl . SSLContext ( ssl . PROTOCOL_TLS_CLIENT ) context . load_verify_locations ( CERT_LOCATION ) sock = context . wrap_socket ( sock , ** kwargs ) self . doSSLHandshake ( sock ) finally : sock . settimeout ( originalTimeout ) return sock def doSSLHandshake ( self , sock : ssl . SSLSocket ) -> None : \"\"\" Performs an SSL handshake. Note: The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Args: sock: The socket to perform the handshake on. \"\"\" while True : try : sock . do_handshake () break except ssl . SSLWantReadError : select . select ([ sock ], [], []) except ssl . SSLWantWriteError : select . select ([], [ sock ], []) Attribute family inherited property readonly \u00b6 A passthrough to the wrapped socket's family. BufferedSocket supports all widely-used families, so this read-only attribute can be one of :data: socket.AF_INET for IP, :data: socket.AF_INET6 for IPv6, and :data: socket.AF_UNIX for UDS. Attribute proto inherited property readonly \u00b6 A passthrough to the wrapped socket's protocol. The proto attribute is very rarely used, so it's always 0, meaning \"the default\" protocol. Pretty much all the practical information is in :attr: ~BufferedSocket.type and :attr: ~BufferedSocket.family , so you can go back to never thinking about this. Attribute type inherited property readonly \u00b6 A passthrough to the wrapped socket's type. Valid usages should only ever see :data: socket.SOCK_STREAM . Method __init__ ( self , sock , * args , * , encrypt = False , ** kwargs ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default sock Union[socket.socket, FakeSocket] The connected socket to be wrapped. required *args Any Positional arguments to be passed to the parent constructor. () encrypt bool True if the socket should be wrapped in an SSL context , False otherwise. False **kwargs Any Key-word only arguments to be passed to the parent constructor. Additional key-word only arguments will be passed to the wrapSSL method. {} Source code in mapper\\sockets\\bufferedsocket.py def __init__ ( self , sock : Union [ socket . socket , FakeSocket ], * args : Any , encrypt : bool = False , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: sock: The connected socket to be wrapped. *args: Positional arguments to be passed to the parent constructor. encrypt: True if the socket should be wrapped in an [SSL context][1], False otherwise. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> **kwargs: Key-word only arguments to be passed to the parent constructor. Additional key-word only arguments will be passed to the [wrapSSL][mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL] method. \"\"\" parentExtraArgs : tuple [ str , ... ] = ( \"timeout\" , \"maxsize\" , \"recvsize\" ) parentKWArgs : dict [ str , Any ] = { arg : kwargs . pop ( arg ) for arg in parentExtraArgs if arg in kwargs } super () . __init__ ( cast ( socket . socket , sock ), * args , ** parentKWArgs ) if encrypt and isinstance ( self . sock , socket . socket ): self . sock = self . wrapSSL ( self . sock , ** kwargs ) Method buffer ( self , data ) inherited \u00b6 Buffer data bytes for the next send operation. Source code in mapper\\sockets\\bufferedsocket.py def buffer ( self , data ): \"Buffer *data* bytes for the next send operation.\" with self . _send_lock : self . sbuf . append ( data ) return Method close ( self ) inherited \u00b6 Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth: ~BufferedSocket.buffer , be sure to call :meth: ~BufferedSocket.flush before calling this method. After calling this method, future socket operations will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def close ( self ): \"\"\"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth:`~BufferedSocket.buffer`, be sure to call :meth:`~BufferedSocket.flush` before calling this method. After calling this method, future socket operations will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : with self . _send_lock : self . rbuf = b '' self . rbuf_unconsumed = self . rbuf self . sbuf [:] = [] self . sock . close () return Method doSSLHandshake ( self , sock ) \u00b6 Performs an SSL handshake. Note The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Parameters: Name Type Description Default sock ssl.SSLSocket The socket to perform the handshake on. required Source code in mapper\\sockets\\bufferedsocket.py def doSSLHandshake ( self , sock : ssl . SSLSocket ) -> None : \"\"\" Performs an SSL handshake. Note: The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Args: sock: The socket to perform the handshake on. \"\"\" while True : try : sock . do_handshake () break except ssl . SSLWantReadError : select . select ([ sock ], [], []) except ssl . SSLWantWriteError : select . select ([], [ sock ], []) Method fileno ( self ) inherited \u00b6 Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling recv* functions. Source code in mapper\\sockets\\bufferedsocket.py def fileno ( self ): \"\"\"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling ``recv*`` functions. \"\"\" return self . sock . fileno () Method flush ( self ) inherited \u00b6 Send the contents of the internal send buffer. Source code in mapper\\sockets\\bufferedsocket.py def flush ( self ): \"Send the contents of the internal send buffer.\" with self . _send_lock : self . send ( b '' ) return Method getpeername ( self ) inherited \u00b6 Convenience function to return the remote address to which the wrapped socket is connected. See :meth: socket.getpeername for more details. Source code in mapper\\sockets\\bufferedsocket.py def getpeername ( self ): \"\"\"Convenience function to return the remote address to which the wrapped socket is connected. See :meth:`socket.getpeername` for more details. \"\"\" return self . sock . getpeername () Method getrecvbuffer ( self ) inherited \u00b6 Returns the receive buffer bytestring (rbuf). Source code in mapper\\sockets\\bufferedsocket.py def getrecvbuffer ( self ): \"Returns the receive buffer bytestring (rbuf).\" with self . _recv_lock : return self . rbuf Method getsendbuffer ( self ) inherited \u00b6 Returns a copy of the send buffer list. Source code in mapper\\sockets\\bufferedsocket.py def getsendbuffer ( self ): \"Returns a copy of the send buffer list.\" with self . _send_lock : return b '' . join ( self . sbuf ) Method getsockname ( self ) inherited \u00b6 Convenience function to return the wrapped socket's own address. See :meth: socket.getsockname for more details. Source code in mapper\\sockets\\bufferedsocket.py def getsockname ( self ): \"\"\"Convenience function to return the wrapped socket's own address. See :meth:`socket.getsockname` for more details. \"\"\" return self . sock . getsockname () Method getsockopt ( self , level , optname , buflen = None ) inherited \u00b6 Convenience function passing through to the wrapped socket's :meth: socket.getsockopt . Source code in mapper\\sockets\\bufferedsocket.py def getsockopt ( self , level , optname , buflen = None ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.getsockopt`. \"\"\" args = ( level , optname ) if buflen is not None : args += ( buflen ,) return self . sock . getsockopt ( * args ) Method peek ( self , size , timeout = _UNSET ) inherited \u00b6 Returns size bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth: getrecvbuffer . Parameters: Name Type Description Default size int The exact number of bytes to peek at required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def peek ( self , size , timeout = _UNSET ): \"\"\"Returns *size* bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth:`getrecvbuffer`. Args: size (int): The exact number of bytes to peek at timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if len ( self . rbuf ) >= size : return self . rbuf [: size ] data = self . recv_size ( size , timeout = timeout ) self . rbuf = data + self . rbuf return data Method recv ( self , size , flags = 0 , timeout = _UNSET ) inherited \u00b6 Returns up to size bytes, using the internal buffer before performing a single :meth: socket.recv operation. Parameters: Name Type Description Default size int The maximum number of bytes to receive. required flags int Kept for API compatibility with sockets. Only the default, 0 , is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET If the operation does not complete in timeout seconds, a :exc: Timeout is raised. Much like the built-in :class: socket.socket , if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def recv ( self , size , flags = 0 , timeout = _UNSET ): \"\"\"Returns **up to** *size* bytes, using the internal buffer before performing a single :meth:`socket.recv` operation. Args: size (int): The maximum number of bytes to receive. flags (int): Kept for API compatibility with sockets. Only the default, ``0``, is valid. timeout (float): The timeout for this operation. Can be ``0`` for nonblocking and ``None`` for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the operation does not complete in *timeout* seconds, a :exc:`Timeout` is raised. Much like the built-in :class:`socket.socket`, if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported: %r \" % flags ) if len ( self . rbuf ) >= size : data , self . rbuf = self . rbuf [: size ], self . rbuf [ size :] return data if self . rbuf : ret , self . rbuf = self . rbuf , b '' return ret self . sock . settimeout ( timeout ) try : data = self . sock . recv ( self . _recvsize ) except socket . timeout : raise Timeout ( timeout ) # check the rbuf attr for more if len ( data ) > size : data , self . rbuf = data [: size ], data [ size :] return data Method recv_close ( self , timeout = _UNSET , maxsize = _UNSET ) inherited \u00b6 Receive until the connection is closed, up to maxsize bytes. If more than maxsize bytes are received, raises :exc: MessageTooLong . Source code in mapper\\sockets\\bufferedsocket.py def recv_close ( self , timeout = _UNSET , maxsize = _UNSET ): \"\"\"Receive until the connection is closed, up to *maxsize* bytes. If more than *maxsize* bytes are received, raises :exc:`MessageTooLong`. \"\"\" # recv_close works by using recv_size to request maxsize data, # and ignoring ConnectionClose, returning and clearing the # internal buffer instead. It raises an exception if # ConnectionClosed isn't raised. with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE try : recvd = self . recv_size ( maxsize + 1 , timeout ) except ConnectionClosed : ret , self . rbuf = self . rbuf , b '' else : # put extra received bytes (now in rbuf) after recvd self . rbuf = recvd + self . rbuf size_read = min ( maxsize , len ( self . rbuf )) raise MessageTooLong ( size_read ) # check receive buffer return ret Method recv_size ( self , size , timeout = _UNSET ) inherited \u00b6 Read off of the internal buffer, then off the socket, until size bytes have been read. Parameters: Name Type Description Default size int number of bytes to read before returning. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def recv_size ( self , size , timeout = _UNSET ): \"\"\"Read off of the internal buffer, then off the socket, until *size* bytes have been read. Args: size (int): number of bytes to read before returning. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout chunks = [] total_bytes = 0 try : start = time . time () self . sock . settimeout ( timeout ) nxt = self . rbuf or self . sock . recv ( self . _recvsize ) while nxt : total_bytes += len ( nxt ) if total_bytes >= size : break chunks . append ( nxt ) if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) nxt = self . sock . recv ( self . _recvsize ) else : msg = ( 'connection closed after reading %s of %s requested' ' bytes' % ( total_bytes , size )) raise ConnectionClosed ( msg ) # check recv buffer except socket . timeout : self . rbuf = b '' . join ( chunks ) msg = 'read %s of %s bytes' % ( total_bytes , size ) raise Timeout ( timeout , msg ) # check recv buffer except Exception : # received data is still buffered in the case of errors self . rbuf = b '' . join ( chunks ) raise extra_bytes = total_bytes - size if extra_bytes : last , self . rbuf = nxt [: - extra_bytes ], nxt [ - extra_bytes :] else : last , self . rbuf = nxt , b '' chunks . append ( last ) return b '' . join ( chunks ) Method recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ) inherited \u00b6 Receive until delimiter is found, maxsize bytes have been read, or timeout is exceeded. Parameters: Name Type Description Default delimiter bytes One or more bytes to be searched for in the socket stream. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET maxsize int The maximum size for the internal buffer. Defaults to the value set in the constructor. _UNSET with_delimiter bool Whether or not to include the delimiter in the output. False by default, but True is useful in cases where one is simply forwarding the messages. False recv_until will raise the following exceptions: :exc: Timeout if more than timeout seconds expire. :exc: ConnectionClosed if the underlying socket is closed by the sending end. :exc: MessageTooLong if the delimiter is not found in the first maxsize bytes. :exc: socket.error if operating in nonblocking mode ( timeout equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. Source code in mapper\\sockets\\bufferedsocket.py def recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ): \"\"\"Receive until *delimiter* is found, *maxsize* bytes have been read, or *timeout* is exceeded. Args: delimiter (bytes): One or more bytes to be searched for in the socket stream. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. maxsize (int): The maximum size for the internal buffer. Defaults to the value set in the constructor. with_delimiter (bool): Whether or not to include the delimiter in the output. ``False`` by default, but ``True`` is useful in cases where one is simply forwarding the messages. ``recv_until`` will raise the following exceptions: * :exc:`Timeout` if more than *timeout* seconds expire. * :exc:`ConnectionClosed` if the underlying socket is closed by the sending end. * :exc:`MessageTooLong` if the delimiter is not found in the first *maxsize* bytes. * :exc:`socket.error` if operating in nonblocking mode (*timeout* equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. \"\"\" with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE if timeout is _UNSET : timeout = self . timeout len_delimiter = len ( delimiter ) sock = self . sock recvd = bytearray ( self . rbuf ) start = time . time () find_offset_start = 0 # becomes a negative index below if not timeout : # covers None (no timeout) and 0 (nonblocking) sock . settimeout ( timeout ) try : while 1 : offset = recvd . find ( delimiter , find_offset_start , maxsize ) if offset != - 1 : # str.find returns -1 when no match found if with_delimiter : # include delimiter in return offset += len_delimiter rbuf_offset = offset else : rbuf_offset = offset + len_delimiter break elif len ( recvd ) > maxsize : raise MessageTooLong ( maxsize , delimiter ) # see rbuf if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () sock . settimeout ( cur_timeout ) nxt = sock . recv ( self . _recvsize ) if not nxt : args = ( len ( recvd ), delimiter ) msg = ( 'connection closed after reading %s bytes' ' without finding symbol: %r ' % args ) raise ConnectionClosed ( msg ) # check the recv buffer recvd . extend ( nxt ) find_offset_start = - len ( nxt ) - len_delimiter + 1 except socket . timeout : self . rbuf = bytes ( recvd ) msg = ( 'read %s bytes without finding delimiter: %r ' % ( len ( recvd ), delimiter )) raise Timeout ( timeout , msg ) # check the recv buffer except Exception : self . rbuf = bytes ( recvd ) raise val , self . rbuf = bytes ( recvd [: offset ]), bytes ( recvd [ rbuf_offset :]) return val Method send ( self , data , flags = 0 , timeout = _UNSET ) inherited \u00b6 Send the contents of the internal send buffer, as well as data , to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of data was sent and the internal send buffer is empty. Parameters: Name Type Description Default data bytes The bytes to send. required flags int Kept for API compatibility with sockets. Only the default 0 is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET Will raise :exc: Timeout if the send operation fails to complete before timeout . In the event of an exception, use :meth: BufferedSocket.getsendbuffer to see which data was unsent. Source code in mapper\\sockets\\bufferedsocket.py def send ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"Send the contents of the internal send buffer, as well as *data*, to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of *data* was sent and the internal send buffer is empty. Args: data (bytes): The bytes to send. flags (int): Kept for API compatibility with sockets. Only the default 0 is valid. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. Will raise :exc:`Timeout` if the send operation fails to complete before *timeout*. In the event of an exception, use :meth:`BufferedSocket.getsendbuffer` to see which data was unsent. \"\"\" with self . _send_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported\" ) sbuf = self . sbuf sbuf . append ( data ) if len ( sbuf ) > 1 : sbuf [:] = [ b '' . join ([ s for s in sbuf if s ])] self . sock . settimeout ( timeout ) start , total_sent = time . time (), 0 try : while sbuf [ 0 ]: sent = self . sock . send ( sbuf [ 0 ]) total_sent += sent sbuf [ 0 ] = sbuf [ 0 ][ sent :] if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) except socket . timeout : raise Timeout ( timeout , ' %s bytes unsent' % len ( sbuf [ 0 ])) return total_sent Method sendall ( self , data , flags = 0 , timeout = _UNSET ) inherited \u00b6 A passthrough to :meth: ~BufferedSocket.send , retained for parallelism to the :class: socket.socket API. Source code in mapper\\sockets\\bufferedsocket.py def sendall ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"A passthrough to :meth:`~BufferedSocket.send`, retained for parallelism to the :class:`socket.socket` API. \"\"\" return self . send ( data , flags , timeout ) Method setmaxsize ( self , maxsize ) inherited \u00b6 Set the default maximum buffer size maxsize for future operations, in bytes. Does not truncate the current buffer. Source code in mapper\\sockets\\bufferedsocket.py def setmaxsize ( self , maxsize ): \"\"\"Set the default maximum buffer size *maxsize* for future operations, in bytes. Does not truncate the current buffer. \"\"\" self . maxsize = maxsize Method setsockopt ( self , level , optname , value ) inherited \u00b6 Convenience function passing through to the wrapped socket's :meth: socket.setsockopt . Source code in mapper\\sockets\\bufferedsocket.py def setsockopt ( self , level , optname , value ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.setsockopt`. \"\"\" return self . sock . setsockopt ( level , optname , value ) Method settimeout ( self , timeout ) inherited \u00b6 Set the default timeout for future operations, in seconds. Source code in mapper\\sockets\\bufferedsocket.py def settimeout ( self , timeout ): \"Set the default *timeout* for future operations, in seconds.\" self . timeout = timeout Method shutdown ( self , how ) inherited \u00b6 Convenience method which passes through to the wrapped socket's :meth: ~socket.shutdown . Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full shutdown is followed by a :meth: ~BufferedSocket.close . Developers requiring more support, please open an issue _. .. _an issue: https://github.com/mahmoud/boltons/issues Source code in mapper\\sockets\\bufferedsocket.py def shutdown ( self , how ): \"\"\"Convenience method which passes through to the wrapped socket's :meth:`~socket.shutdown`. Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full ``shutdown`` is followed by a :meth:`~BufferedSocket.close`. Developers requiring more support, please open `an issue`_. .. _an issue: https://github.com/mahmoud/boltons/issues \"\"\" with self . _recv_lock : with self . _send_lock : self . sock . shutdown ( how ) return Method wrapSSL ( self , sock , ** kwargs ) \u00b6 Wraps a socket in an SSL context. Parameters: Name Type Description Default sock socket.socket The unencrypted socket. required **kwargs Any Key-word only arguments to be passed to the SSLContext.wrap_socket method. {} Returns: Type Description The socket wrapped in an [SSL context.][1] [1] https://docs.python.org/library/ssl.html#ssl.SSLContext Source code in mapper\\sockets\\bufferedsocket.py def wrapSSL ( self , sock : socket . socket , ** kwargs : Any ) -> ssl . SSLSocket : \"\"\" Wraps a socket in an SSL context. Args: sock: The unencrypted socket. **kwargs: Key-word only arguments to be passed to the [`SSLContext.wrap_socket`][1] method. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext.wrap_socket> Returns: The socket wrapped in an [SSL context.][1] [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> \"\"\" kwargs [ \"do_handshake_on_connect\" ] = False # Avoid race condition. with self . _recv_lock , self . _send_lock : originalTimeout : Union [ float , None ] = sock . gettimeout () sock . settimeout ( None ) try : context : ssl . SSLContext = ssl . SSLContext ( ssl . PROTOCOL_TLS_CLIENT ) context . load_verify_locations ( CERT_LOCATION ) sock = context . wrap_socket ( sock , ** kwargs ) self . doSSLHandshake ( sock ) finally : sock . settimeout ( originalTimeout ) return sock","title":"bufferedsocket.py"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket","text":"","title":"bufferedsocket"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket","text":"Source code in mapper\\sockets\\bufferedsocket.py class BufferedSocket ( socketutils . BufferedSocket ): _recv_lock : AbstractContextManager [ None ] _send_lock : AbstractContextManager [ None ] def __init__ ( self , sock : Union [ socket . socket , FakeSocket ], * args : Any , encrypt : bool = False , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: sock: The connected socket to be wrapped. *args: Positional arguments to be passed to the parent constructor. encrypt: True if the socket should be wrapped in an [SSL context][1], False otherwise. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> **kwargs: Key-word only arguments to be passed to the parent constructor. Additional key-word only arguments will be passed to the [wrapSSL][mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL] method. \"\"\" parentExtraArgs : tuple [ str , ... ] = ( \"timeout\" , \"maxsize\" , \"recvsize\" ) parentKWArgs : dict [ str , Any ] = { arg : kwargs . pop ( arg ) for arg in parentExtraArgs if arg in kwargs } super () . __init__ ( cast ( socket . socket , sock ), * args , ** parentKWArgs ) if encrypt and isinstance ( self . sock , socket . socket ): self . sock = self . wrapSSL ( self . sock , ** kwargs ) def wrapSSL ( self , sock : socket . socket , ** kwargs : Any ) -> ssl . SSLSocket : \"\"\" Wraps a socket in an SSL context. Args: sock: The unencrypted socket. **kwargs: Key-word only arguments to be passed to the [`SSLContext.wrap_socket`][1] method. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext.wrap_socket> Returns: The socket wrapped in an [SSL context.][1] [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> \"\"\" kwargs [ \"do_handshake_on_connect\" ] = False # Avoid race condition. with self . _recv_lock , self . _send_lock : originalTimeout : Union [ float , None ] = sock . gettimeout () sock . settimeout ( None ) try : context : ssl . SSLContext = ssl . SSLContext ( ssl . PROTOCOL_TLS_CLIENT ) context . load_verify_locations ( CERT_LOCATION ) sock = context . wrap_socket ( sock , ** kwargs ) self . doSSLHandshake ( sock ) finally : sock . settimeout ( originalTimeout ) return sock def doSSLHandshake ( self , sock : ssl . SSLSocket ) -> None : \"\"\" Performs an SSL handshake. Note: The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Args: sock: The socket to perform the handshake on. \"\"\" while True : try : sock . do_handshake () break except ssl . SSLWantReadError : select . select ([ sock ], [], []) except ssl . SSLWantWriteError : select . select ([], [ sock ], [])","title":"BufferedSocket"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.family","text":"A passthrough to the wrapped socket's family. BufferedSocket supports all widely-used families, so this read-only attribute can be one of :data: socket.AF_INET for IP, :data: socket.AF_INET6 for IPv6, and :data: socket.AF_UNIX for UDS.","title":"family"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.proto","text":"A passthrough to the wrapped socket's protocol. The proto attribute is very rarely used, so it's always 0, meaning \"the default\" protocol. Pretty much all the practical information is in :attr: ~BufferedSocket.type and :attr: ~BufferedSocket.family , so you can go back to never thinking about this.","title":"proto"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.type","text":"A passthrough to the wrapped socket's type. Valid usages should only ever see :data: socket.SOCK_STREAM .","title":"type"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default sock Union[socket.socket, FakeSocket] The connected socket to be wrapped. required *args Any Positional arguments to be passed to the parent constructor. () encrypt bool True if the socket should be wrapped in an SSL context , False otherwise. False **kwargs Any Key-word only arguments to be passed to the parent constructor. Additional key-word only arguments will be passed to the wrapSSL method. {} Source code in mapper\\sockets\\bufferedsocket.py def __init__ ( self , sock : Union [ socket . socket , FakeSocket ], * args : Any , encrypt : bool = False , ** kwargs : Any , ) -> None : \"\"\" Defines the constructor for the object. Args: sock: The connected socket to be wrapped. *args: Positional arguments to be passed to the parent constructor. encrypt: True if the socket should be wrapped in an [SSL context][1], False otherwise. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> **kwargs: Key-word only arguments to be passed to the parent constructor. Additional key-word only arguments will be passed to the [wrapSSL][mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL] method. \"\"\" parentExtraArgs : tuple [ str , ... ] = ( \"timeout\" , \"maxsize\" , \"recvsize\" ) parentKWArgs : dict [ str , Any ] = { arg : kwargs . pop ( arg ) for arg in parentExtraArgs if arg in kwargs } super () . __init__ ( cast ( socket . socket , sock ), * args , ** parentKWArgs ) if encrypt and isinstance ( self . sock , socket . socket ): self . sock = self . wrapSSL ( self . sock , ** kwargs )","title":"__init__()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.buffer","text":"Buffer data bytes for the next send operation. Source code in mapper\\sockets\\bufferedsocket.py def buffer ( self , data ): \"Buffer *data* bytes for the next send operation.\" with self . _send_lock : self . sbuf . append ( data ) return","title":"buffer()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.close","text":"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth: ~BufferedSocket.buffer , be sure to call :meth: ~BufferedSocket.flush before calling this method. After calling this method, future socket operations will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def close ( self ): \"\"\"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth:`~BufferedSocket.buffer`, be sure to call :meth:`~BufferedSocket.flush` before calling this method. After calling this method, future socket operations will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : with self . _send_lock : self . rbuf = b '' self . rbuf_unconsumed = self . rbuf self . sbuf [:] = [] self . sock . close () return","title":"close()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.doSSLHandshake","text":"Performs an SSL handshake. Note The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Parameters: Name Type Description Default sock ssl.SSLSocket The socket to perform the handshake on. required Source code in mapper\\sockets\\bufferedsocket.py def doSSLHandshake ( self , sock : ssl . SSLSocket ) -> None : \"\"\" Performs an SSL handshake. Note: The [`SSLSocket.do_handshake`][1] method is non-blocking and must be retried until it returns successfully. See [here][2] for further explanation. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLSocket.do_handshake> [2]: <https://docs.python.org/library/ssl.html#ssl-nonblocking> Args: sock: The socket to perform the handshake on. \"\"\" while True : try : sock . do_handshake () break except ssl . SSLWantReadError : select . select ([ sock ], [], []) except ssl . SSLWantWriteError : select . select ([], [ sock ], [])","title":"doSSLHandshake()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.fileno","text":"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling recv* functions. Source code in mapper\\sockets\\bufferedsocket.py def fileno ( self ): \"\"\"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling ``recv*`` functions. \"\"\" return self . sock . fileno ()","title":"fileno()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.flush","text":"Send the contents of the internal send buffer. Source code in mapper\\sockets\\bufferedsocket.py def flush ( self ): \"Send the contents of the internal send buffer.\" with self . _send_lock : self . send ( b '' ) return","title":"flush()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getpeername","text":"Convenience function to return the remote address to which the wrapped socket is connected. See :meth: socket.getpeername for more details. Source code in mapper\\sockets\\bufferedsocket.py def getpeername ( self ): \"\"\"Convenience function to return the remote address to which the wrapped socket is connected. See :meth:`socket.getpeername` for more details. \"\"\" return self . sock . getpeername ()","title":"getpeername()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getrecvbuffer","text":"Returns the receive buffer bytestring (rbuf). Source code in mapper\\sockets\\bufferedsocket.py def getrecvbuffer ( self ): \"Returns the receive buffer bytestring (rbuf).\" with self . _recv_lock : return self . rbuf","title":"getrecvbuffer()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getsendbuffer","text":"Returns a copy of the send buffer list. Source code in mapper\\sockets\\bufferedsocket.py def getsendbuffer ( self ): \"Returns a copy of the send buffer list.\" with self . _send_lock : return b '' . join ( self . sbuf )","title":"getsendbuffer()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getsockname","text":"Convenience function to return the wrapped socket's own address. See :meth: socket.getsockname for more details. Source code in mapper\\sockets\\bufferedsocket.py def getsockname ( self ): \"\"\"Convenience function to return the wrapped socket's own address. See :meth:`socket.getsockname` for more details. \"\"\" return self . sock . getsockname ()","title":"getsockname()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.getsockopt","text":"Convenience function passing through to the wrapped socket's :meth: socket.getsockopt . Source code in mapper\\sockets\\bufferedsocket.py def getsockopt ( self , level , optname , buflen = None ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.getsockopt`. \"\"\" args = ( level , optname ) if buflen is not None : args += ( buflen ,) return self . sock . getsockopt ( * args )","title":"getsockopt()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.peek","text":"Returns size bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth: getrecvbuffer . Parameters: Name Type Description Default size int The exact number of bytes to peek at required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def peek ( self , size , timeout = _UNSET ): \"\"\"Returns *size* bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth:`getrecvbuffer`. Args: size (int): The exact number of bytes to peek at timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if len ( self . rbuf ) >= size : return self . rbuf [: size ] data = self . recv_size ( size , timeout = timeout ) self . rbuf = data + self . rbuf return data","title":"peek()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv","text":"Returns up to size bytes, using the internal buffer before performing a single :meth: socket.recv operation. Parameters: Name Type Description Default size int The maximum number of bytes to receive. required flags int Kept for API compatibility with sockets. Only the default, 0 , is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET If the operation does not complete in timeout seconds, a :exc: Timeout is raised. Much like the built-in :class: socket.socket , if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc: socket.error . Source code in mapper\\sockets\\bufferedsocket.py def recv ( self , size , flags = 0 , timeout = _UNSET ): \"\"\"Returns **up to** *size* bytes, using the internal buffer before performing a single :meth:`socket.recv` operation. Args: size (int): The maximum number of bytes to receive. flags (int): Kept for API compatibility with sockets. Only the default, ``0``, is valid. timeout (float): The timeout for this operation. Can be ``0`` for nonblocking and ``None`` for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the operation does not complete in *timeout* seconds, a :exc:`Timeout` is raised. Much like the built-in :class:`socket.socket`, if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported: %r \" % flags ) if len ( self . rbuf ) >= size : data , self . rbuf = self . rbuf [: size ], self . rbuf [ size :] return data if self . rbuf : ret , self . rbuf = self . rbuf , b '' return ret self . sock . settimeout ( timeout ) try : data = self . sock . recv ( self . _recvsize ) except socket . timeout : raise Timeout ( timeout ) # check the rbuf attr for more if len ( data ) > size : data , self . rbuf = data [: size ], data [ size :] return data","title":"recv()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv_close","text":"Receive until the connection is closed, up to maxsize bytes. If more than maxsize bytes are received, raises :exc: MessageTooLong . Source code in mapper\\sockets\\bufferedsocket.py def recv_close ( self , timeout = _UNSET , maxsize = _UNSET ): \"\"\"Receive until the connection is closed, up to *maxsize* bytes. If more than *maxsize* bytes are received, raises :exc:`MessageTooLong`. \"\"\" # recv_close works by using recv_size to request maxsize data, # and ignoring ConnectionClose, returning and clearing the # internal buffer instead. It raises an exception if # ConnectionClosed isn't raised. with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE try : recvd = self . recv_size ( maxsize + 1 , timeout ) except ConnectionClosed : ret , self . rbuf = self . rbuf , b '' else : # put extra received bytes (now in rbuf) after recvd self . rbuf = recvd + self . rbuf size_read = min ( maxsize , len ( self . rbuf )) raise MessageTooLong ( size_read ) # check receive buffer return ret","title":"recv_close()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv_size","text":"Read off of the internal buffer, then off the socket, until size bytes have been read. Parameters: Name Type Description Default size int number of bytes to read before returning. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\sockets\\bufferedsocket.py def recv_size ( self , size , timeout = _UNSET ): \"\"\"Read off of the internal buffer, then off the socket, until *size* bytes have been read. Args: size (int): number of bytes to read before returning. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout chunks = [] total_bytes = 0 try : start = time . time () self . sock . settimeout ( timeout ) nxt = self . rbuf or self . sock . recv ( self . _recvsize ) while nxt : total_bytes += len ( nxt ) if total_bytes >= size : break chunks . append ( nxt ) if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) nxt = self . sock . recv ( self . _recvsize ) else : msg = ( 'connection closed after reading %s of %s requested' ' bytes' % ( total_bytes , size )) raise ConnectionClosed ( msg ) # check recv buffer except socket . timeout : self . rbuf = b '' . join ( chunks ) msg = 'read %s of %s bytes' % ( total_bytes , size ) raise Timeout ( timeout , msg ) # check recv buffer except Exception : # received data is still buffered in the case of errors self . rbuf = b '' . join ( chunks ) raise extra_bytes = total_bytes - size if extra_bytes : last , self . rbuf = nxt [: - extra_bytes ], nxt [ - extra_bytes :] else : last , self . rbuf = nxt , b '' chunks . append ( last ) return b '' . join ( chunks )","title":"recv_size()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.recv_until","text":"Receive until delimiter is found, maxsize bytes have been read, or timeout is exceeded. Parameters: Name Type Description Default delimiter bytes One or more bytes to be searched for in the socket stream. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET maxsize int The maximum size for the internal buffer. Defaults to the value set in the constructor. _UNSET with_delimiter bool Whether or not to include the delimiter in the output. False by default, but True is useful in cases where one is simply forwarding the messages. False recv_until will raise the following exceptions: :exc: Timeout if more than timeout seconds expire. :exc: ConnectionClosed if the underlying socket is closed by the sending end. :exc: MessageTooLong if the delimiter is not found in the first maxsize bytes. :exc: socket.error if operating in nonblocking mode ( timeout equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. Source code in mapper\\sockets\\bufferedsocket.py def recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ): \"\"\"Receive until *delimiter* is found, *maxsize* bytes have been read, or *timeout* is exceeded. Args: delimiter (bytes): One or more bytes to be searched for in the socket stream. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. maxsize (int): The maximum size for the internal buffer. Defaults to the value set in the constructor. with_delimiter (bool): Whether or not to include the delimiter in the output. ``False`` by default, but ``True`` is useful in cases where one is simply forwarding the messages. ``recv_until`` will raise the following exceptions: * :exc:`Timeout` if more than *timeout* seconds expire. * :exc:`ConnectionClosed` if the underlying socket is closed by the sending end. * :exc:`MessageTooLong` if the delimiter is not found in the first *maxsize* bytes. * :exc:`socket.error` if operating in nonblocking mode (*timeout* equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. \"\"\" with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE if timeout is _UNSET : timeout = self . timeout len_delimiter = len ( delimiter ) sock = self . sock recvd = bytearray ( self . rbuf ) start = time . time () find_offset_start = 0 # becomes a negative index below if not timeout : # covers None (no timeout) and 0 (nonblocking) sock . settimeout ( timeout ) try : while 1 : offset = recvd . find ( delimiter , find_offset_start , maxsize ) if offset != - 1 : # str.find returns -1 when no match found if with_delimiter : # include delimiter in return offset += len_delimiter rbuf_offset = offset else : rbuf_offset = offset + len_delimiter break elif len ( recvd ) > maxsize : raise MessageTooLong ( maxsize , delimiter ) # see rbuf if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () sock . settimeout ( cur_timeout ) nxt = sock . recv ( self . _recvsize ) if not nxt : args = ( len ( recvd ), delimiter ) msg = ( 'connection closed after reading %s bytes' ' without finding symbol: %r ' % args ) raise ConnectionClosed ( msg ) # check the recv buffer recvd . extend ( nxt ) find_offset_start = - len ( nxt ) - len_delimiter + 1 except socket . timeout : self . rbuf = bytes ( recvd ) msg = ( 'read %s bytes without finding delimiter: %r ' % ( len ( recvd ), delimiter )) raise Timeout ( timeout , msg ) # check the recv buffer except Exception : self . rbuf = bytes ( recvd ) raise val , self . rbuf = bytes ( recvd [: offset ]), bytes ( recvd [ rbuf_offset :]) return val","title":"recv_until()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.send","text":"Send the contents of the internal send buffer, as well as data , to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of data was sent and the internal send buffer is empty. Parameters: Name Type Description Default data bytes The bytes to send. required flags int Kept for API compatibility with sockets. Only the default 0 is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. _UNSET Will raise :exc: Timeout if the send operation fails to complete before timeout . In the event of an exception, use :meth: BufferedSocket.getsendbuffer to see which data was unsent. Source code in mapper\\sockets\\bufferedsocket.py def send ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"Send the contents of the internal send buffer, as well as *data*, to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of *data* was sent and the internal send buffer is empty. Args: data (bytes): The bytes to send. flags (int): Kept for API compatibility with sockets. Only the default 0 is valid. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. Will raise :exc:`Timeout` if the send operation fails to complete before *timeout*. In the event of an exception, use :meth:`BufferedSocket.getsendbuffer` to see which data was unsent. \"\"\" with self . _send_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported\" ) sbuf = self . sbuf sbuf . append ( data ) if len ( sbuf ) > 1 : sbuf [:] = [ b '' . join ([ s for s in sbuf if s ])] self . sock . settimeout ( timeout ) start , total_sent = time . time (), 0 try : while sbuf [ 0 ]: sent = self . sock . send ( sbuf [ 0 ]) total_sent += sent sbuf [ 0 ] = sbuf [ 0 ][ sent :] if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) except socket . timeout : raise Timeout ( timeout , ' %s bytes unsent' % len ( sbuf [ 0 ])) return total_sent","title":"send()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.sendall","text":"A passthrough to :meth: ~BufferedSocket.send , retained for parallelism to the :class: socket.socket API. Source code in mapper\\sockets\\bufferedsocket.py def sendall ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"A passthrough to :meth:`~BufferedSocket.send`, retained for parallelism to the :class:`socket.socket` API. \"\"\" return self . send ( data , flags , timeout )","title":"sendall()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.setmaxsize","text":"Set the default maximum buffer size maxsize for future operations, in bytes. Does not truncate the current buffer. Source code in mapper\\sockets\\bufferedsocket.py def setmaxsize ( self , maxsize ): \"\"\"Set the default maximum buffer size *maxsize* for future operations, in bytes. Does not truncate the current buffer. \"\"\" self . maxsize = maxsize","title":"setmaxsize()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.setsockopt","text":"Convenience function passing through to the wrapped socket's :meth: socket.setsockopt . Source code in mapper\\sockets\\bufferedsocket.py def setsockopt ( self , level , optname , value ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.setsockopt`. \"\"\" return self . sock . setsockopt ( level , optname , value )","title":"setsockopt()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.settimeout","text":"Set the default timeout for future operations, in seconds. Source code in mapper\\sockets\\bufferedsocket.py def settimeout ( self , timeout ): \"Set the default *timeout* for future operations, in seconds.\" self . timeout = timeout","title":"settimeout()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.shutdown","text":"Convenience method which passes through to the wrapped socket's :meth: ~socket.shutdown . Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full shutdown is followed by a :meth: ~BufferedSocket.close . Developers requiring more support, please open an issue _. .. _an issue: https://github.com/mahmoud/boltons/issues Source code in mapper\\sockets\\bufferedsocket.py def shutdown ( self , how ): \"\"\"Convenience method which passes through to the wrapped socket's :meth:`~socket.shutdown`. Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full ``shutdown`` is followed by a :meth:`~BufferedSocket.close`. Developers requiring more support, please open `an issue`_. .. _an issue: https://github.com/mahmoud/boltons/issues \"\"\" with self . _recv_lock : with self . _send_lock : self . sock . shutdown ( how ) return","title":"shutdown()"},{"location":"api/sockets/bufferedsocket/#mapper.sockets.bufferedsocket.BufferedSocket.wrapSSL","text":"Wraps a socket in an SSL context. Parameters: Name Type Description Default sock socket.socket The unencrypted socket. required **kwargs Any Key-word only arguments to be passed to the SSLContext.wrap_socket method. {} Returns: Type Description The socket wrapped in an [SSL context.][1] [1] https://docs.python.org/library/ssl.html#ssl.SSLContext Source code in mapper\\sockets\\bufferedsocket.py def wrapSSL ( self , sock : socket . socket , ** kwargs : Any ) -> ssl . SSLSocket : \"\"\" Wraps a socket in an SSL context. Args: sock: The unencrypted socket. **kwargs: Key-word only arguments to be passed to the [`SSLContext.wrap_socket`][1] method. [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext.wrap_socket> Returns: The socket wrapped in an [SSL context.][1] [1]: <https://docs.python.org/library/ssl.html#ssl.SSLContext> \"\"\" kwargs [ \"do_handshake_on_connect\" ] = False # Avoid race condition. with self . _recv_lock , self . _send_lock : originalTimeout : Union [ float , None ] = sock . gettimeout () sock . settimeout ( None ) try : context : ssl . SSLContext = ssl . SSLContext ( ssl . PROTOCOL_TLS_CLIENT ) context . load_verify_locations ( CERT_LOCATION ) sock = context . wrap_socket ( sock , ** kwargs ) self . doSSLHandshake ( sock ) finally : sock . settimeout ( originalTimeout ) return sock","title":"wrapSSL()"},{"location":"api/sockets/fakesocket/","text":"Module mapper.sockets.fakesocket \u00b6","title":"fakesocket.py"},{"location":"api/sockets/fakesocket/#mapper.sockets.fakesocket","text":"","title":"fakesocket"}]}