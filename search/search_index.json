{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mapper Proxy \u00b6 A mapper proxy for playing MUME, targeted towards the needs of blind players. It is entirely controlled by plain text commands, and offers some facilities such as pathfinding and room finding. It also comes with a high contrast GUI for visually impaired players, and a tiled one for sighted players. License And Credits \u00b6 Mapper Proxy is licensed under the terms of the Mozilla Public License, version 2.0. Mapper Proxy was originally created and is actively maintained by Nick Stockton. Visually Impaired GUI contributed by Katalina Durden. Sighted GUI and various additions contributed by Lindisse. The tiles of the GUI for sighted players are distributed under the CC-BY-SA 3.0 license. They are a modified version of fantasy-tileset.png originally created by Jerome. Installation \u00b6 As Part of Mud Clients \u00b6 Mapper Proxy is distributed as part of MUSHclient-MUME , and tintin-MUME , which also provide scripts to play Mume more easily. Refer to these projects for an installation guide. Running From Source \u00b6 Install the Python interpreter, and make sure it's in your path before running this package. After Python is installed, execute the following commands from the top level directory of this repository to install the module dependencies. pip install pipenv pipenv install --skip-lock If you wish to contribute to this project, install the development dependencies with the following commands. pipenv install --skip-lock --dev pipenv run pre-commit install -t pre-commit pipenv run pre-commit install -t pre-push Mapper Proxy Usage \u00b6 Manual Startup \u00b6 To start Mapper Proxy, run python start.py from the root directory of this project. It accepts the following arguments: -h , --help Show program's help and exit. -v , --version Show program's version number and exit. -e , --emulation Start in emulation mode. The mapper will not connect to MUME. -i [text|hc|sighted] , --interface [text|hc|sighted] Select an interface. Text-only mode, high contrast GUI, or sighted GUI. The high contrast GUI is a high contrast one for visually impaired players. The sighted GUI uses png tiles. Default is \" text \" mode (no GUI). -f [normal|tintin|raw] , --format [normal|tintin|raw] Select how the data from the server is transformed before being sent to the client. Normal mode filters out XML tags from the data received by the mud before sending it to the user's mud client, TinTin sends certain tags to the client in a special format for the mud client to trigger on, and raw sends the data from the mud to the mud client unmodified. Default is \" normal \". -lh address , --local-host address The local host address to bind to. Default is \" 127.0.0.1 \". -lp port , --local-port port The local port to bind to. Default is \" 4000 \". -rh address , --remote-host address The remote host address to connect to. Default is \" mume.org \". -rp port , --remote-port port The remote port to connect to. Default is \" 4242 \". -nssl , --no-ssl Disable encrypted communication between the local and remote hosts. Don't do this unless you know what you're doing. -ptlf , --prompt-terminator-lf Terminate game prompts with new line characters (IAC + GA is default). -gp , --gag-prompts gag emulated prompts. -ff FormatString , --find-format FormatString The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute} , {direction} , {clockPosition} , {distance} , {name} , {vnum} . Where {attribute} represents the attribute on which the search is performed. The default is \"{vnum}, {name}, {attribute}\" . Once done, connect your client to 127.0.0.1 , port 4000 . Starting From a Client \u00b6 It is possible to start Mapper Proxy directly from the client. Here is, for example, how to start it from a tintin+++ script, from the root directory of this project: #run {mapper} {python -B} from mapper.main import main #action {^MPICOMMAND:%1:MPICOMMAND$} {#mume {#system %1;#mapper continue}} #gts #mapper main(outputFormat=\"tintin\", interface=\"sighted\") Mapper Proxy Commands \u00b6 Auto Mapping Commands \u00b6 Auto mapping mode must be on for these commands to have any effect. autolink -- Toggle Auto linking on or off. If on, the mapper will attempt to link undefined exits in newly added rooms. automap -- Toggle automatic mapping mode on. automerge -- Toggle automatic merging of duplicate rooms on or off. autoupdate -- Toggle Automatic updating of room name/descriptions/dynamic descriptions on or off. Map Editing Commands \u00b6 doorflags [add|remove] [hidden|need_key|no_block|no_break|no_pick|delayed|callable|knockable|magic|action|no_bash] [north|east|south|west|up|down] -- Modify door flags for a given direction. exitflags [add|remove] [exit|door|road|climb|random|special|avoid|no_match] [north|east|south|west|up|down] -- Modify exit flags for a given direction. ralign [good|neutral|evil|undefined] -- Modify the alignment flag of the current room. ravoid [+|-] -- Set or clear the avoid flag for the current room. If the avoid flag is set, the mapper will try to avoid the room when path finding. rdelete [vnum] -- Delete the room with vnum. If the mapper is synced and no vnum is given, delete the current room. rlabel [add|delete|info|search] [label] [vnum] -- Manage room labels. Vnum is only used when adding a room. Leave it blank to use the current room's vnum. Use rlabel info all to get a list of all labels. rlight [lit|dark|undefined] -- Modify the light flag of the current room. rlink [add|remove] [oneway] [vnum] [north|east|south|west|up|down] -- Manually manage links from the current room to room with vnum. If oneway is given, treat the link as unidirectional. rloadflags [add|remove] [treasure|armour|weapon|water|food|herb|key|mule|horse|pack_horse|trained_horse|rohirrim|warg|boat|attention|tower|clock|mail|stable|white_word|dark_word|equipment|coach] -- Modify the load flags of the current room. rmobflags [add|remove] [rent|shop|weapon_shop|armour_shop|food_shop|pet_shop|guild|scout_guild|mage_guild|cleric_guild|warrior_guild|ranger_guild|aggressive_mob|quest_mob|passive_mob|elite_mob|super_mob] -- Modify the mob flags of the current room. rnote [-a|-r] [text] -- Modify the note for the current room. If '-a' is given, append text to the current note. If '-r' is given, remove the note. rportable [portable|notportable|undefined] -- Modify the portable flag of the current room. rridable [ridable|notridable|undefined] -- Modify the ridable flag of the current room. rterrain [death|city|shallowwater|forest|hills|road|cavern|field|water|underwater|rapids|indoors|brush|tunnel|mountains|random|undefined] -- Modify the terrain of the current room. rx [number] -- Modify the X coordinate of the current room. ry [number] -- Modify the Y coordinate of the current room. rz [number] -- Modify the Z coordinate of the current room. savemap -- Save modifications to the map to disk. secret [add|remove] [name] [north|east|south|west|up|down] -- Add or remove a secret door in the current room. Searching Commands \u00b6 fdoor [text] -- Search the map for rooms with doors matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fdynamic [text] -- Search the map for rooms with dynamic descriptions matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. flabel [text] -- Search the map for rooms with labels matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. If no text is given, will show the 20 closest labeled rooms. fname [text] -- Search the map for rooms with names matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fnote [text] -- Search the map for rooms with notes matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. Path Commands \u00b6 path [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Print speed walk directions from the current room to the room with vnum or label. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, path ingrove noroad|nobrush. run [c|t] [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Automatically walk from the current room to the room with vnum or label. If 'c' is provided instead of a vnum or label, the mapper will recalculate the path from the current room to the previously provided destination. If t (short for target) is given before the vnum or label, the mapper will store the destination, but won't start auto walking until the user enters 'run c'. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, run ingrove noroad|nobrush. step [label|vnum] -- Move 1 room towards the destination room matching label or vnum. stop -- Stop auto walking. Door Commands \u00b6 secretaction [action] [north|east|south|west|up|down] -- Perform an action on a secret door in a given direction. This command is meant to be called from an alias. For example, secretaction open east. Miscellaneous Commands \u00b6 clock [action] -- If no action is given, print the output from the mapper's clock. If the action is 'pull', send the appropriate commands to the game for opening the exit in mystical. If any other action is given, send a line with the current game time to the game, prefixed by the action. Example: clock narrate to narrate the current game time. emu [command] -- If not in emulation mode (I.E. connected to the game), execute an emulation command. getlabel [vnum] -- Returns the label or labels defined for the room with vnum. If no vnum is supplied, the current room's vnum is used. gettimer -- Returns the amount of seconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. gettimerms -- Returns the amount of milliseconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. help -- If in emulation mode, print a summery of the available emulation commands. maphelp -- Print a summery of the available mapper commands. quit -- Quit the mapper when in emulation mode. rinfo [vnum|label] -- Print info about the room with vnum or label. If no vnum or label is given, use current room. rinfo [vnum|label] -- Print info about the room with vnum or label. If no vnum or label is given, use current room. sync [vnum|label] -- Manually sync the map to the room with vnum or label. If no vnum or label is given, mapper will be placed in an unsynced state, and will try to automatically sync to the current room. tvnum -- Tell the vnum of the current room to another player. vnum -- Print the vnum of the current room.","title":"Home"},{"location":"#mapper-proxy","text":"A mapper proxy for playing MUME, targeted towards the needs of blind players. It is entirely controlled by plain text commands, and offers some facilities such as pathfinding and room finding. It also comes with a high contrast GUI for visually impaired players, and a tiled one for sighted players.","title":"Mapper Proxy"},{"location":"#license-and-credits","text":"Mapper Proxy is licensed under the terms of the Mozilla Public License, version 2.0. Mapper Proxy was originally created and is actively maintained by Nick Stockton. Visually Impaired GUI contributed by Katalina Durden. Sighted GUI and various additions contributed by Lindisse. The tiles of the GUI for sighted players are distributed under the CC-BY-SA 3.0 license. They are a modified version of fantasy-tileset.png originally created by Jerome.","title":"License And Credits"},{"location":"#installation","text":"","title":"Installation"},{"location":"#as-part-of-mud-clients","text":"Mapper Proxy is distributed as part of MUSHclient-MUME , and tintin-MUME , which also provide scripts to play Mume more easily. Refer to these projects for an installation guide.","title":"As Part of Mud Clients"},{"location":"#running-from-source","text":"Install the Python interpreter, and make sure it's in your path before running this package. After Python is installed, execute the following commands from the top level directory of this repository to install the module dependencies. pip install pipenv pipenv install --skip-lock If you wish to contribute to this project, install the development dependencies with the following commands. pipenv install --skip-lock --dev pipenv run pre-commit install -t pre-commit pipenv run pre-commit install -t pre-push","title":"Running From Source"},{"location":"#mapper-proxy-usage","text":"","title":"Mapper Proxy Usage"},{"location":"#manual-startup","text":"To start Mapper Proxy, run python start.py from the root directory of this project. It accepts the following arguments: -h , --help Show program's help and exit. -v , --version Show program's version number and exit. -e , --emulation Start in emulation mode. The mapper will not connect to MUME. -i [text|hc|sighted] , --interface [text|hc|sighted] Select an interface. Text-only mode, high contrast GUI, or sighted GUI. The high contrast GUI is a high contrast one for visually impaired players. The sighted GUI uses png tiles. Default is \" text \" mode (no GUI). -f [normal|tintin|raw] , --format [normal|tintin|raw] Select how the data from the server is transformed before being sent to the client. Normal mode filters out XML tags from the data received by the mud before sending it to the user's mud client, TinTin sends certain tags to the client in a special format for the mud client to trigger on, and raw sends the data from the mud to the mud client unmodified. Default is \" normal \". -lh address , --local-host address The local host address to bind to. Default is \" 127.0.0.1 \". -lp port , --local-port port The local port to bind to. Default is \" 4000 \". -rh address , --remote-host address The remote host address to connect to. Default is \" mume.org \". -rp port , --remote-port port The remote port to connect to. Default is \" 4242 \". -nssl , --no-ssl Disable encrypted communication between the local and remote hosts. Don't do this unless you know what you're doing. -ptlf , --prompt-terminator-lf Terminate game prompts with new line characters (IAC + GA is default). -gp , --gag-prompts gag emulated prompts. -ff FormatString , --find-format FormatString The format string for controlling output of the find commands. Accepts the following placeholders in braces: {attribute} , {direction} , {clockPosition} , {distance} , {name} , {vnum} . Where {attribute} represents the attribute on which the search is performed. The default is \"{vnum}, {name}, {attribute}\" . Once done, connect your client to 127.0.0.1 , port 4000 .","title":"Manual Startup"},{"location":"#starting-from-a-client","text":"It is possible to start Mapper Proxy directly from the client. Here is, for example, how to start it from a tintin+++ script, from the root directory of this project: #run {mapper} {python -B} from mapper.main import main #action {^MPICOMMAND:%1:MPICOMMAND$} {#mume {#system %1;#mapper continue}} #gts #mapper main(outputFormat=\"tintin\", interface=\"sighted\")","title":"Starting From a Client"},{"location":"#mapper-proxy-commands","text":"","title":"Mapper Proxy Commands"},{"location":"#auto-mapping-commands","text":"Auto mapping mode must be on for these commands to have any effect. autolink -- Toggle Auto linking on or off. If on, the mapper will attempt to link undefined exits in newly added rooms. automap -- Toggle automatic mapping mode on. automerge -- Toggle automatic merging of duplicate rooms on or off. autoupdate -- Toggle Automatic updating of room name/descriptions/dynamic descriptions on or off.","title":"Auto Mapping Commands"},{"location":"#map-editing-commands","text":"doorflags [add|remove] [hidden|need_key|no_block|no_break|no_pick|delayed|callable|knockable|magic|action|no_bash] [north|east|south|west|up|down] -- Modify door flags for a given direction. exitflags [add|remove] [exit|door|road|climb|random|special|avoid|no_match] [north|east|south|west|up|down] -- Modify exit flags for a given direction. ralign [good|neutral|evil|undefined] -- Modify the alignment flag of the current room. ravoid [+|-] -- Set or clear the avoid flag for the current room. If the avoid flag is set, the mapper will try to avoid the room when path finding. rdelete [vnum] -- Delete the room with vnum. If the mapper is synced and no vnum is given, delete the current room. rlabel [add|delete|info|search] [label] [vnum] -- Manage room labels. Vnum is only used when adding a room. Leave it blank to use the current room's vnum. Use rlabel info all to get a list of all labels. rlight [lit|dark|undefined] -- Modify the light flag of the current room. rlink [add|remove] [oneway] [vnum] [north|east|south|west|up|down] -- Manually manage links from the current room to room with vnum. If oneway is given, treat the link as unidirectional. rloadflags [add|remove] [treasure|armour|weapon|water|food|herb|key|mule|horse|pack_horse|trained_horse|rohirrim|warg|boat|attention|tower|clock|mail|stable|white_word|dark_word|equipment|coach] -- Modify the load flags of the current room. rmobflags [add|remove] [rent|shop|weapon_shop|armour_shop|food_shop|pet_shop|guild|scout_guild|mage_guild|cleric_guild|warrior_guild|ranger_guild|aggressive_mob|quest_mob|passive_mob|elite_mob|super_mob] -- Modify the mob flags of the current room. rnote [-a|-r] [text] -- Modify the note for the current room. If '-a' is given, append text to the current note. If '-r' is given, remove the note. rportable [portable|notportable|undefined] -- Modify the portable flag of the current room. rridable [ridable|notridable|undefined] -- Modify the ridable flag of the current room. rterrain [death|city|shallowwater|forest|hills|road|cavern|field|water|underwater|rapids|indoors|brush|tunnel|mountains|random|undefined] -- Modify the terrain of the current room. rx [number] -- Modify the X coordinate of the current room. ry [number] -- Modify the Y coordinate of the current room. rz [number] -- Modify the Z coordinate of the current room. savemap -- Save modifications to the map to disk. secret [add|remove] [name] [north|east|south|west|up|down] -- Add or remove a secret door in the current room.","title":"Map Editing Commands"},{"location":"#searching-commands","text":"fdoor [text] -- Search the map for rooms with doors matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fdynamic [text] -- Search the map for rooms with dynamic descriptions matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. flabel [text] -- Search the map for rooms with labels matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. If no text is given, will show the 20 closest labeled rooms. fname [text] -- Search the map for rooms with names matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance. fnote [text] -- Search the map for rooms with notes matching text. Returns the nearest 20 rooms to you (furthest to closest) based on the Manhattan Distance.","title":"Searching Commands"},{"location":"#path-commands","text":"path [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Print speed walk directions from the current room to the room with vnum or label. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, path ingrove noroad|nobrush. run [c|t] [vnum|label] [nodeath|nocity|noshallowwater|noforest|nohills|noroad|nocavern|nofield|nowater|nounderwater|norapids|noindoors|nobrush|notunnel|nomountains|norandom|noundefined] -- Automatically walk from the current room to the room with vnum or label. If 'c' is provided instead of a vnum or label, the mapper will recalculate the path from the current room to the previously provided destination. If t (short for target) is given before the vnum or label, the mapper will store the destination, but won't start auto walking until the user enters 'run c'. If one or more avoid terrain flags are given after the destination, the mapper will try to avoid all rooms with that terrain type. Multiple avoid terrains can be ringed together with the '|' character, for example, run ingrove noroad|nobrush. step [label|vnum] -- Move 1 room towards the destination room matching label or vnum. stop -- Stop auto walking.","title":"Path Commands"},{"location":"#door-commands","text":"secretaction [action] [north|east|south|west|up|down] -- Perform an action on a secret door in a given direction. This command is meant to be called from an alias. For example, secretaction open east.","title":"Door Commands"},{"location":"#miscellaneous-commands","text":"clock [action] -- If no action is given, print the output from the mapper's clock. If the action is 'pull', send the appropriate commands to the game for opening the exit in mystical. If any other action is given, send a line with the current game time to the game, prefixed by the action. Example: clock narrate to narrate the current game time. emu [command] -- If not in emulation mode (I.E. connected to the game), execute an emulation command. getlabel [vnum] -- Returns the label or labels defined for the room with vnum. If no vnum is supplied, the current room's vnum is used. gettimer -- Returns the amount of seconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. gettimerms -- Returns the amount of milliseconds since the mapper was started in an optimal format for triggering. This is to assist scripters who use clients with no time stamp support such as VIP Mud. help -- If in emulation mode, print a summery of the available emulation commands. maphelp -- Print a summery of the available mapper commands. quit -- Quit the mapper when in emulation mode. rinfo [vnum|label] -- Print info about the room with vnum or label. If no vnum or label is given, use current room. rinfo [vnum|label] -- Print info about the room with vnum or label. If no vnum or label is given, use current room. sync [vnum|label] -- Manually sync the map to the room with vnum or label. If no vnum or label is given, mapper will be placed in an unsynced state, and will try to automatically sync to the current room. tvnum -- Tell the vnum of the current room to another player. vnum -- Print the vnum of the current room.","title":"Miscellaneous Commands"},{"location":"license/","text":"Mozilla Public License Version 2.0 \u00b6 1. Definitions \u00b6 1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity. 2. License Grants and Conditions \u00b6 2.1. Grants \u00b6 Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version. 2.2. Effective Date \u00b6 The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution. 2.3. Limitations on Grant Scope \u00b6 The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4). 2.4. Subsequent Licenses \u00b6 No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3). 2.5. Representation \u00b6 Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License. 2.6. Fair Use \u00b6 This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents. 2.7. Conditions \u00b6 Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1. 3. Responsibilities \u00b6 3.1. Distribution of Source Form \u00b6 All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form. 3.2. Distribution of Executable Form \u00b6 If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License. 3.3. Distribution of a Larger Work \u00b6 You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s). 3.4. Notices \u00b6 You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies. 3.5. Application of Additional Terms \u00b6 You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction. 4. Inability to Comply Due to Statute or Regulation \u00b6 If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it. 5. Termination \u00b6 5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination. 6. Disclaimer of Warranty \u00b6 Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer. 7. Limitation of Liability \u00b6 Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You. 8. Litigation \u00b6 Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims. 9. Miscellaneous \u00b6 This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor. 10. Versions of the License \u00b6 10.1. New Versions \u00b6 Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number. 10.2. Effect of New Versions \u00b6 You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward. 10.3. Modified Versions \u00b6 If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License). 10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses \u00b6 If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached. Exhibit A - Source Code Form License Notice \u00b6 This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership. Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice \u00b6 This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"License"},{"location":"license/#mozilla-public-license-version-20","text":"","title":"Mozilla Public License Version 2.0"},{"location":"license/#1-definitions","text":"1.1. \u201cContributor\u201d means each individual or legal entity that creates, contributes to the creation of, or owns Covered Software. 1.2. \u201cContributor Version\u201d means the combination of the Contributions of others (if any) used by a Contributor and that particular Contributor's Contribution. 1.3. \u201cContribution\u201d means Covered Software of a particular Contributor. 1.4. \u201cCovered Software\u201d means Source Code Form to which the initial Contributor has attached the notice in Exhibit A, the Executable Form of such Source Code Form, and Modifications of such Source Code Form, in each case including portions thereof. 1.5. \u201cIncompatible With Secondary Licenses\u201d means (a) that the initial Contributor has attached the notice described in Exhibit B to the Covered Software; or (b) that the Covered Software was made available under the terms of version 1.1 or earlier of the License, but not also under the terms of a Secondary License. 1.6. \u201cExecutable Form\u201d means any form of the work other than Source Code Form. 1.7. \u201cLarger Work\u201d means a work that combines Covered Software with other material, in a separate file or files, that is not Covered Software. 1.8. \u201cLicense\u201d means this document. 1.9. \u201cLicensable\u201d means having the right to grant, to the maximum extent possible, whether at the time of the initial grant or subsequently, any and all of the rights conveyed by this License. 1.10. \u201cModifications\u201d means any of the following: (a) any file in Source Code Form that results from an addition to, deletion from, or modification of the contents of Covered Software; or (b) any new file in Source Code Form that contains any Covered Software. 1.11. \u201cPatent Claims\u201d of a Contributor means any patent claim(s), including without limitation, method, process, and apparatus claims, in any patent Licensable by such Contributor that would be infringed, but for the grant of the License, by the making, using, selling, offering for sale, having made, import, or transfer of either its Contributions or its Contributor Version. 1.12. \u201cSecondary License\u201d means either the GNU General Public License, Version 2.0, the GNU Lesser General Public License, Version 2.1, the GNU Affero General Public License, Version 3.0, or any later versions of those licenses. 1.13. \u201cSource Code Form\u201d means the form of the work preferred for making modifications. 1.14. \u201cYou\u201d (or \u201cYour\u201d) means an individual or a legal entity exercising rights under this License. For legal entities, \u201cYou\u201d includes any entity that controls, is controlled by, or is under common control with You. For purposes of this definition, \u201ccontrol\u201d means (a) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (b) ownership of more than fifty percent (50%) of the outstanding shares or beneficial ownership of such entity.","title":"1. Definitions"},{"location":"license/#2-license-grants-and-conditions","text":"","title":"2. License Grants and Conditions"},{"location":"license/#21-grants","text":"Each Contributor hereby grants You a world-wide, royalty-free, non-exclusive license: (a) under intellectual property rights (other than patent or trademark) Licensable by such Contributor to use, reproduce, make available, modify, display, perform, distribute, and otherwise exploit its Contributions, either on an unmodified basis, with Modifications, or as part of a Larger Work; and (b) under Patent Claims of such Contributor to make, use, sell, offer for sale, have made, import, and otherwise transfer either its Contributions or its Contributor Version.","title":"2.1. Grants"},{"location":"license/#22-effective-date","text":"The licenses granted in Section 2.1 with respect to any Contribution become effective for each Contribution on the date the Contributor first distributes such Contribution.","title":"2.2. Effective Date"},{"location":"license/#23-limitations-on-grant-scope","text":"The licenses granted in this Section 2 are the only rights granted under this License. No additional rights or licenses will be implied from the distribution or licensing of Covered Software under this License. Notwithstanding Section 2.1(b) above, no patent license is granted by a Contributor: (a) for any code that a Contributor has removed from Covered Software; or (b) for infringements caused by: (i) Your and any other third party's modifications of Covered Software, or (ii) the combination of its Contributions with other software (except as part of its Contributor Version); or (c) under Patent Claims infringed by Covered Software in the absence of its Contributions. This License does not grant any rights in the trademarks, service marks, or logos of any Contributor (except as may be necessary to comply with the notice requirements in Section 3.4).","title":"2.3. Limitations on Grant Scope"},{"location":"license/#24-subsequent-licenses","text":"No Contributor makes additional grants as a result of Your choice to distribute the Covered Software under a subsequent version of this License (see Section 10.2) or under the terms of a Secondary License (if permitted under the terms of Section 3.3).","title":"2.4. Subsequent Licenses"},{"location":"license/#25-representation","text":"Each Contributor represents that the Contributor believes its Contributions are its original creation(s) or it has sufficient rights to grant the rights to its Contributions conveyed by this License.","title":"2.5. Representation"},{"location":"license/#26-fair-use","text":"This License is not intended to limit any rights You have under applicable copyright doctrines of fair use, fair dealing, or other equivalents.","title":"2.6. Fair Use"},{"location":"license/#27-conditions","text":"Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in Section 2.1.","title":"2.7. Conditions"},{"location":"license/#3-responsibilities","text":"","title":"3. Responsibilities"},{"location":"license/#31-distribution-of-source-form","text":"All distribution of Covered Software in Source Code Form, including any Modifications that You create or to which You contribute, must be under the terms of this License. You must inform recipients that the Source Code Form of the Covered Software is governed by the terms of this License, and how they can obtain a copy of this License. You may not attempt to alter or restrict the recipients' rights in the Source Code Form.","title":"3.1. Distribution of Source Form"},{"location":"license/#32-distribution-of-executable-form","text":"If You distribute Covered Software in Executable Form then: (a) such Covered Software must also be made available in Source Code Form, as described in Section 3.1, and You must inform recipients of the Executable Form how they can obtain a copy of such Source Code Form by reasonable means in a timely manner, at a charge no more than the cost of distribution to the recipient; and (b) You may distribute such Executable Form under the terms of this License, or sublicense it under different terms, provided that the license for the Executable Form does not attempt to limit or alter the recipients' rights in the Source Code Form under this License.","title":"3.2. Distribution of Executable Form"},{"location":"license/#33-distribution-of-a-larger-work","text":"You may create and distribute a Larger Work under terms of Your choice, provided that You also comply with the requirements of this License for the Covered Software. If the Larger Work is a combination of Covered Software with a work governed by one or more Secondary Licenses, and the Covered Software is not Incompatible With Secondary Licenses, this License permits You to additionally distribute such Covered Software under the terms of such Secondary License(s), so that the recipient of the Larger Work may, at their option, further distribute the Covered Software under the terms of either this License or such Secondary License(s).","title":"3.3. Distribution of a Larger Work"},{"location":"license/#34-notices","text":"You may not remove or alter the substance of any license notices (including copyright notices, patent notices, disclaimers of warranty, or limitations of liability) contained within the Source Code Form of the Covered Software, except that You may alter any license notices to the extent required to remedy known factual inaccuracies.","title":"3.4. Notices"},{"location":"license/#35-application-of-additional-terms","text":"You may choose to offer, and to charge a fee for, warranty, support, indemnity or liability obligations to one or more recipients of Covered Software. However, You may do so only on Your own behalf, and not on behalf of any Contributor. You must make it absolutely clear that any such warranty, support, indemnity, or liability obligation is offered by You alone, and You hereby agree to indemnify every Contributor for any liability incurred by such Contributor as a result of warranty, support, indemnity or liability terms You offer. You may include additional disclaimers of warranty and limitations of liability specific to any jurisdiction.","title":"3.5. Application of Additional Terms"},{"location":"license/#4-inability-to-comply-due-to-statute-or-regulation","text":"If it is impossible for You to comply with any of the terms of this License with respect to some or all of the Covered Software due to statute, judicial order, or regulation then You must: (a) comply with the terms of this License to the maximum extent possible; and (b) describe the limitations and the code they affect. Such description must be placed in a text file included with all distributions of the Covered Software under this License. Except to the extent prohibited by statute or regulation, such description must be sufficiently detailed for a recipient of ordinary skill to be able to understand it.","title":"4. Inability to Comply Due to Statute or Regulation"},{"location":"license/#5-termination","text":"5.1. The rights granted under this License will terminate automatically if You fail to comply with any of its terms. However, if You become compliant, then the rights granted under this License from a particular Contributor are reinstated (a) provisionally, unless and until such Contributor explicitly and finally terminates Your grants, and (b) on an ongoing basis, if such Contributor fails to notify You of the non-compliance by some reasonable means prior to 60 days after You have come back into compliance. Moreover, Your grants from a particular Contributor are reinstated on an ongoing basis if such Contributor notifies You of the non-compliance by some reasonable means, this is the first time You have received notice of non-compliance with this License from such Contributor, and You become compliant prior to 30 days after Your receipt of the notice. 5.2. If You initiate litigation against any entity by asserting a patent infringement claim (excluding declaratory judgment actions, counter-claims, and cross-claims) alleging that a Contributor Version directly or indirectly infringes any patent, then the rights granted to You by any and all Contributors for the Covered Software under Section 2.1 of this License shall terminate. 5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user license agreements (excluding distributors and resellers) which have been validly granted by You or Your distributors under this License prior to termination shall survive termination.","title":"5. Termination"},{"location":"license/#6-disclaimer-of-warranty","text":"Covered Software is provided under this License on an \u201cas is\u201d basis, without warranty of any kind, either expressed, implied, or statutory, including, without limitation, warranties that the Covered Software is free of defects, merchantable, fit for a particular purpose or non-infringing. The entire risk as to the quality and performance of the Covered Software is with You. Should any Covered Software prove defective in any respect, You (not any Contributor) assume the cost of any necessary servicing, repair, or correction. This disclaimer of warranty constitutes an essential part of this License. No use of any Covered Software is authorized under this License except under this disclaimer.","title":"6. Disclaimer of Warranty"},{"location":"license/#7-limitation-of-liability","text":"Under no circumstances and under no legal theory, whether tort (including negligence), contract, or otherwise, shall any Contributor, or anyone who distributes Covered Software as permitted above, be liable to You for any direct, indirect, special, incidental, or consequential damages of any character including, without limitation, damages for lost profits, loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses, even if such party shall have been informed of the possibility of such damages. This limitation of liability shall not apply to liability for death or personal injury resulting from such party's negligence to the extent applicable law prohibits such limitation. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so this exclusion and limitation may not apply to You.","title":"7. Limitation of Liability"},{"location":"license/#8-litigation","text":"Any litigation relating to this License may be brought only in the courts of a jurisdiction where the defendant maintains its principal place of business and such litigation shall be governed by laws of that jurisdiction, without reference to its conflict-of-law provisions. Nothing in this Section shall prevent a party's ability to bring cross-claims or counter-claims.","title":"8. Litigation"},{"location":"license/#9-miscellaneous","text":"This License represents the complete agreement concerning the subject matter hereof. If any provision of this License is held to be unenforceable, such provision shall be reformed only to the extent necessary to make it enforceable. Any law or regulation which provides that the language of a contract shall be construed against the drafter shall not be used to construe this License against a Contributor.","title":"9. Miscellaneous"},{"location":"license/#10-versions-of-the-license","text":"","title":"10. Versions of the License"},{"location":"license/#101-new-versions","text":"Mozilla Foundation is the license steward. Except as provided in Section 10.3, no one other than the license steward has the right to modify or publish new versions of this License. Each version will be given a distinguishing version number.","title":"10.1. New Versions"},{"location":"license/#102-effect-of-new-versions","text":"You may distribute the Covered Software under the terms of the version of the License under which You originally received the Covered Software, or under the terms of any subsequent version published by the license steward.","title":"10.2. Effect of New Versions"},{"location":"license/#103-modified-versions","text":"If you create software not governed by this License, and you want to create a new license for such software, you may create and use a modified version of this License if you rename the license and remove any references to the name of the license steward (except to note that such modified license differs from this License).","title":"10.3. Modified Versions"},{"location":"license/#104-distributing-source-code-form-that-is-incompatible-with-secondary-licenses","text":"If You choose to distribute Source Code Form that is Incompatible With Secondary Licenses under the terms of this version of the License, the notice described in Exhibit B of this License must be attached.","title":"10.4. Distributing Source Code Form that is Incompatible With Secondary Licenses"},{"location":"license/#exhibit-a-source-code-form-license-notice","text":"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/. If it is not possible or desirable to put the notice in a particular file, then You may include the notice in a location (such as a LICENSE file in a relevant directory) where a recipient would be likely to look for such a notice. You may add additional accurate notices of copyright ownership.","title":"Exhibit A - Source Code Form License Notice"},{"location":"license/#exhibit-b-incompatible-with-secondary-licenses-notice","text":"This Source Code Form is \"Incompatible With Secondary Licenses\", as defined by the Mozilla Public License, v. 2.0.","title":"Exhibit B - \u201cIncompatible With Secondary Licenses\u201d Notice"},{"location":"api/","text":"Mapper Proxy API \u00b6 Automatically generated API reference. Mapper \u00b6 Clean Map Clock Config Delays Main Mapper Mud Events Utils World Protocols \u00b6 Base MPI Telnet Telnet Constants XML Room Data \u00b6 Database Room Objects","title":"API Index"},{"location":"api/#mapper-proxy-api","text":"Automatically generated API reference.","title":"Mapper Proxy API"},{"location":"api/#mapper","text":"Clean Map Clock Config Delays Main Mapper Mud Events Utils World","title":"Mapper"},{"location":"api/#protocols","text":"Base MPI Telnet Telnet Constants XML","title":"Protocols"},{"location":"api/#room-data","text":"Database Room Objects","title":"Room Data"},{"location":"api/cleanmap/","text":"Module mapper.cleanmap \u00b6 Class ExitsCleaner \u00b6 Method handle ( self , data ) \u00b6 Receives the output from the exit command in Mume. Checks if the output indicates any exits that are definitely not hidden despite being flagged as so, then removes any such secret exit from the map. Source code in mapper\\cleanmap.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def handle ( self , data ): \"\"\"Receives the output from the exit command in Mume. Checks if the output indicates any exits that are definitely not hidden despite being flagged as so, then removes any such secret exit from the map. \"\"\" if not self . mapper . autoUpdateRooms or data . startswith ( \"Exits:\" ): return for line in data . split ( \" \\r\\n \" ): m = exitRegexp . match ( line ) if m : room = self . mapper . currentRoom dir = m . group ( \"dir\" ) . lower () if self . mapper . isSynced and dir in room . exits and \"hidden\" in room . exits [ dir ] . doorFlags : self . mapper . user_command_secret ( \"remove \" + dir )","title":"cleanmap.py"},{"location":"api/cleanmap/#mapper.cleanmap","text":"","title":"cleanmap"},{"location":"api/cleanmap/#mapper.cleanmap.ExitsCleaner","text":"","title":"ExitsCleaner"},{"location":"api/cleanmap/#mapper.cleanmap.ExitsCleaner.handle","text":"Receives the output from the exit command in Mume. Checks if the output indicates any exits that are definitely not hidden despite being flagged as so, then removes any such secret exit from the map. Source code in mapper\\cleanmap.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def handle ( self , data ): \"\"\"Receives the output from the exit command in Mume. Checks if the output indicates any exits that are definitely not hidden despite being flagged as so, then removes any such secret exit from the map. \"\"\" if not self . mapper . autoUpdateRooms or data . startswith ( \"Exits:\" ): return for line in data . split ( \" \\r\\n \" ): m = exitRegexp . match ( line ) if m : room = self . mapper . currentRoom dir = m . group ( \"dir\" ) . lower () if self . mapper . isSynced and dir in room . exits and \"hidden\" in room . exits [ dir ] . doorFlags : self . mapper . user_command_secret ( \"remove \" + dir )","title":"handle()"},{"location":"api/clock/","text":"Module mapper.clock \u00b6 Class Clock \u00b6 Attribute epoch: int property writable \u00b6 The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset. Method setTime ( self , year , month , day , hour , minutes ) \u00b6 Sets the Mume epoch from the current Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Source code in mapper\\clock.py 498 499 500 501 502 503 504 505 506 507 508 509 510 def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta Method time ( self , action = None ) \u00b6 Outputs information about the current Mume time. Parameters: Name Type Description Default action Optional[str] An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. None Returns: Type Description str The requested output. Source code in mapper\\clock.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info Class MumeTime \u00b6 Attribute amPm: str property readonly \u00b6 The AM - PM value. Attribute dawn: int property readonly \u00b6 The hour of dawn. Attribute dawnDuskState: Tuple [ str , str , int ] property readonly \u00b6 A tuple containing the current state name, the next state name, and the game hours until next state. Attribute day: int property readonly \u00b6 The day of the month (1 or more). Attribute dayOfYear: int property readonly \u00b6 The day of the year (1 or more). Attribute daysSinceFullMoon: int property readonly \u00b6 The days since last full moon (0 or more). Attribute daysSinceMoonCycle: int property readonly \u00b6 The days since last moon cycle (0 or more). Attribute daysUntilFullMoon: int property readonly \u00b6 The days until next full moon (1 or more). Attribute daysUntilMoonCycle: int property readonly \u00b6 The days until next moon cycle (1 or more). Attribute daysUntilSeason: int property readonly \u00b6 The days until next season (1 or more). Attribute daysUntilWinter: int property readonly \u00b6 The days until next winter (1 or more). Attribute delta: int property readonly \u00b6 The time as a delta. Attribute dusk: int property readonly \u00b6 The hour of dusk. Attribute hour: int property readonly \u00b6 The hour of the day (0 or more). Attribute hourOfMoonRise: int property readonly \u00b6 The hour of day when the moon will rise (0 or more). Attribute hourOfYear: int property readonly \u00b6 The hour of the year (0 or more). Attribute hoursSinceFullMoon: int property readonly \u00b6 The hours since last full moon (0 or more). Attribute hoursUntilFullMoon: int property readonly \u00b6 The hours Until full moon (1 or more). Attribute info: str property readonly \u00b6 A summery of information about this moment in Mume time. Attribute minutes: int property readonly \u00b6 The minutes of the hour (0 or more). Attribute month: int property readonly \u00b6 The month of the year (0 or more). Attribute monthName: str property readonly \u00b6 The name of the month. Attribute monthSindarin: str property readonly \u00b6 The name of the month in Sindarin. Attribute monthWestron: str property readonly \u00b6 The name of the month in Westron. Attribute overallDay: int property readonly \u00b6 The sum of all the elapsed years in days and the day of year (1 or more). Attribute rlHoursUntilSeason: int property readonly \u00b6 The real life hours until next season (1 or more). Attribute rlHoursUntilWinter: int property readonly \u00b6 The real life hours until next winter (0 or more). Attribute season: str property readonly \u00b6 The name of the season. Attribute weekday: str property readonly \u00b6 The name of the weekday. Attribute year: int property readonly \u00b6 The year. Function deltaToTime ( delta ) \u00b6 Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default delta int The delta. required Returns: Type Description Tuple[int, int, int, int, int] A tuple containing the Mume year, month, day, hour, and minutes. Source code in mapper\\clock.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def deltaToTime ( delta : int ) -> Tuple [ int , int , int , int , int ]: \"\"\" Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: delta: The delta. Returns: A tuple containing the Mume year, month, day, hour, and minutes. \"\"\" year = delta // MINUTES_PER_YEAR + FIRST_YEAR delta %= MINUTES_PER_YEAR month = delta // MINUTES_PER_MONTH # 0 - 11. delta %= MINUTES_PER_MONTH day = delta // MINUTES_PER_DAY + 1 # 1 - 30. delta %= MINUTES_PER_DAY hour = delta // MINUTES_PER_HOUR # 0 - 23. delta %= MINUTES_PER_HOUR minutes = delta # 0 - 59. return year , month , day , hour , minutes Function timeToDelta ( year , month , day , hour , minutes ) \u00b6 Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Returns: Type Description int The delta. Source code in mapper\\clock.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def timeToDelta ( year : int , month : int , day : int , hour : int , minutes : int ) -> int : \"\"\" Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). Returns: The delta. \"\"\" return ( ( year - FIRST_YEAR ) * MINUTES_PER_YEAR + month * MINUTES_PER_MONTH + ( day - 1 ) * MINUTES_PER_DAY + hour * MINUTES_PER_HOUR + minutes )","title":"clock.py"},{"location":"api/clock/#mapper.clock","text":"","title":"clock"},{"location":"api/clock/#mapper.clock.Clock","text":"","title":"Clock"},{"location":"api/clock/#mapper.clock.Clock.epoch","text":"The Mume epoch. The Mume epoch is the real life time (in seconds) when Mume time was last reset.","title":"epoch"},{"location":"api/clock/#mapper.clock.Clock.setTime","text":"Sets the Mume epoch from the current Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Source code in mapper\\clock.py 498 499 500 501 502 503 504 505 506 507 508 509 510 def setTime ( self , year : int , month : int , day : int , hour : int , minutes : int ) -> None : \"\"\" Sets the Mume epoch from the current Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). \"\"\" delta = timeToDelta ( year , month , day , hour , minutes ) self . epoch = int ( time . time ()) - delta","title":"setTime()"},{"location":"api/clock/#mapper.clock.Clock.time","text":"Outputs information about the current Mume time. Parameters: Name Type Description Default action Optional[str] An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. None Returns: Type Description str The requested output. Source code in mapper\\clock.py 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 def time ( self , action : Optional [ str ] = None ) -> str : \"\"\" Outputs information about the current Mume time. Args: action: An action to perform. If 'pull', output commands for looting mystical. If not None, output first line of output, preceded by the action. Otherwise, output the full information. Returns: The requested output. \"\"\" mt = MumeTime ( int ( time . time ()) - self . epoch ) if action == \"pull\" : return f \"pull lever { mt . day } \\n pull lever { mt . monthWestron } \" elif action is not None : return f \" { action } { mt . info . splitlines ()[ 0 ] } \" return mt . info","title":"time()"},{"location":"api/clock/#mapper.clock.MumeTime","text":"","title":"MumeTime"},{"location":"api/clock/#mapper.clock.MumeTime.amPm","text":"The AM - PM value.","title":"amPm"},{"location":"api/clock/#mapper.clock.MumeTime.dawn","text":"The hour of dawn.","title":"dawn"},{"location":"api/clock/#mapper.clock.MumeTime.dawnDuskState","text":"A tuple containing the current state name, the next state name, and the game hours until next state.","title":"dawnDuskState"},{"location":"api/clock/#mapper.clock.MumeTime.day","text":"The day of the month (1 or more).","title":"day"},{"location":"api/clock/#mapper.clock.MumeTime.dayOfYear","text":"The day of the year (1 or more).","title":"dayOfYear"},{"location":"api/clock/#mapper.clock.MumeTime.daysSinceFullMoon","text":"The days since last full moon (0 or more).","title":"daysSinceFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.daysSinceMoonCycle","text":"The days since last moon cycle (0 or more).","title":"daysSinceMoonCycle"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilFullMoon","text":"The days until next full moon (1 or more).","title":"daysUntilFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilMoonCycle","text":"The days until next moon cycle (1 or more).","title":"daysUntilMoonCycle"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilSeason","text":"The days until next season (1 or more).","title":"daysUntilSeason"},{"location":"api/clock/#mapper.clock.MumeTime.daysUntilWinter","text":"The days until next winter (1 or more).","title":"daysUntilWinter"},{"location":"api/clock/#mapper.clock.MumeTime.delta","text":"The time as a delta.","title":"delta"},{"location":"api/clock/#mapper.clock.MumeTime.dusk","text":"The hour of dusk.","title":"dusk"},{"location":"api/clock/#mapper.clock.MumeTime.hour","text":"The hour of the day (0 or more).","title":"hour"},{"location":"api/clock/#mapper.clock.MumeTime.hourOfMoonRise","text":"The hour of day when the moon will rise (0 or more).","title":"hourOfMoonRise"},{"location":"api/clock/#mapper.clock.MumeTime.hourOfYear","text":"The hour of the year (0 or more).","title":"hourOfYear"},{"location":"api/clock/#mapper.clock.MumeTime.hoursSinceFullMoon","text":"The hours since last full moon (0 or more).","title":"hoursSinceFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.hoursUntilFullMoon","text":"The hours Until full moon (1 or more).","title":"hoursUntilFullMoon"},{"location":"api/clock/#mapper.clock.MumeTime.info","text":"A summery of information about this moment in Mume time.","title":"info"},{"location":"api/clock/#mapper.clock.MumeTime.minutes","text":"The minutes of the hour (0 or more).","title":"minutes"},{"location":"api/clock/#mapper.clock.MumeTime.month","text":"The month of the year (0 or more).","title":"month"},{"location":"api/clock/#mapper.clock.MumeTime.monthName","text":"The name of the month.","title":"monthName"},{"location":"api/clock/#mapper.clock.MumeTime.monthSindarin","text":"The name of the month in Sindarin.","title":"monthSindarin"},{"location":"api/clock/#mapper.clock.MumeTime.monthWestron","text":"The name of the month in Westron.","title":"monthWestron"},{"location":"api/clock/#mapper.clock.MumeTime.overallDay","text":"The sum of all the elapsed years in days and the day of year (1 or more).","title":"overallDay"},{"location":"api/clock/#mapper.clock.MumeTime.rlHoursUntilSeason","text":"The real life hours until next season (1 or more).","title":"rlHoursUntilSeason"},{"location":"api/clock/#mapper.clock.MumeTime.rlHoursUntilWinter","text":"The real life hours until next winter (0 or more).","title":"rlHoursUntilWinter"},{"location":"api/clock/#mapper.clock.MumeTime.season","text":"The name of the season.","title":"season"},{"location":"api/clock/#mapper.clock.MumeTime.weekday","text":"The name of the weekday.","title":"weekday"},{"location":"api/clock/#mapper.clock.MumeTime.year","text":"The year.","title":"year"},{"location":"api/clock/#mapper.clock.deltaToTime","text":"Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default delta int The delta. required Returns: Type Description Tuple[int, int, int, int, int] A tuple containing the Mume year, month, day, hour, and minutes. Source code in mapper\\clock.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def deltaToTime ( delta : int ) -> Tuple [ int , int , int , int , int ]: \"\"\" Calculates the Mume time of a given delta. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: delta: The delta. Returns: A tuple containing the Mume year, month, day, hour, and minutes. \"\"\" year = delta // MINUTES_PER_YEAR + FIRST_YEAR delta %= MINUTES_PER_YEAR month = delta // MINUTES_PER_MONTH # 0 - 11. delta %= MINUTES_PER_MONTH day = delta // MINUTES_PER_DAY + 1 # 1 - 30. delta %= MINUTES_PER_DAY hour = delta // MINUTES_PER_HOUR # 0 - 23. delta %= MINUTES_PER_HOUR minutes = delta # 0 - 59. return year , month , day , hour , minutes","title":"deltaToTime()"},{"location":"api/clock/#mapper.clock.timeToDelta","text":"Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Parameters: Name Type Description Default year int The year. required month int Month of the year (0 - 11). required day int Day of the month (1 - 30). required hour int Hour of day (0 - 23). required minutes int Minutes of the hour (0 - 59). required Returns: Type Description int The delta. Source code in mapper\\clock.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def timeToDelta ( year : int , month : int , day : int , hour : int , minutes : int ) -> int : \"\"\" Calculates the delta of a given Mume time. The delta is the difference (in real seconds) between the last reset of Mume time and the given Mume time. Args: year: The year. month: Month of the year (0 - 11). day: Day of the month (1 - 30). hour: Hour of day (0 - 23). minutes: Minutes of the hour (0 - 59). Returns: The delta. \"\"\" return ( ( year - FIRST_YEAR ) * MINUTES_PER_YEAR + month * MINUTES_PER_MONTH + ( day - 1 ) * MINUTES_PER_DAY + hour * MINUTES_PER_HOUR + minutes )","title":"timeToDelta()"},{"location":"api/config/","text":"Module mapper.config \u00b6 Class Config \u00b6 Implements loading and saving of program configuration. Attribute name: str property writable \u00b6 The name of the configuration. Method __init__ ( self , name = 'config' ) special \u00b6 Defines the constructor for the object. Parameters: Name Type Description Default name str The name of the configuration. 'config' Source code in mapper\\config.py 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . name = name self . _config : MutableMapping = dict () self . reload () Method clear ( self ) inherited \u00b6 D.clear() -> None. Remove all items from D. Source code in mapper\\config.py 816 817 818 819 820 821 822 def clear ( self ): 'D.clear() -> None. Remove all items from D.' try : while True : self . popitem () except KeyError : pass Method get ( self , key , default = None ) inherited \u00b6 D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Source code in mapper\\config.py 657 658 659 660 661 662 def get ( self , key , default = None ): 'D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.' try : return self [ key ] except KeyError : return default Method items ( self ) inherited \u00b6 D.items() -> a set-like object providing a view on D's items Source code in mapper\\config.py 676 677 678 def items ( self ): \"D.items() -> a set-like object providing a view on D's items\" return ItemsView ( self ) Method keys ( self ) inherited \u00b6 D.keys() -> a set-like object providing a view on D's keys Source code in mapper\\config.py 672 673 674 def keys ( self ): \"D.keys() -> a set-like object providing a view on D's keys\" return KeysView ( self ) Method pop ( self , key , default =< object object at 0x009130A8 > ) inherited \u00b6 D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Source code in mapper\\config.py 790 791 792 793 794 795 796 797 798 799 800 801 802 def pop ( self , key , default = __marker ): '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. ''' try : value = self [ key ] except KeyError : if default is self . __marker : raise return default else : del self [ key ] return value Method popitem ( self ) inherited \u00b6 D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. Source code in mapper\\config.py 804 805 806 807 808 809 810 811 812 813 814 def popitem ( self ): '''D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. ''' try : key = next ( iter ( self )) except StopIteration : raise KeyError from None value = self [ key ] del self [ key ] return key , value Method reload ( self ) \u00b6 Reloads the configuration from disc. Source code in mapper\\config.py 71 72 73 74 75 def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . _name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . _name } .json\" )) Method save ( self ) \u00b6 Saves the configuration to disc. Source code in mapper\\config.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename = os . path . join ( DATA_DIRECTORY , f \" { self . _name } .json\" ) with self . _configLock : with codecs . open ( filename , \"wb\" , encoding = \"utf-8\" ) as fileObj : # Configuration should be stored using Windows style line endings (\\r\\n) # so the file can be viewed in Notepad. # However, codecs.open forces opening files in binary mode, which # prevents the use of the newline flag to force a particular delimiter for new lines. # The json data must therefore be modified to replace Unix line endings # with Windows line endings before it is written. data = json . dumps ( self . _config , sort_keys = True , indent = 2 ) fileObj . write ( data . replace ( \" \\n \" , \" \\r\\n \" )) Method setdefault ( self , key , default = None ) inherited \u00b6 D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Source code in mapper\\config.py 851 852 853 854 855 856 857 def setdefault ( self , key , default = None ): 'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D' try : return self [ key ] except KeyError : self [ key ] = default return default Method update ( * args , ** kwds ) inherited \u00b6 D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Source code in mapper\\config.py 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def update ( * args , ** kwds ): ''' D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v ''' if not args : raise TypeError ( \"descriptor 'update' of 'MutableMapping' object \" \"needs an argument\" ) self , * args = args if len ( args ) > 1 : raise TypeError ( 'update expected at most 1 arguments, got %d ' % len ( args )) if args : other = args [ 0 ] if isinstance ( other , Mapping ): for key in other : self [ key ] = other [ key ] elif hasattr ( other , \"keys\" ): for key in other . keys (): self [ key ] = other [ key ] else : for key , value in other : self [ key ] = value for key , value in kwds . items (): self [ key ] = value Method values ( self ) inherited \u00b6 D.values() -> an object providing a view on D's values Source code in mapper\\config.py 680 681 682 def values ( self ): \"D.values() -> an object providing a view on D's values\" return ValuesView ( self ) Class ConfigError \u00b6 Implements the base class for Config exceptions.","title":"config.py"},{"location":"api/config/#mapper.config","text":"","title":"config"},{"location":"api/config/#mapper.config.Config","text":"Implements loading and saving of program configuration.","title":"Config"},{"location":"api/config/#mapper.config.Config.name","text":"The name of the configuration.","title":"name"},{"location":"api/config/#mapper.config.Config.__init__","text":"Defines the constructor for the object. Parameters: Name Type Description Default name str The name of the configuration. 'config' Source code in mapper\\config.py 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , name : str = \"config\" ) -> None : \"\"\" Defines the constructor for the object. Args: name: The name of the configuration. \"\"\" super () . __init__ () self . name = name self . _config : MutableMapping = dict () self . reload ()","title":"__init__()"},{"location":"api/config/#mapper.config.Config.clear","text":"D.clear() -> None. Remove all items from D. Source code in mapper\\config.py 816 817 818 819 820 821 822 def clear ( self ): 'D.clear() -> None. Remove all items from D.' try : while True : self . popitem () except KeyError : pass","title":"clear()"},{"location":"api/config/#mapper.config.Config.get","text":"D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. Source code in mapper\\config.py 657 658 659 660 661 662 def get ( self , key , default = None ): 'D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.' try : return self [ key ] except KeyError : return default","title":"get()"},{"location":"api/config/#mapper.config.Config.items","text":"D.items() -> a set-like object providing a view on D's items Source code in mapper\\config.py 676 677 678 def items ( self ): \"D.items() -> a set-like object providing a view on D's items\" return ItemsView ( self )","title":"items()"},{"location":"api/config/#mapper.config.Config.keys","text":"D.keys() -> a set-like object providing a view on D's keys Source code in mapper\\config.py 672 673 674 def keys ( self ): \"D.keys() -> a set-like object providing a view on D's keys\" return KeysView ( self )","title":"keys()"},{"location":"api/config/#mapper.config.Config.pop","text":"D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. Source code in mapper\\config.py 790 791 792 793 794 795 796 797 798 799 800 801 802 def pop ( self , key , default = __marker ): '''D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. ''' try : value = self [ key ] except KeyError : if default is self . __marker : raise return default else : del self [ key ] return value","title":"pop()"},{"location":"api/config/#mapper.config.Config.popitem","text":"D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. Source code in mapper\\config.py 804 805 806 807 808 809 810 811 812 813 814 def popitem ( self ): '''D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. ''' try : key = next ( iter ( self )) except StopIteration : raise KeyError from None value = self [ key ] del self [ key ] return key , value","title":"popitem()"},{"location":"api/config/#mapper.config.Config.reload","text":"Reloads the configuration from disc. Source code in mapper\\config.py 71 72 73 74 75 def reload ( self ) -> None : \"\"\"Reloads the configuration from disc.\"\"\" self . _config . clear () self . _config . update ( self . _parse ( f \" { self . _name } .json.sample\" )) self . _config . update ( self . _parse ( f \" { self . _name } .json\" ))","title":"reload()"},{"location":"api/config/#mapper.config.Config.save","text":"Saves the configuration to disc. Source code in mapper\\config.py 77 78 79 80 81 82 83 84 85 86 87 88 89 def save ( self ) -> None : \"\"\"Saves the configuration to disc.\"\"\" filename = os . path . join ( DATA_DIRECTORY , f \" { self . _name } .json\" ) with self . _configLock : with codecs . open ( filename , \"wb\" , encoding = \"utf-8\" ) as fileObj : # Configuration should be stored using Windows style line endings (\\r\\n) # so the file can be viewed in Notepad. # However, codecs.open forces opening files in binary mode, which # prevents the use of the newline flag to force a particular delimiter for new lines. # The json data must therefore be modified to replace Unix line endings # with Windows line endings before it is written. data = json . dumps ( self . _config , sort_keys = True , indent = 2 ) fileObj . write ( data . replace ( \" \\n \" , \" \\r\\n \" ))","title":"save()"},{"location":"api/config/#mapper.config.Config.setdefault","text":"D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D Source code in mapper\\config.py 851 852 853 854 855 856 857 def setdefault ( self , key , default = None ): 'D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D' try : return self [ key ] except KeyError : self [ key ] = default return default","title":"setdefault()"},{"location":"api/config/#mapper.config.Config.update","text":"D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v Source code in mapper\\config.py 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 def update ( * args , ** kwds ): ''' D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v ''' if not args : raise TypeError ( \"descriptor 'update' of 'MutableMapping' object \" \"needs an argument\" ) self , * args = args if len ( args ) > 1 : raise TypeError ( 'update expected at most 1 arguments, got %d ' % len ( args )) if args : other = args [ 0 ] if isinstance ( other , Mapping ): for key in other : self [ key ] = other [ key ] elif hasattr ( other , \"keys\" ): for key in other . keys (): self [ key ] = other [ key ] else : for key , value in other : self [ key ] = value for key , value in kwds . items (): self [ key ] = value","title":"update()"},{"location":"api/config/#mapper.config.Config.values","text":"D.values() -> an object providing a view on D's values Source code in mapper\\config.py 680 681 682 def values ( self ): \"D.values() -> an object providing a view on D's values\" return ValuesView ( self )","title":"values()"},{"location":"api/config/#mapper.config.ConfigError","text":"Implements the base class for Config exceptions.","title":"ConfigError"},{"location":"api/delays/","text":"Module mapper.delays \u00b6 Class BaseDelay \u00b6 Implements the base delay class. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method __init__ ( self , duration , count , function , * args , ** kwargs ) special \u00b6 Parameters: Name Type Description Default duration int The amount of time (in seconds) to delay between iterations. required count Union[int, None] The number of iterations to delay, or None to repeat indefinitely. required function Callable[..., Any] The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. required Source code in mapper\\delays.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , duration : int , count : Union [ int , None ], function : Callable [ ... , Any ], * args , ** kwargs ) -> None : \"\"\" Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon = True self . _duration = duration self . _count = count self . _function = function self . _args = args self . _kwargs = kwargs self . _finished = threading . Event () Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) \u00b6 Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class Delay \u00b6 Implements a delay which automatically starts upon creation. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class OneShot \u00b6 Implements a delay which is run only once. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method __init__ ( self , duration , function , * args , ** kwargs ) special \u00b6 Parameters: Name Type Description Default duration int The amount of time (in seconds) to delay. required function Callable[..., Any] The function to be called when the delay completes. Any remaining positional or keyword arguments will be passed to this function. required Source code in mapper\\delays.py 75 76 77 78 79 80 81 82 def __init__ ( self , duration : int , function : Callable [ ... , Any ], * args , ** kwargs ) -> None : \"\"\" Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. Any remaining positional or keyword arguments will be passed to this function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs ) Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set () Class Repeating \u00b6 Implements a delay which runs indefinitely. Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method __init__ ( self , duration , function , * args , ** kwargs ) special \u00b6 Parameters: Name Type Description Default duration int The amount of time (in seconds) to delay between iterations. required function Callable[..., Any] The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. required Source code in mapper\\delays.py 90 91 92 93 94 95 96 97 def __init__ ( self , duration : int , function : Callable [ ... , Any ], * args , ** kwargs ) -> None : \"\"\" Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs ) Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) inherited \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method stop ( self ) inherited \u00b6 Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"delays.py"},{"location":"api/delays/#mapper.delays","text":"","title":"delays"},{"location":"api/delays/#mapper.delays.BaseDelay","text":"Implements the base delay class.","title":"BaseDelay"},{"location":"api/delays/#mapper.delays.BaseDelay.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.BaseDelay.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.BaseDelay.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.BaseDelay.__init__","text":"Parameters: Name Type Description Default duration int The amount of time (in seconds) to delay between iterations. required count Union[int, None] The number of iterations to delay, or None to repeat indefinitely. required function Callable[..., Any] The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. required Source code in mapper\\delays.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def __init__ ( self , duration : int , count : Union [ int , None ], function : Callable [ ... , Any ], * args , ** kwargs ) -> None : \"\"\" Args: duration: The amount of time (in seconds) to delay between iterations. count: The number of iterations to delay, or None to repeat indefinitely. function: The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. \"\"\" if count is not None and count < 0 : raise ValueError ( \"count must be a positive number or None.\" ) super () . __init__ () self . daemon = True self . _duration = duration self . _count = count self . _function = function self . _args = args self . _kwargs = kwargs self . _finished = threading . Event ()","title":"__init__()"},{"location":"api/delays/#mapper.delays.BaseDelay.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.BaseDelay.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.BaseDelay.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.BaseDelay.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self )","title":"run()"},{"location":"api/delays/#mapper.delays.BaseDelay.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.BaseDelay.stop","text":"Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.Delay","text":"Implements a delay which automatically starts upon creation.","title":"Delay"},{"location":"api/delays/#mapper.delays.Delay.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.Delay.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.Delay.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.Delay.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.Delay.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.Delay.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.Delay.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self )","title":"run()"},{"location":"api/delays/#mapper.delays.Delay.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.Delay.stop","text":"Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.OneShot","text":"Implements a delay which is run only once.","title":"OneShot"},{"location":"api/delays/#mapper.delays.OneShot.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.OneShot.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.OneShot.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.OneShot.__init__","text":"Parameters: Name Type Description Default duration int The amount of time (in seconds) to delay. required function Callable[..., Any] The function to be called when the delay completes. Any remaining positional or keyword arguments will be passed to this function. required Source code in mapper\\delays.py 75 76 77 78 79 80 81 82 def __init__ ( self , duration : int , function : Callable [ ... , Any ], * args , ** kwargs ) -> None : \"\"\" Args: duration: The amount of time (in seconds) to delay. function: The function to be called when the delay completes. Any remaining positional or keyword arguments will be passed to this function. \"\"\" super () . __init__ ( duration , 1 , function , * args , ** kwargs )","title":"__init__()"},{"location":"api/delays/#mapper.delays.OneShot.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.OneShot.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.OneShot.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.OneShot.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self )","title":"run()"},{"location":"api/delays/#mapper.delays.OneShot.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.OneShot.stop","text":"Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/delays/#mapper.delays.Repeating","text":"Implements a delay which runs indefinitely.","title":"Repeating"},{"location":"api/delays/#mapper.delays.Repeating.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/delays/#mapper.delays.Repeating.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/delays/#mapper.delays.Repeating.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/delays/#mapper.delays.Repeating.__init__","text":"Parameters: Name Type Description Default duration int The amount of time (in seconds) to delay between iterations. required function Callable[..., Any] The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. required Source code in mapper\\delays.py 90 91 92 93 94 95 96 97 def __init__ ( self , duration : int , function : Callable [ ... , Any ], * args , ** kwargs ) -> None : \"\"\" Args: duration: The amount of time (in seconds) to delay between iterations. function: The function to be called at each iteration. Any remaining positional or keyword arguments will be passed to this function. \"\"\" super () . __init__ ( duration , None , function , * args , ** kwargs )","title":"__init__()"},{"location":"api/delays/#mapper.delays.Repeating.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\delays.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/delays/#mapper.delays.Repeating.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\delays.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/delays/#mapper.delays.Repeating.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\delays.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/delays/#mapper.delays.Repeating.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\delays.py 46 47 48 49 50 51 52 53 54 55 56 57 def run ( self ) -> None : try : self . _delays . append ( self ) while not self . _finished . is_set () and self . _count != 0 : self . _finished . wait ( self . _duration ) if not self . _finished . is_set (): self . _function ( * self . _args , ** self . _kwargs ) if self . _count is not None : self . _count -= 1 finally : del self . _function , self . _args , self . _kwargs self . _delays . remove ( self )","title":"run()"},{"location":"api/delays/#mapper.delays.Repeating.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\delays.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/delays/#mapper.delays.Repeating.stop","text":"Stops an active delay. Source code in mapper\\delays.py 42 43 44 def stop ( self ) -> None : \"\"\"Stops an active delay.\"\"\" self . _finished . set ()","title":"stop()"},{"location":"api/main/","text":"Module mapper.main \u00b6 Class BufferedSSLSocket \u00b6 Attribute family inherited property readonly \u00b6 A passthrough to the wrapped socket's family. BufferedSocket supports all widely-used families, so this read-only attribute can be one of :data: socket.AF_INET for IP, :data: socket.AF_INET6 for IPv6, and :data: socket.AF_UNIX for UDS. Attribute proto inherited property readonly \u00b6 A passthrough to the wrapped socket's protocol. The proto attribute is very rarely used, so it's always 0, meaning \"the default\" protocol. Pretty much all the practical information is in :attr: ~BufferedSocket.type and :attr: ~BufferedSocket.family , so you can go back to never thinking about this. Attribute type inherited property readonly \u00b6 A passthrough to the wrapped socket's type. Valid usages should only ever see :data: socket.SOCK_STREAM . Method buffer ( self , data ) inherited \u00b6 Buffer data bytes for the next send operation. Source code in mapper\\main.py 448 449 450 451 452 def buffer ( self , data ): \"Buffer *data* bytes for the next send operation.\" with self . _send_lock : self . sbuf . append ( data ) return Method close ( self ) inherited \u00b6 Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth: ~BufferedSocket.buffer , be sure to call :meth: ~BufferedSocket.flush before calling this method. After calling this method, future socket operations will raise :exc: socket.error . Source code in mapper\\main.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def close ( self ): \"\"\"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth:`~BufferedSocket.buffer`, be sure to call :meth:`~BufferedSocket.flush` before calling this method. After calling this method, future socket operations will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : with self . _send_lock : self . rbuf = b '' self . rbuf_unconsumed = self . rbuf self . sbuf [:] = [] self . sock . close () return Method fileno ( self ) inherited \u00b6 Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling recv* functions. Source code in mapper\\main.py 518 519 520 521 522 523 524 525 526 527 528 def fileno ( self ): \"\"\"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling ``recv*`` functions. \"\"\" return self . sock . fileno () Method flush ( self ) inherited \u00b6 Send the contents of the internal send buffer. Source code in mapper\\main.py 442 443 444 445 446 def flush ( self ): \"Send the contents of the internal send buffer.\" with self . _send_lock : self . send ( b '' ) return Method getpeername ( self ) inherited \u00b6 Convenience function to return the remote address to which the wrapped socket is connected. See :meth: socket.getpeername for more details. Source code in mapper\\main.py 464 465 466 467 468 469 def getpeername ( self ): \"\"\"Convenience function to return the remote address to which the wrapped socket is connected. See :meth:`socket.getpeername` for more details. \"\"\" return self . sock . getpeername () Method getrecvbuffer ( self ) inherited \u00b6 Returns the receive buffer bytestring (rbuf). Source code in mapper\\main.py 158 159 160 161 def getrecvbuffer ( self ): \"Returns the receive buffer bytestring (rbuf).\" with self . _recv_lock : return self . rbuf Method getsendbuffer ( self ) inherited \u00b6 Returns a copy of the send buffer list. Source code in mapper\\main.py 163 164 165 166 def getsendbuffer ( self ): \"Returns a copy of the send buffer list.\" with self . _send_lock : return b '' . join ( self . sbuf ) Method getsockname ( self ) inherited \u00b6 Convenience function to return the wrapped socket's own address. See :meth: socket.getsockname for more details. Source code in mapper\\main.py 458 459 460 461 462 def getsockname ( self ): \"\"\"Convenience function to return the wrapped socket's own address. See :meth:`socket.getsockname` for more details. \"\"\" return self . sock . getsockname () Method getsockopt ( self , level , optname , buflen = None ) inherited \u00b6 Convenience function passing through to the wrapped socket's :meth: socket.getsockopt . Source code in mapper\\main.py 471 472 473 474 475 476 477 478 def getsockopt ( self , level , optname , buflen = None ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.getsockopt`. \"\"\" args = ( level , optname ) if buflen is not None : args += ( buflen ,) return self . sock . getsockopt ( * args ) Method peek ( self , size , timeout =< object object at 0x00913C48 > ) inherited \u00b6 Returns size bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth: getrecvbuffer . Parameters: Name Type Description Default size int The exact number of bytes to peek at required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\main.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def peek ( self , size , timeout = _UNSET ): \"\"\"Returns *size* bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth:`getrecvbuffer`. Args: size (int): The exact number of bytes to peek at timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if len ( self . rbuf ) >= size : return self . rbuf [: size ] data = self . recv_size ( size , timeout = timeout ) self . rbuf = data + self . rbuf return data Method recv ( self , size , flags = 0 , timeout =< object object at 0x00913C48 > ) inherited \u00b6 Returns up to size bytes, using the internal buffer before performing a single :meth: socket.recv operation. Parameters: Name Type Description Default size int The maximum number of bytes to receive. required flags int Kept for API compatibility with sockets. Only the default, 0 , is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> If the operation does not complete in timeout seconds, a :exc: Timeout is raised. Much like the built-in :class: socket.socket , if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc: socket.error . Source code in mapper\\main.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def recv ( self , size , flags = 0 , timeout = _UNSET ): \"\"\"Returns **up to** *size* bytes, using the internal buffer before performing a single :meth:`socket.recv` operation. Args: size (int): The maximum number of bytes to receive. flags (int): Kept for API compatibility with sockets. Only the default, ``0``, is valid. timeout (float): The timeout for this operation. Can be ``0`` for nonblocking and ``None`` for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the operation does not complete in *timeout* seconds, a :exc:`Timeout` is raised. Much like the built-in :class:`socket.socket`, if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported: %r \" % flags ) if len ( self . rbuf ) >= size : data , self . rbuf = self . rbuf [: size ], self . rbuf [ size :] return data if self . rbuf : ret , self . rbuf = self . rbuf , b '' return ret self . sock . settimeout ( timeout ) try : data = self . sock . recv ( self . _recvsize ) except socket . timeout : raise Timeout ( timeout ) # check the rbuf attr for more if len ( data ) > size : data , self . rbuf = data [: size ], data [ size :] return data Method recv_close ( self , timeout =< object object at 0x00913C48 > , maxsize =< object object at 0x00913C48 > ) inherited \u00b6 Receive until the connection is closed, up to maxsize bytes. If more than maxsize bytes are received, raises :exc: MessageTooLong . Source code in mapper\\main.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def recv_close ( self , timeout = _UNSET , maxsize = _UNSET ): \"\"\"Receive until the connection is closed, up to *maxsize* bytes. If more than *maxsize* bytes are received, raises :exc:`MessageTooLong`. \"\"\" # recv_close works by using recv_size to request maxsize data, # and ignoring ConnectionClose, returning and clearing the # internal buffer instead. It raises an exception if # ConnectionClosed isn't raised. with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE try : recvd = self . recv_size ( maxsize + 1 , timeout ) except ConnectionClosed : ret , self . rbuf = self . rbuf , b '' else : # put extra received bytes (now in rbuf) after recvd self . rbuf = recvd + self . rbuf size_read = min ( maxsize , len ( self . rbuf )) raise MessageTooLong ( size_read ) # check receive buffer return ret Method recv_size ( self , size , timeout =< object object at 0x00913C48 > ) inherited \u00b6 Read off of the internal buffer, then off the socket, until size bytes have been read. Parameters: Name Type Description Default size int number of bytes to read before returning. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\main.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def recv_size ( self , size , timeout = _UNSET ): \"\"\"Read off of the internal buffer, then off the socket, until *size* bytes have been read. Args: size (int): number of bytes to read before returning. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout chunks = [] total_bytes = 0 try : start = time . time () self . sock . settimeout ( timeout ) nxt = self . rbuf or self . sock . recv ( self . _recvsize ) while nxt : total_bytes += len ( nxt ) if total_bytes >= size : break chunks . append ( nxt ) if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) nxt = self . sock . recv ( self . _recvsize ) else : msg = ( 'connection closed after reading %s of %s requested' ' bytes' % ( total_bytes , size )) raise ConnectionClosed ( msg ) # check recv buffer except socket . timeout : self . rbuf = b '' . join ( chunks ) msg = 'read %s of %s bytes' % ( total_bytes , size ) raise Timeout ( timeout , msg ) # check recv buffer except Exception : # received data is still buffered in the case of errors self . rbuf = b '' . join ( chunks ) raise extra_bytes = total_bytes - size if extra_bytes : last , self . rbuf = nxt [: - extra_bytes ], nxt [ - extra_bytes :] else : last , self . rbuf = nxt , b '' chunks . append ( last ) return b '' . join ( chunks ) Method recv_until ( self , delimiter , timeout =< object object at 0x00913C48 > , maxsize =< object object at 0x00913C48 > , with_delimiter = False ) inherited \u00b6 Receive until delimiter is found, maxsize bytes have been read, or timeout is exceeded. Parameters: Name Type Description Default delimiter bytes One or more bytes to be searched for in the socket stream. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> maxsize int The maximum size for the internal buffer. Defaults to the value set in the constructor. <object object at 0x00913C48> with_delimiter bool Whether or not to include the delimiter in the output. False by default, but True is useful in cases where one is simply forwarding the messages. False recv_until will raise the following exceptions: :exc: Timeout if more than timeout seconds expire. :exc: ConnectionClosed if the underlying socket is closed by the sending end. :exc: MessageTooLong if the delimiter is not found in the first maxsize bytes. :exc: socket.error if operating in nonblocking mode ( timeout equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. Source code in mapper\\main.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ): \"\"\"Receive until *delimiter* is found, *maxsize* bytes have been read, or *timeout* is exceeded. Args: delimiter (bytes): One or more bytes to be searched for in the socket stream. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. maxsize (int): The maximum size for the internal buffer. Defaults to the value set in the constructor. with_delimiter (bool): Whether or not to include the delimiter in the output. ``False`` by default, but ``True`` is useful in cases where one is simply forwarding the messages. ``recv_until`` will raise the following exceptions: * :exc:`Timeout` if more than *timeout* seconds expire. * :exc:`ConnectionClosed` if the underlying socket is closed by the sending end. * :exc:`MessageTooLong` if the delimiter is not found in the first *maxsize* bytes. * :exc:`socket.error` if operating in nonblocking mode (*timeout* equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. \"\"\" with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE if timeout is _UNSET : timeout = self . timeout len_delimiter = len ( delimiter ) sock = self . sock recvd = bytearray ( self . rbuf ) start = time . time () find_offset_start = 0 # becomes a negative index below if not timeout : # covers None (no timeout) and 0 (nonblocking) sock . settimeout ( timeout ) try : while 1 : offset = recvd . find ( delimiter , find_offset_start , maxsize ) if offset != - 1 : # str.find returns -1 when no match found if with_delimiter : # include delimiter in return offset += len_delimiter rbuf_offset = offset else : rbuf_offset = offset + len_delimiter break elif len ( recvd ) > maxsize : raise MessageTooLong ( maxsize , delimiter ) # see rbuf if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () sock . settimeout ( cur_timeout ) nxt = sock . recv ( self . _recvsize ) if not nxt : args = ( len ( recvd ), delimiter ) msg = ( 'connection closed after reading %s bytes' ' without finding symbol: %r ' % args ) raise ConnectionClosed ( msg ) # check the recv buffer recvd . extend ( nxt ) find_offset_start = - len ( nxt ) - len_delimiter + 1 except socket . timeout : self . rbuf = bytes ( recvd ) msg = ( 'read %s bytes without finding delimiter: %r ' % ( len ( recvd ), delimiter )) raise Timeout ( timeout , msg ) # check the recv buffer except Exception : self . rbuf = bytes ( recvd ) raise val , self . rbuf = bytes ( recvd [: offset ]), bytes ( recvd [ rbuf_offset :]) return val Method send ( self , data , flags = 0 , timeout =< object object at 0x00913C48 > ) inherited \u00b6 Send the contents of the internal send buffer, as well as data , to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of data was sent and the internal send buffer is empty. Parameters: Name Type Description Default data bytes The bytes to send. required flags int Kept for API compatibility with sockets. Only the default 0 is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> Will raise :exc: Timeout if the send operation fails to complete before timeout . In the event of an exception, use :meth: BufferedSocket.getsendbuffer to see which data was unsent. Source code in mapper\\main.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def send ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"Send the contents of the internal send buffer, as well as *data*, to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of *data* was sent and the internal send buffer is empty. Args: data (bytes): The bytes to send. flags (int): Kept for API compatibility with sockets. Only the default 0 is valid. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. Will raise :exc:`Timeout` if the send operation fails to complete before *timeout*. In the event of an exception, use :meth:`BufferedSocket.getsendbuffer` to see which data was unsent. \"\"\" with self . _send_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported\" ) sbuf = self . sbuf sbuf . append ( data ) if len ( sbuf ) > 1 : sbuf [:] = [ b '' . join ([ s for s in sbuf if s ])] self . sock . settimeout ( timeout ) start , total_sent = time . time (), 0 try : while sbuf [ 0 ]: sent = self . sock . send ( sbuf [ 0 ]) total_sent += sent sbuf [ 0 ] = sbuf [ 0 ][ sent :] if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) except socket . timeout : raise Timeout ( timeout , ' %s bytes unsent' % len ( sbuf [ 0 ])) return total_sent Method sendall ( self , data , flags = 0 , timeout =< object object at 0x00913C48 > ) inherited \u00b6 A passthrough to :meth: ~BufferedSocket.send , retained for parallelism to the :class: socket.socket API. Source code in mapper\\main.py 436 437 438 439 440 def sendall ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"A passthrough to :meth:`~BufferedSocket.send`, retained for parallelism to the :class:`socket.socket` API. \"\"\" return self . send ( data , flags , timeout ) Method setmaxsize ( self , maxsize ) inherited \u00b6 Set the default maximum buffer size maxsize for future operations, in bytes. Does not truncate the current buffer. Source code in mapper\\main.py 152 153 154 155 156 def setmaxsize ( self , maxsize ): \"\"\"Set the default maximum buffer size *maxsize* for future operations, in bytes. Does not truncate the current buffer. \"\"\" self . maxsize = maxsize Method setsockopt ( self , level , optname , value ) inherited \u00b6 Convenience function passing through to the wrapped socket's :meth: socket.setsockopt . Source code in mapper\\main.py 480 481 482 483 484 def setsockopt ( self , level , optname , value ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.setsockopt`. \"\"\" return self . sock . setsockopt ( level , optname , value ) Method settimeout ( self , timeout ) inherited \u00b6 Set the default timeout for future operations, in seconds. Source code in mapper\\main.py 142 143 144 def settimeout ( self , timeout ): \"Set the default *timeout* for future operations, in seconds.\" self . timeout = timeout Method shutdown ( self , how ) inherited \u00b6 Convenience method which passes through to the wrapped socket's :meth: ~socket.shutdown . Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full shutdown is followed by a :meth: ~BufferedSocket.close . Developers requiring more support, please open an issue _. .. _an issue: https://github.com/mahmoud/boltons/issues Source code in mapper\\main.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 def shutdown ( self , how ): \"\"\"Convenience method which passes through to the wrapped socket's :meth:`~socket.shutdown`. Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full ``shutdown`` is followed by a :meth:`~BufferedSocket.close`. Developers requiring more support, please open `an issue`_. .. _an issue: https://github.com/mahmoud/boltons/issues \"\"\" with self . _recv_lock : with self . _send_lock : self . sock . shutdown ( how ) return Class Game \u00b6 Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def run ( self ): while not self . finished . isSet (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except MockedSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Class Player \u00b6 Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def run ( self ): while not self . finished . isSet (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"main.py"},{"location":"api/main/#mapper.main","text":"","title":"main"},{"location":"api/main/#mapper.main.BufferedSSLSocket","text":"","title":"BufferedSSLSocket"},{"location":"api/main/#mapper.main.BufferedSSLSocket.family","text":"A passthrough to the wrapped socket's family. BufferedSocket supports all widely-used families, so this read-only attribute can be one of :data: socket.AF_INET for IP, :data: socket.AF_INET6 for IPv6, and :data: socket.AF_UNIX for UDS.","title":"family"},{"location":"api/main/#mapper.main.BufferedSSLSocket.proto","text":"A passthrough to the wrapped socket's protocol. The proto attribute is very rarely used, so it's always 0, meaning \"the default\" protocol. Pretty much all the practical information is in :attr: ~BufferedSocket.type and :attr: ~BufferedSocket.family , so you can go back to never thinking about this.","title":"proto"},{"location":"api/main/#mapper.main.BufferedSSLSocket.type","text":"A passthrough to the wrapped socket's type. Valid usages should only ever see :data: socket.SOCK_STREAM .","title":"type"},{"location":"api/main/#mapper.main.BufferedSSLSocket.buffer","text":"Buffer data bytes for the next send operation. Source code in mapper\\main.py 448 449 450 451 452 def buffer ( self , data ): \"Buffer *data* bytes for the next send operation.\" with self . _send_lock : self . sbuf . append ( data ) return","title":"buffer()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.close","text":"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth: ~BufferedSocket.buffer , be sure to call :meth: ~BufferedSocket.flush before calling this method. After calling this method, future socket operations will raise :exc: socket.error . Source code in mapper\\main.py 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 def close ( self ): \"\"\"Closes the wrapped socket, and empties the internal buffers. The send buffer is not flushed automatically, so if you have been calling :meth:`~BufferedSocket.buffer`, be sure to call :meth:`~BufferedSocket.flush` before calling this method. After calling this method, future socket operations will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : with self . _send_lock : self . rbuf = b '' self . rbuf_unconsumed = self . rbuf self . sbuf [:] = [] self . sock . close () return","title":"close()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.fileno","text":"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling recv* functions. Source code in mapper\\main.py 518 519 520 521 522 523 524 525 526 527 528 def fileno ( self ): \"\"\"Returns the file descriptor of the wrapped socket. -1 if it has been closed on this end. Note that this makes the BufferedSocket selectable, i.e., usable for operating system event loops without any external libraries. Keep in mind that the operating system cannot know about data in BufferedSocket's internal buffer. Exercise discipline with calling ``recv*`` functions. \"\"\" return self . sock . fileno ()","title":"fileno()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.flush","text":"Send the contents of the internal send buffer. Source code in mapper\\main.py 442 443 444 445 446 def flush ( self ): \"Send the contents of the internal send buffer.\" with self . _send_lock : self . send ( b '' ) return","title":"flush()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.getpeername","text":"Convenience function to return the remote address to which the wrapped socket is connected. See :meth: socket.getpeername for more details. Source code in mapper\\main.py 464 465 466 467 468 469 def getpeername ( self ): \"\"\"Convenience function to return the remote address to which the wrapped socket is connected. See :meth:`socket.getpeername` for more details. \"\"\" return self . sock . getpeername ()","title":"getpeername()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.getrecvbuffer","text":"Returns the receive buffer bytestring (rbuf). Source code in mapper\\main.py 158 159 160 161 def getrecvbuffer ( self ): \"Returns the receive buffer bytestring (rbuf).\" with self . _recv_lock : return self . rbuf","title":"getrecvbuffer()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.getsendbuffer","text":"Returns a copy of the send buffer list. Source code in mapper\\main.py 163 164 165 166 def getsendbuffer ( self ): \"Returns a copy of the send buffer list.\" with self . _send_lock : return b '' . join ( self . sbuf )","title":"getsendbuffer()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.getsockname","text":"Convenience function to return the wrapped socket's own address. See :meth: socket.getsockname for more details. Source code in mapper\\main.py 458 459 460 461 462 def getsockname ( self ): \"\"\"Convenience function to return the wrapped socket's own address. See :meth:`socket.getsockname` for more details. \"\"\" return self . sock . getsockname ()","title":"getsockname()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.getsockopt","text":"Convenience function passing through to the wrapped socket's :meth: socket.getsockopt . Source code in mapper\\main.py 471 472 473 474 475 476 477 478 def getsockopt ( self , level , optname , buflen = None ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.getsockopt`. \"\"\" args = ( level , optname ) if buflen is not None : args += ( buflen ,) return self . sock . getsockopt ( * args )","title":"getsockopt()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.peek","text":"Returns size bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth: getrecvbuffer . Parameters: Name Type Description Default size int The exact number of bytes to peek at required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\main.py 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def peek ( self , size , timeout = _UNSET ): \"\"\"Returns *size* bytes from the socket and/or internal buffer. Bytes are retained in BufferedSocket's internal recv buffer. To only see bytes in the recv buffer, use :meth:`getrecvbuffer`. Args: size (int): The exact number of bytes to peek at timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if len ( self . rbuf ) >= size : return self . rbuf [: size ] data = self . recv_size ( size , timeout = timeout ) self . rbuf = data + self . rbuf return data","title":"peek()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.recv","text":"Returns up to size bytes, using the internal buffer before performing a single :meth: socket.recv operation. Parameters: Name Type Description Default size int The maximum number of bytes to receive. required flags int Kept for API compatibility with sockets. Only the default, 0 , is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> If the operation does not complete in timeout seconds, a :exc: Timeout is raised. Much like the built-in :class: socket.socket , if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc: socket.error . Source code in mapper\\main.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def recv ( self , size , flags = 0 , timeout = _UNSET ): \"\"\"Returns **up to** *size* bytes, using the internal buffer before performing a single :meth:`socket.recv` operation. Args: size (int): The maximum number of bytes to receive. flags (int): Kept for API compatibility with sockets. Only the default, ``0``, is valid. timeout (float): The timeout for this operation. Can be ``0`` for nonblocking and ``None`` for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the operation does not complete in *timeout* seconds, a :exc:`Timeout` is raised. Much like the built-in :class:`socket.socket`, if this method returns an empty string, then the socket is closed and recv buffer is empty. Further calls to recv will raise :exc:`socket.error`. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported: %r \" % flags ) if len ( self . rbuf ) >= size : data , self . rbuf = self . rbuf [: size ], self . rbuf [ size :] return data if self . rbuf : ret , self . rbuf = self . rbuf , b '' return ret self . sock . settimeout ( timeout ) try : data = self . sock . recv ( self . _recvsize ) except socket . timeout : raise Timeout ( timeout ) # check the rbuf attr for more if len ( data ) > size : data , self . rbuf = data [: size ], data [ size :] return data","title":"recv()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.recv_close","text":"Receive until the connection is closed, up to maxsize bytes. If more than maxsize bytes are received, raises :exc: MessageTooLong . Source code in mapper\\main.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def recv_close ( self , timeout = _UNSET , maxsize = _UNSET ): \"\"\"Receive until the connection is closed, up to *maxsize* bytes. If more than *maxsize* bytes are received, raises :exc:`MessageTooLong`. \"\"\" # recv_close works by using recv_size to request maxsize data, # and ignoring ConnectionClose, returning and clearing the # internal buffer instead. It raises an exception if # ConnectionClosed isn't raised. with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE try : recvd = self . recv_size ( maxsize + 1 , timeout ) except ConnectionClosed : ret , self . rbuf = self . rbuf , b '' else : # put extra received bytes (now in rbuf) after recvd self . rbuf = recvd + self . rbuf size_read = min ( maxsize , len ( self . rbuf )) raise MessageTooLong ( size_read ) # check receive buffer return ret","title":"recv_close()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.recv_size","text":"Read off of the internal buffer, then off the socket, until size bytes have been read. Parameters: Name Type Description Default size int number of bytes to read before returning. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> If the appropriate number of bytes cannot be fetched from the buffer and socket before timeout expires, then a :exc: Timeout will be raised. If the connection is closed, a :exc: ConnectionClosed will be raised. Source code in mapper\\main.py 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 def recv_size ( self , size , timeout = _UNSET ): \"\"\"Read off of the internal buffer, then off the socket, until *size* bytes have been read. Args: size (int): number of bytes to read before returning. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. If the appropriate number of bytes cannot be fetched from the buffer and socket before *timeout* expires, then a :exc:`Timeout` will be raised. If the connection is closed, a :exc:`ConnectionClosed` will be raised. \"\"\" with self . _recv_lock : if timeout is _UNSET : timeout = self . timeout chunks = [] total_bytes = 0 try : start = time . time () self . sock . settimeout ( timeout ) nxt = self . rbuf or self . sock . recv ( self . _recvsize ) while nxt : total_bytes += len ( nxt ) if total_bytes >= size : break chunks . append ( nxt ) if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) nxt = self . sock . recv ( self . _recvsize ) else : msg = ( 'connection closed after reading %s of %s requested' ' bytes' % ( total_bytes , size )) raise ConnectionClosed ( msg ) # check recv buffer except socket . timeout : self . rbuf = b '' . join ( chunks ) msg = 'read %s of %s bytes' % ( total_bytes , size ) raise Timeout ( timeout , msg ) # check recv buffer except Exception : # received data is still buffered in the case of errors self . rbuf = b '' . join ( chunks ) raise extra_bytes = total_bytes - size if extra_bytes : last , self . rbuf = nxt [: - extra_bytes ], nxt [ - extra_bytes :] else : last , self . rbuf = nxt , b '' chunks . append ( last ) return b '' . join ( chunks )","title":"recv_size()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.recv_until","text":"Receive until delimiter is found, maxsize bytes have been read, or timeout is exceeded. Parameters: Name Type Description Default delimiter bytes One or more bytes to be searched for in the socket stream. required timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> maxsize int The maximum size for the internal buffer. Defaults to the value set in the constructor. <object object at 0x00913C48> with_delimiter bool Whether or not to include the delimiter in the output. False by default, but True is useful in cases where one is simply forwarding the messages. False recv_until will raise the following exceptions: :exc: Timeout if more than timeout seconds expire. :exc: ConnectionClosed if the underlying socket is closed by the sending end. :exc: MessageTooLong if the delimiter is not found in the first maxsize bytes. :exc: socket.error if operating in nonblocking mode ( timeout equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. Source code in mapper\\main.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def recv_until ( self , delimiter , timeout = _UNSET , maxsize = _UNSET , with_delimiter = False ): \"\"\"Receive until *delimiter* is found, *maxsize* bytes have been read, or *timeout* is exceeded. Args: delimiter (bytes): One or more bytes to be searched for in the socket stream. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. maxsize (int): The maximum size for the internal buffer. Defaults to the value set in the constructor. with_delimiter (bool): Whether or not to include the delimiter in the output. ``False`` by default, but ``True`` is useful in cases where one is simply forwarding the messages. ``recv_until`` will raise the following exceptions: * :exc:`Timeout` if more than *timeout* seconds expire. * :exc:`ConnectionClosed` if the underlying socket is closed by the sending end. * :exc:`MessageTooLong` if the delimiter is not found in the first *maxsize* bytes. * :exc:`socket.error` if operating in nonblocking mode (*timeout* equal to 0), or if some unexpected socket error occurs, such as operating on a closed socket. \"\"\" with self . _recv_lock : if maxsize is _UNSET : maxsize = self . maxsize if maxsize is None : maxsize = _RECV_LARGE_MAXSIZE if timeout is _UNSET : timeout = self . timeout len_delimiter = len ( delimiter ) sock = self . sock recvd = bytearray ( self . rbuf ) start = time . time () find_offset_start = 0 # becomes a negative index below if not timeout : # covers None (no timeout) and 0 (nonblocking) sock . settimeout ( timeout ) try : while 1 : offset = recvd . find ( delimiter , find_offset_start , maxsize ) if offset != - 1 : # str.find returns -1 when no match found if with_delimiter : # include delimiter in return offset += len_delimiter rbuf_offset = offset else : rbuf_offset = offset + len_delimiter break elif len ( recvd ) > maxsize : raise MessageTooLong ( maxsize , delimiter ) # see rbuf if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () sock . settimeout ( cur_timeout ) nxt = sock . recv ( self . _recvsize ) if not nxt : args = ( len ( recvd ), delimiter ) msg = ( 'connection closed after reading %s bytes' ' without finding symbol: %r ' % args ) raise ConnectionClosed ( msg ) # check the recv buffer recvd . extend ( nxt ) find_offset_start = - len ( nxt ) - len_delimiter + 1 except socket . timeout : self . rbuf = bytes ( recvd ) msg = ( 'read %s bytes without finding delimiter: %r ' % ( len ( recvd ), delimiter )) raise Timeout ( timeout , msg ) # check the recv buffer except Exception : self . rbuf = bytes ( recvd ) raise val , self . rbuf = bytes ( recvd [: offset ]), bytes ( recvd [ rbuf_offset :]) return val","title":"recv_until()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.send","text":"Send the contents of the internal send buffer, as well as data , to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of data was sent and the internal send buffer is empty. Parameters: Name Type Description Default data bytes The bytes to send. required flags int Kept for API compatibility with sockets. Only the default 0 is valid. 0 timeout float The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. <object object at 0x00913C48> Will raise :exc: Timeout if the send operation fails to complete before timeout . In the event of an exception, use :meth: BufferedSocket.getsendbuffer to see which data was unsent. Source code in mapper\\main.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 def send ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"Send the contents of the internal send buffer, as well as *data*, to the receiving end of the connection. Returns the total number of bytes sent. If no exception is raised, all of *data* was sent and the internal send buffer is empty. Args: data (bytes): The bytes to send. flags (int): Kept for API compatibility with sockets. Only the default 0 is valid. timeout (float): The timeout for this operation. Can be 0 for nonblocking and None for no timeout. Defaults to the value set in the constructor of BufferedSocket. Will raise :exc:`Timeout` if the send operation fails to complete before *timeout*. In the event of an exception, use :meth:`BufferedSocket.getsendbuffer` to see which data was unsent. \"\"\" with self . _send_lock : if timeout is _UNSET : timeout = self . timeout if flags : raise ValueError ( \"non-zero flags not supported\" ) sbuf = self . sbuf sbuf . append ( data ) if len ( sbuf ) > 1 : sbuf [:] = [ b '' . join ([ s for s in sbuf if s ])] self . sock . settimeout ( timeout ) start , total_sent = time . time (), 0 try : while sbuf [ 0 ]: sent = self . sock . send ( sbuf [ 0 ]) total_sent += sent sbuf [ 0 ] = sbuf [ 0 ][ sent :] if timeout : cur_timeout = timeout - ( time . time () - start ) if cur_timeout <= 0.0 : raise socket . timeout () self . sock . settimeout ( cur_timeout ) except socket . timeout : raise Timeout ( timeout , ' %s bytes unsent' % len ( sbuf [ 0 ])) return total_sent","title":"send()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.sendall","text":"A passthrough to :meth: ~BufferedSocket.send , retained for parallelism to the :class: socket.socket API. Source code in mapper\\main.py 436 437 438 439 440 def sendall ( self , data , flags = 0 , timeout = _UNSET ): \"\"\"A passthrough to :meth:`~BufferedSocket.send`, retained for parallelism to the :class:`socket.socket` API. \"\"\" return self . send ( data , flags , timeout )","title":"sendall()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.setmaxsize","text":"Set the default maximum buffer size maxsize for future operations, in bytes. Does not truncate the current buffer. Source code in mapper\\main.py 152 153 154 155 156 def setmaxsize ( self , maxsize ): \"\"\"Set the default maximum buffer size *maxsize* for future operations, in bytes. Does not truncate the current buffer. \"\"\" self . maxsize = maxsize","title":"setmaxsize()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.setsockopt","text":"Convenience function passing through to the wrapped socket's :meth: socket.setsockopt . Source code in mapper\\main.py 480 481 482 483 484 def setsockopt ( self , level , optname , value ): \"\"\"Convenience function passing through to the wrapped socket's :meth:`socket.setsockopt`. \"\"\" return self . sock . setsockopt ( level , optname , value )","title":"setsockopt()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.settimeout","text":"Set the default timeout for future operations, in seconds. Source code in mapper\\main.py 142 143 144 def settimeout ( self , timeout ): \"Set the default *timeout* for future operations, in seconds.\" self . timeout = timeout","title":"settimeout()"},{"location":"api/main/#mapper.main.BufferedSSLSocket.shutdown","text":"Convenience method which passes through to the wrapped socket's :meth: ~socket.shutdown . Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full shutdown is followed by a :meth: ~BufferedSocket.close . Developers requiring more support, please open an issue _. .. _an issue: https://github.com/mahmoud/boltons/issues Source code in mapper\\main.py 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 def shutdown ( self , how ): \"\"\"Convenience method which passes through to the wrapped socket's :meth:`~socket.shutdown`. Semantics vary by platform, so no special internal handling is done with the buffers. This method exists to facilitate the most common usage, wherein a full ``shutdown`` is followed by a :meth:`~BufferedSocket.close`. Developers requiring more support, please open `an issue`_. .. _an issue: https://github.com/mahmoud/boltons/issues \"\"\" with self . _recv_lock : with self . _send_lock : self . sock . shutdown ( how ) return","title":"shutdown()"},{"location":"api/main/#mapper.main.Game","text":"","title":"Game"},{"location":"api/main/#mapper.main.Game.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/main/#mapper.main.Game.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/main/#mapper.main.Game.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/main/#mapper.main.Game.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/main/#mapper.main.Game.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/main/#mapper.main.Game.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/main/#mapper.main.Game.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def run ( self ): while not self . finished . isSet (): try : data = self . game . recv ( 4096 ) if data : self . mapper . proxy . game . parse ( data ) else : self . close () except MockedSocketEmpty : continue except EnvironmentError : self . close () continue if self . mapper . interface != \"text\" : # Shutdown the gui self . mapper . _gui_queue . put ( None )","title":"run()"},{"location":"api/main/#mapper.main.Game.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/main/#mapper.main.Player","text":"","title":"Player"},{"location":"api/main/#mapper.main.Player.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/main/#mapper.main.Player.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/main/#mapper.main.Player.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/main/#mapper.main.Player.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\main.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/main/#mapper.main.Player.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\main.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/main/#mapper.main.Player.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\main.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/main/#mapper.main.Player.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\main.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def run ( self ): while not self . finished . isSet (): try : data = self . player . recv ( 4096 ) if data : self . mapper . proxy . player . parse ( data ) else : self . close () except socket . timeout : continue except EnvironmentError : self . close () continue if self . mapper . isEmulatingOffline : self . mapper . proxy . game . write ( b \"quit\" )","title":"run()"},{"location":"api/main/#mapper.main.Player.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\main.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/mapper/","text":"Module mapper.mapper \u00b6 Class Mapper \u00b6 Attribute daemon inherited property writable \u00b6 A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. Attribute ident inherited property readonly \u00b6 Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. Attribute name inherited property writable \u00b6 A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. Method createSpeedWalk ( self , directionsList ) inherited \u00b6 Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\mapper.py 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 def createSpeedWalk ( self , directionsList ): \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer ): speedWalkDirs = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections = len ([ d for d in directionsList if d in DIRECTIONS ]) result = [] directionsBuffer = [] while directionsList : item = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer = [] result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" Method deregisterMudEventHandler ( self , event , handler ) \u00b6 Deregisters mud event handlers. params: same as registerMudEventHandler. Source code in mapper\\mapper.py 1059 1060 1061 1062 1063 1064 def deregisterMudEventHandler ( self , event , handler ): \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler ) Method emulate_leave ( self , direction ) \u00b6 emulates leaving the room into a neighbouring room Source code in mapper\\mapper.py 374 375 376 377 378 379 380 381 382 383 384 385 def emulate_leave ( self , direction ): \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return room = self . emulationRoom . exits [ direction ] . to if \"death\" == room : self . output ( \"deathtrap!\" ) elif \"undefined\" == room : self . output ( \"undefined\" ) else : self . emulation_command_go ( room , isJump = False ) Method emulation_command_brief ( self , * args ) \u00b6 toggles brief mode. Source code in mapper\\mapper.py 289 290 291 292 def emulation_command_brief ( self , * args ): \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" ) Method emulation_command_examine ( self , * args ) \u00b6 shows the room's description. Source code in mapper\\mapper.py 294 295 296 def emulation_command_examine ( self , * args ): \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc ) Method emulation_command_exits ( self , * args ) \u00b6 shows the exits in the room. Source code in mapper\\mapper.py 298 299 300 301 def emulation_command_exits ( self , * args ): \"\"\"shows the exits in the room.\"\"\" exits = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" ) Method emulation_command_go ( self , label , isJump = True ) \u00b6 mimic the /go command that the ainur use. Source code in mapper\\mapper.py 303 304 305 306 307 308 309 310 311 312 313 314 315 def emulation_command_go ( self , label , isJump = True ): \"\"\"mimic the /go command that the ainur use.\"\"\" room , error = self . getRoomFromLabel ( label ) if error : self . output ( error ) return self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room Method emulation_command_help ( self , * args ) \u00b6 Shows documentation for mapper's emulation commands. Source code in mapper\\mapper.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def emulation_command_help ( self , * args ): \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs = [ text for text in helpTexts if not text [ 1 ] . strip ()] result = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) Method emulation_command_look ( self , * args ) \u00b6 looks at the room. Source code in mapper\\mapper.py 348 349 350 351 352 353 354 355 def emulation_command_look ( self , * args ): \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) self . output ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" ) Method emulation_command_quit ( self , * args ) \u00b6 Exits the program. Source code in mapper\\mapper.py 285 286 287 def emulation_command_quit ( self , * args ): \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" ) Method emulation_command_return ( self , * args ) \u00b6 returns to the last room jumped to with the go command. Source code in mapper\\mapper.py 357 358 359 360 361 362 def emulation_command_return ( self , * args ): \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" ) Method emulation_command_sync ( self , * args ) \u00b6 When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. Source code in mapper\\mapper.py 364 365 366 367 368 369 370 371 372 def emulation_command_sync ( self , * args ): \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom ) Method getNeighborsFromCoordinates ( self , start = None , radius = 1 ) inherited \u00b6 A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def getNeighborsFromCoordinates ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" try : iter ( start ) except TypeError : x = y = z = 0 else : x , y , z = start try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNeighborsFromRoom ( self , start = None , radius = 1 ) inherited \u00b6 A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def getNeighborsFromRoom ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" if start is None : start = self . currentRoom x , y , z = start . x , start . y , start . z try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getRoomFromLabel ( self , label ) inherited \u00b6 Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. Source code in mapper\\mapper.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 def getRoomFromLabel ( self , label ): \"\"\"Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. \"\"\" if isinstance ( label , roomdata . objects . Room ): return label , None label = label . strip () . lower () if not label : return None , \"No label or room vnum specified.\" elif label . isdecimal (): vnum = label if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , \"No room with vnum \" + vnum elif label in self . labels : vnum = self . labels [ label ] if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , f \" { label } is set to vnum { vnum } , but there is no room with that vnum\" else : # The label is neither a vnum nor an existing label similarLabels = list ( self . labels ) similarLabels . sort ( reverse = True , key = lambda l : fuzz . ratio ( l , label )) return None , f \"Unknown label. Did you mean { ', ' . join ( similarLabels [ 0 : 4 ]) } ?\" Method GUIRefresh ( self ) inherited \u00b6 Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\mapper.py 96 97 98 99 def GUIRefresh ( self ): \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,)) Method is_alive ( self ) inherited \u00b6 Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\mapper.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped Method isAlive ( self ) inherited \u00b6 Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\mapper.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive () Method isBidirectional ( self , exitObj ) inherited \u00b6 Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\mapper.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def isBidirectional ( self , exitObj ): \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest = self . rooms [ exitObj . to ] except KeyError : return False revdir = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False Method join ( self , timeout = None ) inherited \u00b6 Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\mapper.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 )) Method pathFind ( self , origin = None , destination = None , flags = None ) inherited \u00b6 Find the path Source code in mapper\\mapper.py 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 def pathFind ( self , origin = None , destination = None , flags = None ): \"\"\"Find the path\"\"\" origin = origin or self . currentRoom if not origin : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) destinationRoom , errorFindingDestination = self . getRoomFromLabel ( destination ) if errorFindingDestination : self . output ( errorFindingDestination ) return None if origin is destinationRoom : self . output ( \"You are already there!\" ) return [] if flags : avoidTerrains = frozenset ( terrain for terrain in roomdata . objects . TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc = lambda currentRoomObj : currentRoomObj is destinationRoom # NOQA: E731 exitIgnoreFunc = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc ) Method registerMudEventHandler ( self , event , handler ) \u00b6 Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, data, which is the text received from the mud. Source code in mapper\\mapper.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 def registerMudEventHandler ( self , event , handler ): \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, data, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () self . mudEventHandlers [ event ] . add ( handler ) Method run ( self ) \u00b6 Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\mapper.py 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 def run ( self ): while True : try : dataType , data = self . queue . get () if data is None : break elif dataType == USER_DATA : # The data was a valid mapper command, sent from the user's mud client. self . handleUserData ( data ) elif dataType == MUD_DATA : # The data was from the mud server. event , data = data self . handleMudEvent ( event , data ) except Exception as e : self . output ( \"map error\" ) print ( \"error \" + str ( e )) self . sendPlayer ( \"Exiting mapper thread.\" ) Method start ( self ) inherited \u00b6 Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\mapper.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait () Method user_command_maphelp ( self , * args ) \u00b6 Shows documentation for mapper commands Source code in mapper\\mapper.py 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 def user_command_maphelp ( self , * args ): \"\"\"Shows documentation for mapper commands\"\"\" helpTexts = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs = [ text for text in helpTexts if not text [ 1 ] . strip ()] result = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result )) Method user_command_tvnum ( self , * args ) \u00b6 tells a given char the vnum of your room Source code in mapper\\mapper.py 541 542 543 544 545 546 def user_command_tvnum ( self , * args ): \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" ) Method user_command_vnum ( self , * args ) \u00b6 states the vnum of the current room Source code in mapper\\mapper.py 537 538 539 def user_command_vnum ( self , * args ): \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" )","title":"mapper.py"},{"location":"api/mapper/#mapper.mapper","text":"","title":"mapper"},{"location":"api/mapper/#mapper.mapper.Mapper","text":"","title":"Mapper"},{"location":"api/mapper/#mapper.mapper.Mapper.daemon","text":"A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left.","title":"daemon"},{"location":"api/mapper/#mapper.mapper.Mapper.ident","text":"Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.","title":"ident"},{"location":"api/mapper/#mapper.mapper.Mapper.name","text":"A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.","title":"name"},{"location":"api/mapper/#mapper.mapper.Mapper.createSpeedWalk","text":"Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\mapper.py 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 def createSpeedWalk ( self , directionsList ): \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer ): speedWalkDirs = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections = len ([ d for d in directionsList if d in DIRECTIONS ]) result = [] directionsBuffer = [] while directionsList : item = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer = [] result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \"","title":"createSpeedWalk()"},{"location":"api/mapper/#mapper.mapper.Mapper.deregisterMudEventHandler","text":"Deregisters mud event handlers. params: same as registerMudEventHandler. Source code in mapper\\mapper.py 1059 1060 1061 1062 1063 1064 def deregisterMudEventHandler ( self , event , handler ): \"\"\"Deregisters mud event handlers. params: same as registerMudEventHandler. \"\"\" if event in self . mudEventHandlers and handler in self . mudEventHandlers [ event ]: self . mudEventHandlers [ event ] . remove ( handler )","title":"deregisterMudEventHandler()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulate_leave","text":"emulates leaving the room into a neighbouring room Source code in mapper\\mapper.py 374 375 376 377 378 379 380 381 382 383 384 385 def emulate_leave ( self , direction ): \"\"\"emulates leaving the room into a neighbouring room\"\"\" if direction not in self . emulationRoom . exits : self . output ( \"Alas, you cannot go that way...\" ) return room = self . emulationRoom . exits [ direction ] . to if \"death\" == room : self . output ( \"deathtrap!\" ) elif \"undefined\" == room : self . output ( \"undefined\" ) else : self . emulation_command_go ( room , isJump = False )","title":"emulate_leave()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_brief","text":"toggles brief mode. Source code in mapper\\mapper.py 289 290 291 292 def emulation_command_brief ( self , * args ): \"\"\"toggles brief mode.\"\"\" self . isEmulatingBriefMode = not self . isEmulatingBriefMode self . output ( f \"Brief mode { 'on' if self . isEmulatingBriefMode else 'off' } \" )","title":"emulation_command_brief()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_examine","text":"shows the room's description. Source code in mapper\\mapper.py 294 295 296 def emulation_command_examine ( self , * args ): \"\"\"shows the room's description.\"\"\" self . output ( self . emulationRoom . desc )","title":"emulation_command_examine()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_exits","text":"shows the exits in the room. Source code in mapper\\mapper.py 298 299 300 301 def emulation_command_exits ( self , * args ): \"\"\"shows the exits in the room.\"\"\" exits = [ key for key in DIRECTIONS if key in self . emulationRoom . exits . keys ()] self . output ( f \"Exits: { ', ' . join ( exits ) } .\" )","title":"emulation_command_exits()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_go","text":"mimic the /go command that the ainur use. Source code in mapper\\mapper.py 303 304 305 306 307 308 309 310 311 312 313 314 315 def emulation_command_go ( self , label , isJump = True ): \"\"\"mimic the /go command that the ainur use.\"\"\" room , error = self . getRoomFromLabel ( label ) if error : self . output ( error ) return self . emulationRoom = room self . emulation_command_look () self . emulation_command_exits () if self . isEmulatingOffline : self . currentRoom = self . emulationRoom if isJump : self . lastEmulatedJump = room","title":"emulation_command_go()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_help","text":"Shows documentation for mapper's emulation commands. Source code in mapper\\mapper.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def emulation_command_help ( self , * args ): \"\"\"Shows documentation for mapper's emulation commands.\"\"\" helpTexts = [ ( funcName , getattr ( self , \"emulation_command_\" + funcName ) . __doc__ ) for funcName in self . emulationCommands ] documentedFuncs = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs = [ text for text in helpTexts if not text [ 1 ] . strip ()] result = [ \"The following commands allow you to emulate exploring the map without needing to move in game:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"The following commands have no documentation yet.\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result ))","title":"emulation_command_help()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_look","text":"looks at the room. Source code in mapper\\mapper.py 348 349 350 351 352 353 354 355 def emulation_command_look ( self , * args ): \"\"\"looks at the room.\"\"\" self . output ( self . emulationRoom . name ) if not self . isEmulatingBriefMode : self . output ( self . emulationRoom . desc ) self . output ( self . emulationRoom . dynamicDesc ) if self . emulationRoom . note : self . output ( f \"Note: { self . emulationRoom . note } \" )","title":"emulation_command_look()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_quit","text":"Exits the program. Source code in mapper\\mapper.py 285 286 287 def emulation_command_quit ( self , * args ): \"\"\"Exits the program.\"\"\" self . proxy . game . write ( b \"quit\" )","title":"emulation_command_quit()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_return","text":"returns to the last room jumped to with the go command. Source code in mapper\\mapper.py 357 358 359 360 361 362 def emulation_command_return ( self , * args ): \"\"\"returns to the last room jumped to with the go command.\"\"\" if self . lastEmulatedJump : self . emulation_command_go ( self . lastEmulatedJump ) else : self . output ( \"Cannot return anywhere until the go command has been used at least once.\" )","title":"emulation_command_return()"},{"location":"api/mapper/#mapper.mapper.Mapper.emulation_command_sync","text":"When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. Source code in mapper\\mapper.py 364 365 366 367 368 369 370 371 372 def emulation_command_sync ( self , * args ): \"\"\" When emulating while connected to the mud, syncs the emulated location with the in-game location. When running in offline mode, is equivalent to the return command. \"\"\" if self . isEmulatingOffline : self . emulation_command_return () else : self . emulation_command_go ( self . currentRoom )","title":"emulation_command_sync()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNeighborsFromCoordinates","text":"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def getNeighborsFromCoordinates ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" try : iter ( start ) except TypeError : x = y = z = 0 else : x , y , z = start try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromCoordinates()"},{"location":"api/mapper/#mapper.mapper.Mapper.getNeighborsFromRoom","text":"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\mapper.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def getNeighborsFromRoom ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" if start is None : start = self . currentRoom x , y , z = start . x , start . y , start . z try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromRoom()"},{"location":"api/mapper/#mapper.mapper.Mapper.getRoomFromLabel","text":"Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. Source code in mapper\\mapper.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 def getRoomFromLabel ( self , label ): \"\"\"Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. \"\"\" if isinstance ( label , roomdata . objects . Room ): return label , None label = label . strip () . lower () if not label : return None , \"No label or room vnum specified.\" elif label . isdecimal (): vnum = label if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , \"No room with vnum \" + vnum elif label in self . labels : vnum = self . labels [ label ] if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , f \" { label } is set to vnum { vnum } , but there is no room with that vnum\" else : # The label is neither a vnum nor an existing label similarLabels = list ( self . labels ) similarLabels . sort ( reverse = True , key = lambda l : fuzz . ratio ( l , label )) return None , f \"Unknown label. Did you mean { ', ' . join ( similarLabels [ 0 : 4 ]) } ?\"","title":"getRoomFromLabel()"},{"location":"api/mapper/#mapper.mapper.Mapper.GUIRefresh","text":"Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\mapper.py 96 97 98 99 def GUIRefresh ( self ): \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,))","title":"GUIRefresh()"},{"location":"api/mapper/#mapper.mapper.Mapper.is_alive","text":"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. Source code in mapper\\mapper.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 def is_alive ( self ): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. The module function enumerate() returns a list of all alive threads. \"\"\" assert self . _initialized , \"Thread.__init__() not called\" if self . _is_stopped or not self . _started . is_set (): return False self . _wait_for_tstate_lock ( False ) return not self . _is_stopped","title":"is_alive()"},{"location":"api/mapper/#mapper.mapper.Mapper.isAlive","text":"Return whether the thread is alive. This method is deprecated, use is_alive() instead. Source code in mapper\\mapper.py 1106 1107 1108 1109 1110 1111 1112 1113 1114 def isAlive ( self ): \"\"\"Return whether the thread is alive. This method is deprecated, use is_alive() instead. \"\"\" import warnings warnings . warn ( 'isAlive() is deprecated, use is_alive() instead' , PendingDeprecationWarning , stacklevel = 2 ) return self . is_alive ()","title":"isAlive()"},{"location":"api/mapper/#mapper.mapper.Mapper.isBidirectional","text":"Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\mapper.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def isBidirectional ( self , exitObj ): \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest = self . rooms [ exitObj . to ] except KeyError : return False revdir = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False","title":"isBidirectional()"},{"location":"api/mapper/#mapper.mapper.Mapper.join","text":"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. Source code in mapper\\mapper.py 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 def join ( self , timeout = None ): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self . _initialized : raise RuntimeError ( \"Thread.__init__() not called\" ) if not self . _started . is_set (): raise RuntimeError ( \"cannot join thread before it is started\" ) if self is current_thread (): raise RuntimeError ( \"cannot join current thread\" ) if timeout is None : self . _wait_for_tstate_lock () else : # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self . _wait_for_tstate_lock ( timeout = max ( timeout , 0 ))","title":"join()"},{"location":"api/mapper/#mapper.mapper.Mapper.pathFind","text":"Find the path Source code in mapper\\mapper.py 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 def pathFind ( self , origin = None , destination = None , flags = None ): \"\"\"Find the path\"\"\" origin = origin or self . currentRoom if not origin : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) destinationRoom , errorFindingDestination = self . getRoomFromLabel ( destination ) if errorFindingDestination : self . output ( errorFindingDestination ) return None if origin is destinationRoom : self . output ( \"You are already there!\" ) return [] if flags : avoidTerrains = frozenset ( terrain for terrain in roomdata . objects . TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc = lambda currentRoomObj : currentRoomObj is destinationRoom # NOQA: E731 exitIgnoreFunc = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"pathFind()"},{"location":"api/mapper/#mapper.mapper.Mapper.registerMudEventHandler","text":"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, data, which is the text received from the mud. Source code in mapper\\mapper.py 1049 1050 1051 1052 1053 1054 1055 1056 1057 def registerMudEventHandler ( self , event , handler ): \"\"\"Registers a method to handle mud events of a given type. Params: event, handler where event is the name of the event type, typically corresponding to the XML tag of the incoming data, and handler is a method that takes a single argument, data, which is the text received from the mud. \"\"\" if event not in self . mudEventHandlers : self . mudEventHandlers [ event ] = set () self . mudEventHandlers [ event ] . add ( handler )","title":"registerMudEventHandler()"},{"location":"api/mapper/#mapper.mapper.Mapper.run","text":"Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. Source code in mapper\\mapper.py 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 def run ( self ): while True : try : dataType , data = self . queue . get () if data is None : break elif dataType == USER_DATA : # The data was a valid mapper command, sent from the user's mud client. self . handleUserData ( data ) elif dataType == MUD_DATA : # The data was from the mud server. event , data = data self . handleMudEvent ( event , data ) except Exception as e : self . output ( \"map error\" ) print ( \"error \" + str ( e )) self . sendPlayer ( \"Exiting mapper thread.\" )","title":"run()"},{"location":"api/mapper/#mapper.mapper.Mapper.start","text":"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. Source code in mapper\\mapper.py 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 def start ( self ): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self . _initialized : raise RuntimeError ( \"thread.__init__() not called\" ) if self . _started . is_set (): raise RuntimeError ( \"threads can only be started once\" ) with _active_limbo_lock : _limbo [ self ] = self try : _start_new_thread ( self . _bootstrap , ()) except Exception : with _active_limbo_lock : del _limbo [ self ] raise self . _started . wait ()","title":"start()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_maphelp","text":"Shows documentation for mapper commands Source code in mapper\\mapper.py 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 def user_command_maphelp ( self , * args ): \"\"\"Shows documentation for mapper commands\"\"\" helpTexts = [ ( funcName , getattr ( self , \"user_command_\" + funcName ) . __doc__ or \"\" ) for funcName in self . userCommands ] documentedFuncs = [ ( name , formatDocString ( docString , prefix = \" \" * 8 ) . strip ()) for name , docString in helpTexts if docString . strip () ] undocumentedFuncs = [ text for text in helpTexts if not text [ 1 ] . strip ()] result = [ \"Mapper Commands\" , \"The following commands are used for viewing and editing map data:\" , \" \\n \" . join ( \" {} : {} \" . format ( * helpText ) for helpText in documentedFuncs ), ] if undocumentedFuncs : result . append ( \"Undocumented Commands:\" ) result . append ( textwrap . indent ( textwrap . fill ( \", \" . join ( helpText [ 0 ] for helpText in undocumentedFuncs ), width = 79 , break_long_words = False , break_on_hyphens = False , ), prefix = \" \" , ) ) self . output ( \" \\n \" . join ( result ))","title":"user_command_maphelp()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_tvnum","text":"tells a given char the vnum of your room Source code in mapper\\mapper.py 541 542 543 544 545 546 def user_command_tvnum ( self , * args ): \"\"\"tells a given char the vnum of your room\"\"\" if not args or not args [ 0 ] or not args [ 0 ] . strip (): self . sendPlayer ( \"Tell VNum to who?\" ) else : self . sendGame ( f \"tell { args [ 0 ] . strip () } { self . currentRoom . vnum } \" )","title":"user_command_tvnum()"},{"location":"api/mapper/#mapper.mapper.Mapper.user_command_vnum","text":"states the vnum of the current room Source code in mapper\\mapper.py 537 538 539 def user_command_vnum ( self , * args ): \"\"\"states the vnum of the current room\"\"\" self . sendPlayer ( f \"Vnum: { self . currentRoom . vnum } .\" )","title":"user_command_vnum()"},{"location":"api/mudevents/","text":"Module mapper.mudevents \u00b6 Class Handler \u00b6 Method __init__ ( self , mapper , event = None ) special \u00b6 Initialises a mud event handler in the given mapper class. params: mapper, event where mapper is the mapper instance that will be dispatching events, and event is an optional event name. The event name may be omitted if the subclass is defined with an event attribute. Source code in mapper\\mudevents.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , mapper , event = None ): \"\"\"Initialises a mud event handler in the given mapper class. params: mapper, event where mapper is the mapper instance that will be dispatching events, and event is an optional event name. The event name may be omitted if the subclass is defined with an event attribute. \"\"\" self . mapper = mapper try : self . event = event or self . event except AttributeError as e : raise ValueError ( \"Tried to initialise handler without an event type.\" \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) from e self . mapper . registerMudEventHandler ( self . event , self . handle ) Method handle ( self , data ) \u00b6 the method called when the event is dispatched Source code in mapper\\mudevents.py 35 36 37 @abstractmethod def handle ( self , data ): \"\"\"the method called when the event is dispatched\"\"\"","title":"mudevents.py"},{"location":"api/mudevents/#mapper.mudevents","text":"","title":"mudevents"},{"location":"api/mudevents/#mapper.mudevents.Handler","text":"","title":"Handler"},{"location":"api/mudevents/#mapper.mudevents.Handler.__init__","text":"Initialises a mud event handler in the given mapper class. params: mapper, event where mapper is the mapper instance that will be dispatching events, and event is an optional event name. The event name may be omitted if the subclass is defined with an event attribute. Source code in mapper\\mudevents.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , mapper , event = None ): \"\"\"Initialises a mud event handler in the given mapper class. params: mapper, event where mapper is the mapper instance that will be dispatching events, and event is an optional event name. The event name may be omitted if the subclass is defined with an event attribute. \"\"\" self . mapper = mapper try : self . event = event or self . event except AttributeError as e : raise ValueError ( \"Tried to initialise handler without an event type.\" \" Either pass event=MyEventType when initialising, or declare self.event in the class definition.\" ) from e self . mapper . registerMudEventHandler ( self . event , self . handle )","title":"__init__()"},{"location":"api/mudevents/#mapper.mudevents.Handler.handle","text":"the method called when the event is dispatched Source code in mapper\\mudevents.py 35 36 37 @abstractmethod def handle ( self , data ): \"\"\"the method called when the event is dispatched\"\"\"","title":"handle()"},{"location":"api/utils/","text":"Module mapper.utils \u00b6 Function escapeIAC ( dataBytes ) \u00b6 Double IAC characters in a bytes or bytearray object to escape them. Source code in mapper\\utils.py 85 86 87 def escapeIAC ( dataBytes ): \"\"\"Double IAC characters in a bytes or bytearray object to escape them.\"\"\" return dataBytes . replace ( IAC , IAC + IAC ) Function formatDocString ( functionOrString , width = 79 , prefix = '' ) \u00b6 Format a docstring for displaying. Source code in mapper\\utils.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def formatDocString ( functionOrString , width = 79 , prefix = \"\" ): \"\"\"Format a docstring for displaying.\"\"\" if callable ( functionOrString ): # It's a function. docString = functionOrString . __docstring__ if functionOrString . __docstring__ is not None else \"\" else : # It's a string. docString = functionOrString docString = docString . lstrip ( \" \\r\\n \" ) # Remove any empty lines from the beginning, while keeping indention. if not INDENT_REGEX . search ( docString ) . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): indent , text = INDENT_REGEX . search ( line ) . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix ) # Indent docstring lines with the prefix. return docString Function getDirectoryPath ( * subdirectory ) \u00b6 Return the location where the program is running. Source code in mapper\\utils.py 180 181 182 183 184 185 186 def getDirectoryPath ( * subdirectory ): \"\"\"Return the location where the program is running.\"\"\" if isFrozen (): path = os . path . dirname ( sys . executable ) else : path = os . path . join ( os . path . dirname ( __file__ ), os . path . pardir ) return os . path . realpath ( os . path . join ( path , * subdirectory )) Function getFreezer () \u00b6 Return the name of the package used to freeze the running code or None. Source code in mapper\\utils.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def getFreezer (): \"\"\"Return the name of the package used to freeze the running code or None.\"\"\" # https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py frozen = getattr ( sys , \"frozen\" , None ) if frozen and hasattr ( sys , \"_MEIPASS\" ): return \"pyinstaller\" elif frozen is True : return \"cx_freeze\" elif frozen in ( \"windows_exe\" , \"console_exe\" , \"dll\" ): return \"py2exe\" elif frozen == \"macosx_app\" : return \"py2app\" elif hasattr ( sys , \"importers\" ): return \"old_py2exe\" elif _imp . is_frozen ( \"__main__\" ): return \"tools/freeze\" return frozen Function iterBytes ( data ) \u00b6 Yield each byte in a bytes-like object. Source code in mapper\\utils.py 32 33 34 35 def iterBytes ( data ): \"\"\"Yield each byte in a bytes-like object.\"\"\" for i in range ( len ( data )): yield data [ i : i + 1 ] Function minIndent ( text ) \u00b6 Return the white space used to indent the line with the least amount of indention. Source code in mapper\\utils.py 38 39 40 41 42 43 44 def minIndent ( text ): \"\"\"Return the white space used to indent the line with the least amount of indention.\"\"\" return min ( ( INDENT_REGEX . search ( line ) . group ( \"indent\" ) for line in text . splitlines () if line . strip ( \" \\r\\n \" )), default = \"\" , key = len , ) Function padList ( lst , padding , count , fixed = False , left = False ) \u00b6 Pad a list with the value of 'padding' so that the list is at least 'count' number of items. If 'fixed' is True, the number of items in the returned list will be restricted to 'count'. If 'left' is True, the list will be padded at the left (top), rather than the right (bottom). Source code in mapper\\utils.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def padList ( lst , padding , count , fixed = False , left = False ): \"\"\" Pad a list with the value of 'padding' so that the list is *at least* 'count' number of items. If 'fixed' is True, the number of items in the returned list will be *restricted* to 'count'. If 'left' is True, the list will be padded at the left (top), rather than the right (bottom). \"\"\" if left and fixed : return ([ padding ] * ( count - len ( lst )) + lst )[: count ] elif left : return [ padding ] * ( count - len ( lst )) + lst elif fixed : return ( lst + [ padding ] * ( count - len ( lst )))[: count ] else : return lst + [ padding ] * ( count - len ( lst )) Function page ( lines ) \u00b6 Output word wrapped lines using the 'more' shell command if necessary. Source code in mapper\\utils.py 217 218 219 220 221 222 223 224 225 def page ( lines ): \"\"\"Output word wrapped lines using the 'more' shell command if necessary.\"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text ) Function removeFile ( toRemove ) \u00b6 Remove a file, ignoring any errors. Source code in mapper\\utils.py 98 99 100 101 102 103 104 105 def removeFile ( toRemove ): \"\"\"Remove a file, ignoring any errors.\"\"\" try : if not toRemove . closed : toRemove . close () os . remove ( toRemove . name ) except AttributeError : os . remove ( toRemove ) Function touch ( name , times = None ) \u00b6 Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Source code in mapper\\utils.py 108 109 110 111 112 113 114 def touch ( name , times = None ): \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. \"\"\" with open ( name , \"a\" ): os . utime ( name , times )","title":"utils.py"},{"location":"api/utils/#mapper.utils","text":"","title":"utils"},{"location":"api/utils/#mapper.utils.escapeIAC","text":"Double IAC characters in a bytes or bytearray object to escape them. Source code in mapper\\utils.py 85 86 87 def escapeIAC ( dataBytes ): \"\"\"Double IAC characters in a bytes or bytearray object to escape them.\"\"\" return dataBytes . replace ( IAC , IAC + IAC )","title":"escapeIAC()"},{"location":"api/utils/#mapper.utils.formatDocString","text":"Format a docstring for displaying. Source code in mapper\\utils.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def formatDocString ( functionOrString , width = 79 , prefix = \"\" ): \"\"\"Format a docstring for displaying.\"\"\" if callable ( functionOrString ): # It's a function. docString = functionOrString . __docstring__ if functionOrString . __docstring__ is not None else \"\" else : # It's a string. docString = functionOrString docString = docString . lstrip ( \" \\r\\n \" ) # Remove any empty lines from the beginning, while keeping indention. if not INDENT_REGEX . search ( docString ) . group ( \"indent\" ): # The first line was not indented. # Prefix the first line with the white space from the subsequent, non-empty # line with the least amount of indention. # This is needed so that textwrap.dedent will work. docString = minIndent ( \" \\n \" . join ( docString . splitlines ()[ 1 :])) + docString docString = textwrap . dedent ( docString ) # Remove common indention from lines. docString = docString . rstrip () # Remove trailing white space from the end of the docstring. # Word wrap long lines, while maintaining existing structure. wrappedLines = [] indentLevel = 0 lastIndent = \"\" for line in docString . splitlines (): indent , text = INDENT_REGEX . search ( line ) . groups () if len ( indent ) > len ( lastIndent ): indentLevel += 1 elif len ( indent ) < len ( lastIndent ): indentLevel -= 1 lastIndent = indent linePrefix = prefix * indentLevel if prefix else indent lines = textwrap . wrap ( text , width = width - len ( linePrefix ), break_long_words = False , break_on_hyphens = False ) wrappedLines . append ( linePrefix + f \" \\n { linePrefix } \" . join ( lines )) docString = \" \\n \" . join ( wrappedLines ) docString = textwrap . indent ( docString , prefix = prefix ) # Indent docstring lines with the prefix. return docString","title":"formatDocString()"},{"location":"api/utils/#mapper.utils.getDirectoryPath","text":"Return the location where the program is running. Source code in mapper\\utils.py 180 181 182 183 184 185 186 def getDirectoryPath ( * subdirectory ): \"\"\"Return the location where the program is running.\"\"\" if isFrozen (): path = os . path . dirname ( sys . executable ) else : path = os . path . join ( os . path . dirname ( __file__ ), os . path . pardir ) return os . path . realpath ( os . path . join ( path , * subdirectory ))","title":"getDirectoryPath()"},{"location":"api/utils/#mapper.utils.getFreezer","text":"Return the name of the package used to freeze the running code or None. Source code in mapper\\utils.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def getFreezer (): \"\"\"Return the name of the package used to freeze the running code or None.\"\"\" # https://github.com/blackmagicgirl/ktools/blob/master/ktools/utils.py frozen = getattr ( sys , \"frozen\" , None ) if frozen and hasattr ( sys , \"_MEIPASS\" ): return \"pyinstaller\" elif frozen is True : return \"cx_freeze\" elif frozen in ( \"windows_exe\" , \"console_exe\" , \"dll\" ): return \"py2exe\" elif frozen == \"macosx_app\" : return \"py2app\" elif hasattr ( sys , \"importers\" ): return \"old_py2exe\" elif _imp . is_frozen ( \"__main__\" ): return \"tools/freeze\" return frozen","title":"getFreezer()"},{"location":"api/utils/#mapper.utils.iterBytes","text":"Yield each byte in a bytes-like object. Source code in mapper\\utils.py 32 33 34 35 def iterBytes ( data ): \"\"\"Yield each byte in a bytes-like object.\"\"\" for i in range ( len ( data )): yield data [ i : i + 1 ]","title":"iterBytes()"},{"location":"api/utils/#mapper.utils.minIndent","text":"Return the white space used to indent the line with the least amount of indention. Source code in mapper\\utils.py 38 39 40 41 42 43 44 def minIndent ( text ): \"\"\"Return the white space used to indent the line with the least amount of indention.\"\"\" return min ( ( INDENT_REGEX . search ( line ) . group ( \"indent\" ) for line in text . splitlines () if line . strip ( \" \\r\\n \" )), default = \"\" , key = len , )","title":"minIndent()"},{"location":"api/utils/#mapper.utils.padList","text":"Pad a list with the value of 'padding' so that the list is at least 'count' number of items. If 'fixed' is True, the number of items in the returned list will be restricted to 'count'. If 'left' is True, the list will be padded at the left (top), rather than the right (bottom). Source code in mapper\\utils.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def padList ( lst , padding , count , fixed = False , left = False ): \"\"\" Pad a list with the value of 'padding' so that the list is *at least* 'count' number of items. If 'fixed' is True, the number of items in the returned list will be *restricted* to 'count'. If 'left' is True, the list will be padded at the left (top), rather than the right (bottom). \"\"\" if left and fixed : return ([ padding ] * ( count - len ( lst )) + lst )[: count ] elif left : return [ padding ] * ( count - len ( lst )) + lst elif fixed : return ( lst + [ padding ] * ( count - len ( lst )))[: count ] else : return lst + [ padding ] * ( count - len ( lst ))","title":"padList()"},{"location":"api/utils/#mapper.utils.page","text":"Output word wrapped lines using the 'more' shell command if necessary. Source code in mapper\\utils.py 217 218 219 220 221 222 223 224 225 def page ( lines ): \"\"\"Output word wrapped lines using the 'more' shell command if necessary.\"\"\" # This is necessary in order for lines with embedded new line characters to be properly handled. lines = \" \\n \" . join ( lines ) . splitlines () width , height = shutil . get_terminal_size () # Word wrapping to 1 less than the terminal width is necessary to prevent # occasional blank lines in the terminal output. text = \" \\n \" . join ( textwrap . fill ( line . strip (), width - 1 ) for line in lines ) pager ( text )","title":"page()"},{"location":"api/utils/#mapper.utils.removeFile","text":"Remove a file, ignoring any errors. Source code in mapper\\utils.py 98 99 100 101 102 103 104 105 def removeFile ( toRemove ): \"\"\"Remove a file, ignoring any errors.\"\"\" try : if not toRemove . closed : toRemove . close () os . remove ( toRemove . name ) except AttributeError : os . remove ( toRemove )","title":"removeFile()"},{"location":"api/utils/#mapper.utils.touch","text":"Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. Source code in mapper\\utils.py 108 109 110 111 112 113 114 def touch ( name , times = None ): \"\"\" Touches a file. I.E. creates the file if it doesn't exist, or updates the modified time of the file if it does. \"\"\" with open ( name , \"a\" ): os . utime ( name , times )","title":"touch()"},{"location":"api/world/","text":"Module mapper.world \u00b6 Class World \u00b6 Method createSpeedWalk ( self , directionsList ) \u00b6 Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\world.py 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 def createSpeedWalk ( self , directionsList ): \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer ): speedWalkDirs = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections = len ([ d for d in directionsList if d in DIRECTIONS ]) result = [] directionsBuffer = [] while directionsList : item = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer = [] result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \" Method getNeighborsFromCoordinates ( self , start = None , radius = 1 ) \u00b6 A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def getNeighborsFromCoordinates ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" try : iter ( start ) except TypeError : x = y = z = 0 else : x , y , z = start try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getNeighborsFromRoom ( self , start = None , radius = 1 ) \u00b6 A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def getNeighborsFromRoom ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" if start is None : start = self . currentRoom x , y , z = start . x , start . y , start . z try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ ) Method getRoomFromLabel ( self , label ) \u00b6 Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. Source code in mapper\\world.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 def getRoomFromLabel ( self , label ): \"\"\"Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. \"\"\" if isinstance ( label , roomdata . objects . Room ): return label , None label = label . strip () . lower () if not label : return None , \"No label or room vnum specified.\" elif label . isdecimal (): vnum = label if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , \"No room with vnum \" + vnum elif label in self . labels : vnum = self . labels [ label ] if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , f \" { label } is set to vnum { vnum } , but there is no room with that vnum\" else : # The label is neither a vnum nor an existing label similarLabels = list ( self . labels ) similarLabels . sort ( reverse = True , key = lambda l : fuzz . ratio ( l , label )) return None , f \"Unknown label. Did you mean { ', ' . join ( similarLabels [ 0 : 4 ]) } ?\" Method GUIRefresh ( self ) \u00b6 Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\world.py 96 97 98 99 def GUIRefresh ( self ): \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,)) Method isBidirectional ( self , exitObj ) \u00b6 Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\world.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def isBidirectional ( self , exitObj ): \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest = self . rooms [ exitObj . to ] except KeyError : return False revdir = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False Method pathFind ( self , origin = None , destination = None , flags = None ) \u00b6 Find the path Source code in mapper\\world.py 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 def pathFind ( self , origin = None , destination = None , flags = None ): \"\"\"Find the path\"\"\" origin = origin or self . currentRoom if not origin : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) destinationRoom , errorFindingDestination = self . getRoomFromLabel ( destination ) if errorFindingDestination : self . output ( errorFindingDestination ) return None if origin is destinationRoom : self . output ( \"You are already there!\" ) return [] if flags : avoidTerrains = frozenset ( terrain for terrain in roomdata . objects . TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc = lambda currentRoomObj : currentRoomObj is destinationRoom # NOQA: E731 exitIgnoreFunc = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"world.py"},{"location":"api/world/#mapper.world","text":"","title":"world"},{"location":"api/world/#mapper.world.World","text":"","title":"World"},{"location":"api/world/#mapper.world.World.createSpeedWalk","text":"Given a list of directions, return a string of the directions in standard speed walk format Source code in mapper\\world.py 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 def createSpeedWalk ( self , directionsList ): \"\"\"Given a list of directions, return a string of the directions in standard speed walk format\"\"\" def compressDirections ( directionsBuffer ): speedWalkDirs = [] for direction , group in itertools . groupby ( directionsBuffer ): lenGroup = len ( list ( group )) if lenGroup == 1 : speedWalkDirs . append ( direction [ 0 ]) else : speedWalkDirs . append ( f \" { lenGroup }{ direction [ 0 ] } \" ) return speedWalkDirs numDirections = len ([ d for d in directionsList if d in DIRECTIONS ]) result = [] directionsBuffer = [] while directionsList : item = directionsList . pop () if item in DIRECTIONS : directionsBuffer . append ( item ) else : # The item is not a direction, so process the directions buffer, clear the buffer, # and add the resulting list plus the item to the result. result . extend ( compressDirections ( directionsBuffer )) directionsBuffer = [] result . append ( item ) # Process any remaining items in the directions buffer. if directionsBuffer : result . extend ( compressDirections ( directionsBuffer )) return f \" { numDirections } rooms. { ', ' . join ( result ) } \"","title":"createSpeedWalk()"},{"location":"api/world/#mapper.world.World.getNeighborsFromCoordinates","text":"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 def getNeighborsFromCoordinates ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of the given X-Y-Z coordinates. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" try : iter ( start ) except TypeError : x = y = z = 0 else : x , y , z = start try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): if obj . x == x and obj . y == y and obj . z == z : continue differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ : yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromCoordinates()"},{"location":"api/world/#mapper.world.World.getNeighborsFromRoom","text":"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates. Source code in mapper\\world.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 def getNeighborsFromRoom ( self , start = None , radius = 1 ): \"\"\"A generator which yields all rooms in the vicinity of a room object. Each yielded result contains the vnum, room object reference, and difference in X-Y-Z coordinates.\"\"\" if start is None : start = self . currentRoom x , y , z = start . x , start . y , start . z try : iter ( radius ) except TypeError : radiusX = radiusY = radiusZ = int ( radius ) else : radiusX , radiusY , radiusZ = radius for vnum , obj in self . rooms . items (): differenceX , differenceY , differenceZ = obj . x - x , obj . y - y , obj . z - z if ( abs ( differenceX ) <= radiusX and abs ( differenceY ) <= radiusY and abs ( differenceZ ) <= radiusZ and obj is not start ): yield ( vnum , obj , differenceX , differenceY , differenceZ )","title":"getNeighborsFromRoom()"},{"location":"api/world/#mapper.world.World.getRoomFromLabel","text":"Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. Source code in mapper\\world.py 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 def getRoomFromLabel ( self , label ): \"\"\"Takes a single argument, and returns a tuple of length 2. If successful, the first element returned is a room object, and the second element is none. Otherwise, the first element returned is None, and the second element is a human-readable error message. If the given argument is a room object, it is returned as is. If the given argument is a room vnum corresponding to an extant room, the corresponding room is returned. If the given argument is the label of a room, that room is returned. Otherwise, None is returned with a helpful error message for the user. \"\"\" if isinstance ( label , roomdata . objects . Room ): return label , None label = label . strip () . lower () if not label : return None , \"No label or room vnum specified.\" elif label . isdecimal (): vnum = label if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , \"No room with vnum \" + vnum elif label in self . labels : vnum = self . labels [ label ] if vnum in self . rooms : return self . rooms [ vnum ], None else : return None , f \" { label } is set to vnum { vnum } , but there is no room with that vnum\" else : # The label is neither a vnum nor an existing label similarLabels = list ( self . labels ) similarLabels . sort ( reverse = True , key = lambda l : fuzz . ratio ( l , label )) return None , f \"Unknown label. Did you mean { ', ' . join ( similarLabels [ 0 : 4 ]) } ?\"","title":"getRoomFromLabel()"},{"location":"api/world/#mapper.world.World.GUIRefresh","text":"Trigger the clearing and redrawing of rooms by the GUI Source code in mapper\\world.py 96 97 98 99 def GUIRefresh ( self ): \"\"\"Trigger the clearing and redrawing of rooms by the GUI\"\"\" if self . _interface != \"text\" : self . _gui_queue . put (( \"on_gui_refresh\" ,))","title":"GUIRefresh()"},{"location":"api/world/#mapper.world.World.isBidirectional","text":"Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. Source code in mapper\\world.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 def isBidirectional ( self , exitObj ): \"\"\" Returns True if an exit is bidirectional, False if unidirectional. I.E. True if moving in a given direction then moving back in the direction you just came from would put you back where you started, False otherwise. \"\"\" try : dest = self . rooms [ exitObj . to ] except KeyError : return False revdir = REVERSE_DIRECTIONS [ exitObj . direction ] if revdir in dest . exits and dest . exits [ revdir ] . to == exitObj . vnum : return True else : return False","title":"isBidirectional()"},{"location":"api/world/#mapper.world.World.pathFind","text":"Find the path Source code in mapper\\world.py 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 def pathFind ( self , origin = None , destination = None , flags = None ): \"\"\"Find the path\"\"\" origin = origin or self . currentRoom if not origin : self . output ( \"Error! The mapper has no location. Please use the sync command then try again.\" ) destinationRoom , errorFindingDestination = self . getRoomFromLabel ( destination ) if errorFindingDestination : self . output ( errorFindingDestination ) return None if origin is destinationRoom : self . output ( \"You are already there!\" ) return [] if flags : avoidTerrains = frozenset ( terrain for terrain in roomdata . objects . TERRAIN_COSTS if f \"no { terrain } \" in flags ) else : avoidTerrains = frozenset () ignoreVnums = frozenset (( \"undefined\" , \"death\" )) isDestinationFunc = lambda currentRoomObj : currentRoomObj is destinationRoom # NOQA: E731 exitIgnoreFunc = lambda exitObj : exitObj . to in ignoreVnums # NOQA: E731 exitCostFunc = lambda exitObj , neighborRoomObj : ( # NOQA: E731 ( 5 if \"door\" in exitObj . exitFlags or \"climb\" in exitObj . exitFlags else 0 ) + ( 1000 if \"avoid\" in exitObj . exitFlags else 0 ) + ( 10 if neighborRoomObj . terrain in avoidTerrains else 0 ) ) exitDestinationFunc = None return self . _pathFind ( origin , isDestinationFunc , exitIgnoreFunc , exitCostFunc , exitDestinationFunc )","title":"pathFind()"},{"location":"api/protocols/base/","text":"Module mapper.protocols.base \u00b6 Class BaseProtocol \u00b6 Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\base.py 32 33 34 @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\" Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\base.py 28 29 30 @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\" Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\base.py 36 37 38 39 40 41 42 43 @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\" Method write ( self , data ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\base.py 19 20 21 22 23 24 25 26 @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\" Class Protocol \u00b6 Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\base.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\base.py 56 57 def on_connectionMade ( self ) -> None : pass Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\base.py 62 63 def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data ) Method write ( self , data ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\base.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"base.py"},{"location":"api/protocols/base/#mapper.protocols.base","text":"","title":"base"},{"location":"api/protocols/base/#mapper.protocols.base.BaseProtocol","text":"","title":"BaseProtocol"},{"location":"api/protocols/base/#mapper.protocols.base.BaseProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\base.py 32 33 34 @abstractmethod def on_connectionLost ( self ) -> None : \"\"\"Called by `disconnect` when a connection to peer has been lost.\"\"\"","title":"on_connectionLost()"},{"location":"api/protocols/base/#mapper.protocols.base.BaseProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\base.py 28 29 30 @abstractmethod def on_connectionMade ( self ) -> None : \"\"\"Called by `connect` when a connection to peer has been established.\"\"\"","title":"on_connectionMade()"},{"location":"api/protocols/base/#mapper.protocols.base.BaseProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\base.py 36 37 38 39 40 41 42 43 @abstractmethod def on_dataReceived ( self , data : bytes ) -> None : \"\"\" Called by `parse` when data is received. Args: data: The received data. \"\"\"","title":"on_dataReceived()"},{"location":"api/protocols/base/#mapper.protocols.base.BaseProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\base.py 19 20 21 22 23 24 25 26 @abstractmethod def write ( self , data : bytes ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. \"\"\"","title":"write()"},{"location":"api/protocols/base/#mapper.protocols.base.Protocol","text":"","title":"Protocol"},{"location":"api/protocols/base/#mapper.protocols.base.Protocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\base.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/base/#mapper.protocols.base.Protocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\base.py 56 57 def on_connectionMade ( self ) -> None : pass","title":"on_connectionMade()"},{"location":"api/protocols/base/#mapper.protocols.base.Protocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\base.py 62 63 def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data )","title":"on_dataReceived()"},{"location":"api/protocols/base/#mapper.protocols.base.Protocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\base.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/manager/","text":"Module mapper.protocols.manager \u00b6 Class Manager \u00b6 Attribute isConnected: bool property readonly \u00b6 Connection status. Method close ( self ) \u00b6 Calls disconnect . Source code in mapper\\protocols\\manager.py 46 47 48 def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect () Method connect ( self ) \u00b6 Signals that peer is connected. If data was buffered while not connected, parse will be called with the data. Source code in mapper\\protocols\\manager.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" if not self . isConnected : self . _isConnected = True if self . _readBuffer : data = b \"\" . join ( self . _readBuffer ) self . _readBuffer . clear () self . parse ( data ) if self . _writeBuffer : data = b \"\" . join ( self . _writeBuffer ) self . _writeBuffer . clear () self . write ( data ) Method disconnect ( self ) \u00b6 Signals that peer has disconnected. Source code in mapper\\protocols\\manager.py 67 68 69 70 71 72 def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . isConnected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _isConnected = False Method parse ( self , data ) \u00b6 Parses data from peer. If not connected, data will be buffered until connect is called. Parameters: Name Type Description Default data bytes The data to be parsed. required Source code in mapper\\protocols\\manager.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . isConnected or not self . _handlers : self . _readBuffer . append ( data ) elif self . _readBuffer : data = b \"\" . join ( self . _readBuffer ) + data self . _readBuffer . clear () self . _handlers [ 0 ] . on_dataReceived ( data ) elif data : self . _handlers [ 0 ] . on_dataReceived ( data ) Method register ( self , handler , * args , ** kwargs ) \u00b6 Registers a protocol handler. Parameters: Name Type Description Default handler Type[Protocol] The handler to be registered. required *args Positional arguments to be passed to the handler's constructer. () **kwargs Key word arguments to be passed to the handler's constructer. {} Source code in mapper\\protocols\\manager.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def register ( self , handler : Type [ Protocol ], * args , ** kwargs ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. *args: Positional arguments to be passed to the handler's constructer. **kwargs: Key word arguments to be passed to the handler's constructer. \"\"\" if not inspect . isclass ( handler ): raise ValueError ( \"Class required, not instance.\" ) for i in self . _handlers : if isinstance ( i , handler ): raise ValueError ( \"Already registered.\" ) instance : Protocol = handler ( * args , self . write , self . _receiver , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_dataReceived self . _handlers . append ( instance ) instance . on_connectionMade () Method unregister ( self , instance ) \u00b6 Unregisters a protocol handler. Parameters: Name Type Description Default instance Protocol The handler instance to be unregistered. required Source code in mapper\\protocols\\manager.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def unregister ( self , instance : Protocol ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. \"\"\" if inspect . isclass ( instance ): raise ValueError ( \"Instance required, not class.\" ) elif instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver instance . on_connectionLost () Method write ( self , data , escape = False ) \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required escape bool If true, escapes line endings and IAC characters. False Source code in mapper\\protocols\\manager.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def write ( self , data : bytes , escape : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If true, escapes line endings and IAC characters. \"\"\" if escape : data = ( escapeIAC ( data ) . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) if not self . isConnected or not self . _handlers : self . _writeBuffer . append ( data ) elif self . _writeBuffer : data = b \"\" . join ( self . _writeBuffer ) + data self . _writeBuffer . clear () self . _writer ( data ) elif data : self . _writer ( data )","title":"manager.py"},{"location":"api/protocols/manager/#mapper.protocols.manager","text":"","title":"manager"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager","text":"","title":"Manager"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.isConnected","text":"Connection status.","title":"isConnected"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.close","text":"Calls disconnect . Source code in mapper\\protocols\\manager.py 46 47 48 def close ( self ) -> None : \"\"\"Calls `disconnect`.\"\"\" self . disconnect ()","title":"close()"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.connect","text":"Signals that peer is connected. If data was buffered while not connected, parse will be called with the data. Source code in mapper\\protocols\\manager.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def connect ( self ) -> None : \"\"\" Signals that peer is connected. If data was buffered while not connected, `parse` will be called with the data. \"\"\" if not self . isConnected : self . _isConnected = True if self . _readBuffer : data = b \"\" . join ( self . _readBuffer ) self . _readBuffer . clear () self . parse ( data ) if self . _writeBuffer : data = b \"\" . join ( self . _writeBuffer ) self . _writeBuffer . clear () self . write ( data )","title":"connect()"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.disconnect","text":"Signals that peer has disconnected. Source code in mapper\\protocols\\manager.py 67 68 69 70 71 72 def disconnect ( self ) -> None : \"\"\"Signals that peer has disconnected.\"\"\" if self . isConnected : while self . _handlers : self . unregister ( self . _handlers [ 0 ]) self . _isConnected = False","title":"disconnect()"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.parse","text":"Parses data from peer. If not connected, data will be buffered until connect is called. Parameters: Name Type Description Default data bytes The data to be parsed. required Source code in mapper\\protocols\\manager.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 def parse ( self , data : bytes ) -> None : \"\"\" Parses data from peer. If not connected, data will be buffered until `connect` is called. Args: data: The data to be parsed. \"\"\" if not self . isConnected or not self . _handlers : self . _readBuffer . append ( data ) elif self . _readBuffer : data = b \"\" . join ( self . _readBuffer ) + data self . _readBuffer . clear () self . _handlers [ 0 ] . on_dataReceived ( data ) elif data : self . _handlers [ 0 ] . on_dataReceived ( data )","title":"parse()"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.register","text":"Registers a protocol handler. Parameters: Name Type Description Default handler Type[Protocol] The handler to be registered. required *args Positional arguments to be passed to the handler's constructer. () **kwargs Key word arguments to be passed to the handler's constructer. {} Source code in mapper\\protocols\\manager.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def register ( self , handler : Type [ Protocol ], * args , ** kwargs ) -> None : \"\"\" Registers a protocol handler. Args: handler: The handler to be registered. *args: Positional arguments to be passed to the handler's constructer. **kwargs: Key word arguments to be passed to the handler's constructer. \"\"\" if not inspect . isclass ( handler ): raise ValueError ( \"Class required, not instance.\" ) for i in self . _handlers : if isinstance ( i , handler ): raise ValueError ( \"Already registered.\" ) instance : Protocol = handler ( * args , self . write , self . _receiver , ** kwargs ) if self . _handlers : self . _handlers [ - 1 ] . _receiver = instance . on_dataReceived self . _handlers . append ( instance ) instance . on_connectionMade ()","title":"register()"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.unregister","text":"Unregisters a protocol handler. Parameters: Name Type Description Default instance Protocol The handler instance to be unregistered. required Source code in mapper\\protocols\\manager.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def unregister ( self , instance : Protocol ) -> None : \"\"\" Unregisters a protocol handler. Args: instance: The handler instance to be unregistered. \"\"\" if inspect . isclass ( instance ): raise ValueError ( \"Instance required, not class.\" ) elif instance not in self . _handlers : raise ValueError ( \"Instance wasn't registered.\" ) index = self . _handlers . index ( instance ) self . _handlers . remove ( instance ) if self . _handlers and index > 0 : self . _handlers [ index - 1 ] . _receiver = instance . _receiver instance . on_connectionLost ()","title":"unregister()"},{"location":"api/protocols/manager/#mapper.protocols.manager.Manager.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required escape bool If true, escapes line endings and IAC characters. False Source code in mapper\\protocols\\manager.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def write ( self , data : bytes , escape : bool = False ) -> None : \"\"\" Writes data to peer. Args: data: The bytes to be written. escape: If true, escapes line endings and IAC characters. \"\"\" if escape : data = ( escapeIAC ( data ) . replace ( CR_LF , LF ) . replace ( CR_NULL , CR ) . replace ( CR , CR_NULL ) . replace ( LF , CR_LF ) ) if not self . isConnected or not self . _handlers : self . _writeBuffer . append ( data ) elif self . _writeBuffer : data = b \"\" . join ( self . _writeBuffer ) + data self . _writeBuffer . clear () self . _writer ( data ) elif data : self . _writer ( data )","title":"write()"},{"location":"api/protocols/mpi/","text":"Module mapper.protocols.mpi \u00b6 Mume Remote Editing Protocol. Class MPIProtocol \u00b6 Implements support for the Mume remote editing protocol. Attributes: Name Type Description commandMap Mapping[bytes, Callable[]] A mapping of bytes to callables. editor str The program to use for editing received text. pager str The program to use for viewing received read-only text. Attribute state: str property writable \u00b6 The state of the state machine. Valid values are in states . Attribute states: AbstractSet [ str ] \u00b6 Valid states for the state machine. Method edit ( self , data ) \u00b6 Edits text using the program defined in editor . Parameters: Name Type Description Default data bytes Received data from Mume, containing the session, description, and body of the text. required Source code in mapper\\protocols\\mpi.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" session , description , body = data [ 1 :] . split ( LF , 2 ) with tempfile . NamedTemporaryFile ( prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( body . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) lastModified = os . path . getmtime ( fileName ) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { fileName } :MPICOMMAND\" ) input ( \"Continue:\" ) else : editorProcess = subprocess . Popen (( * self . editor . split (), fileName )) editorProcess . wait () if os . path . getmtime ( fileName ) == lastModified : # The user closed the text editor without saving. Cancel the editing session. response = b \"C\" + session else : with open ( fileName , \"rb\" ) as fileObj : response = b \"E\" + session + LF + fileObj . read () response = response . replace ( CR , b \"\" ) . strip () + LF removeFile ( fileName ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( response ) + LF + response ) Method on_command ( self , command , data ) \u00b6 Called when an MPI command is received. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mapper\\protocols\\mpi.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . commandMap : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandledCommand ( command , data ) elif self . commandMap [ command ] is not None : thread = threading . Thread ( target = self . commandMap [ command ], args = ( data ,), daemon = True ) self . _MPIThreads . append ( thread ) thread . start () Method on_connectionLost ( self ) \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\mpi.py 208 209 210 211 212 def on_connectionLost ( self ) -> None : # Clean up any active editing sessions. for thread in self . _MPIThreads : thread . join () self . _MPIThreads . clear () Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\mpi.py 204 205 206 def on_connectionMade ( self ) -> None : # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF ) Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\mpi.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( LF ) appDataBuffer . append ( appData + separator ) if separator : self . state = \"newline\" elif self . state == \"newline\" : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = \"init\" else : self . state = \"data\" elif self . state == \"init\" : remaining = len ( MPI_INIT ) - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _MPIBuffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . _MPIBuffer . clear () self . state = \"command\" elif not MPI_INIT . startswith ( self . _MPIBuffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _MPIBuffer ) + data self . _MPIBuffer . clear () self . state = \"data\" elif self . state == \"command\" : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = \"length\" elif self . state == \"length\" : length , separator , data = data . partition ( LF ) self . _MPIBuffer . extend ( length ) if not self . _MPIBuffer . isdigit (): logger . warning ( f \"Invalid data { self . _MPIBuffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _MPIBuffer ) + separator + data del self . _command self . _MPIBuffer . clear () self . state = \"data\" elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _MPIBuffer ) self . _MPIBuffer . clear () self . state = \"body\" elif self . state == \"body\" : remaining = self . _length - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _MPIBuffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _MPIBuffer )) del self . _command del self . _length self . _MPIBuffer . clear () self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) Method on_unhandledCommand ( self , command , data ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mapper\\protocols\\mpi.py 214 215 216 217 218 219 220 221 222 def on_unhandledCommand ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_dataReceived ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data ) Method view ( self , data ) \u00b6 Views text using the program defined in pager . Parameters: Name Type Description Default data bytes Received data from Mume, containing the text. required Source code in mapper\\protocols\\mpi.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" with tempfile . NamedTemporaryFile ( prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( data . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { fileName } :MPICOMMAND\" ) else : pagerProcess = subprocess . Popen (( * self . pager . split (), fileName )) pagerProcess . wait () removeFile ( fileName ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\mpi.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"mpi.py"},{"location":"api/protocols/mpi/#mapper.protocols.mpi","text":"Mume Remote Editing Protocol.","title":"mpi"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol","text":"Implements support for the Mume remote editing protocol. Attributes: Name Type Description commandMap Mapping[bytes, Callable[]] A mapping of bytes to callables. editor str The program to use for editing received text. pager str The program to use for viewing received read-only text.","title":"MPIProtocol"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.state","text":"The state of the state machine. Valid values are in states .","title":"state"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.states","text":"Valid states for the state machine.","title":"states"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.edit","text":"Edits text using the program defined in editor . Parameters: Name Type Description Default data bytes Received data from Mume, containing the session, description, and body of the text. required Source code in mapper\\protocols\\mpi.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def edit ( self , data : bytes ) -> None : \"\"\" Edits text using the program defined in `editor`. Args: data: Received data from Mume, containing the session, description, and body of the text. \"\"\" session , description , body = data [ 1 :] . split ( LF , 2 ) with tempfile . NamedTemporaryFile ( prefix = \"mume_editing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( body . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) lastModified = os . path . getmtime ( fileName ) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . editor } { fileName } :MPICOMMAND\" ) input ( \"Continue:\" ) else : editorProcess = subprocess . Popen (( * self . editor . split (), fileName )) editorProcess . wait () if os . path . getmtime ( fileName ) == lastModified : # The user closed the text editor without saving. Cancel the editing session. response = b \"C\" + session else : with open ( fileName , \"rb\" ) as fileObj : response = b \"E\" + session + LF + fileObj . read () response = response . replace ( CR , b \"\" ) . strip () + LF removeFile ( fileName ) self . write ( MPI_INIT + b \"E\" + b \" %d \" % len ( response ) + LF + response )","title":"edit()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.on_command","text":"Called when an MPI command is received. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mapper\\protocols\\mpi.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def on_command ( self , command : bytes , data : bytes ) -> None : \"\"\" Called when an MPI command is received. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" if command not in self . commandMap : logger . warning ( f \"Invalid MPI command { command !r} .\" ) self . on_unhandledCommand ( command , data ) elif self . commandMap [ command ] is not None : thread = threading . Thread ( target = self . commandMap [ command ], args = ( data ,), daemon = True ) self . _MPIThreads . append ( thread ) thread . start ()","title":"on_command()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\mpi.py 208 209 210 211 212 def on_connectionLost ( self ) -> None : # Clean up any active editing sessions. for thread in self . _MPIThreads : thread . join () self . _MPIThreads . clear ()","title":"on_connectionLost()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\mpi.py 204 205 206 def on_connectionMade ( self ) -> None : # Identify for Mume Remote Editing. self . write ( MPI_INIT + b \"I\" + LF )","title":"on_connectionMade()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\mpi.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( LF ) appDataBuffer . append ( appData + separator ) if separator : self . state = \"newline\" elif self . state == \"newline\" : if MPI_INIT . startswith ( data [: len ( MPI_INIT )]): # Data starts with some or all of the MPI_INIT sequence. self . state = \"init\" else : self . state = \"data\" elif self . state == \"init\" : remaining = len ( MPI_INIT ) - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if self . _MPIBuffer == MPI_INIT : # The final byte in the MPI_INIT sequence has been reached. if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . _MPIBuffer . clear () self . state = \"command\" elif not MPI_INIT . startswith ( self . _MPIBuffer ): # The Bytes in the buffer are not part of an MPI init sequence. data = bytes ( self . _MPIBuffer ) + data self . _MPIBuffer . clear () self . state = \"data\" elif self . state == \"command\" : # The MPI command is a single byte. self . _command , data = data [: 1 ], data [ 1 :] self . state = \"length\" elif self . state == \"length\" : length , separator , data = data . partition ( LF ) self . _MPIBuffer . extend ( length ) if not self . _MPIBuffer . isdigit (): logger . warning ( f \"Invalid data { self . _MPIBuffer !r} in MPI length. Digit expected.\" ) data = MPI_INIT + self . _command + bytes ( self . _MPIBuffer ) + separator + data del self . _command self . _MPIBuffer . clear () self . state = \"data\" elif separator : # The buffer contains the length of subsequent bytes to be received. self . _length = int ( self . _MPIBuffer ) self . _MPIBuffer . clear () self . state = \"body\" elif self . state == \"body\" : remaining = self . _length - len ( self . _MPIBuffer ) self . _MPIBuffer . extend ( data [: remaining ]) data = data [ remaining :] if len ( self . _MPIBuffer ) == self . _length : # The final byte in the expected MPI data has been received. self . on_command ( self . _command , bytes ( self . _MPIBuffer )) del self . _command del self . _length self . _MPIBuffer . clear () self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The MPI command, consisting of a single byte. required data bytes The payload. required Source code in mapper\\protocols\\mpi.py 214 215 216 217 218 219 220 221 222 def on_unhandledCommand ( self , command : bytes , data : bytes ) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The MPI command, consisting of a single byte. data: The payload. \"\"\" super () . on_dataReceived ( MPI_INIT + command + b \" %d \" % len ( data ) + LF + data )","title":"on_unhandledCommand()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.view","text":"Views text using the program defined in pager . Parameters: Name Type Description Default data bytes Received data from Mume, containing the text. required Source code in mapper\\protocols\\mpi.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def view ( self , data : bytes ) -> None : \"\"\" Views text using the program defined in `pager`. Args: data: Received data from Mume, containing the text. \"\"\" with tempfile . NamedTemporaryFile ( prefix = \"mume_viewing_\" , suffix = \".txt\" , delete = False ) as fileObj : fileName = fileObj . name fileObj . write ( data . replace ( CR , b \"\" ) . replace ( LF , CR_LF )) if self . outputFormat == \"tintin\" : print ( f \"MPICOMMAND: { self . pager } { fileName } :MPICOMMAND\" ) else : pagerProcess = subprocess . Popen (( * self . pager . split (), fileName )) pagerProcess . wait () removeFile ( fileName )","title":"view()"},{"location":"api/protocols/mpi/#mapper.protocols.mpi.MPIProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\mpi.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/proxy/","text":"Module mapper.protocols.proxy \u00b6 Class Game \u00b6 Attribute charset: bytes property writable \u00b6 The character set to be used. Attribute charsets: Sequence [ bytes ] \u00b6 Supported character sets. Attribute state: str inherited property writable \u00b6 The state of the state machine. Valid values are in states . Attribute states: AbstractSet [ str ] inherited \u00b6 Valid states for the state machine. Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\proxy.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\proxy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) Method getOptionState ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\proxy.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] Method negotiateCharset ( self , name ) \u00b6 Negotiates changing the character set. Parameters: Name Type Description Default name bytes The name of the character set to use. required Source code in mapper\\protocols\\proxy.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def negotiateCharset ( self , name : bytes ) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" self . _oldCharset = self . charset try : self . charset = name except ValueError : logger . warning ( f \"Invalid charset { name !r} : falling back to { self . charset !r} .\" ) name = self . charset separator = b \";\" logger . debug ( f \"Tell peer we would like to use the { name !r} charset.\" ) self . requestNegotiation ( CHARSET , CHARSET_REQUEST + separator + name ) Method on_charset ( self , data ) \u00b6 Called when a charset subnegotiation is received. Parameters: Name Type Description Default data bytes The payload. required Source code in mapper\\protocols\\proxy.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) if self . charset == self . _oldCharset : logger . warning ( f \"Unable to fall back to { self . _oldCharset !r} . Old and new charsets match.\" ) else : logger . debug ( f \"Falling back to { self . _oldCharset !r} .\" ) self . charset = self . _oldCharset else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . charset = self . _oldCharset self . wont ( CHARSET ) del self . _oldCharset Method on_command ( self , command , option ) inherited \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 54 55 56 57 58 59 60 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in NEGOTIATION_BYTES and option not in self . subnegotiationMap : # Treat any unhandled negotiation options the same as unhandled commands, so # they are forwarded to the other end of the proxy. self . on_unhandledCommand ( command , option ) else : super () . on_command ( command , option ) Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\proxy.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\proxy.py 150 151 152 153 154 155 def on_connectionMade ( self ): super () . on_connectionMade () # Offer to handle charset. self . will ( CHARSET ) # Tell the Mume server to put IAC-GA at end of prompts. self . write ( MPI_INIT + b \"P2\" + LF + b \"G\" + LF ) Method on_dataReceived ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\proxy.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) Method on_disableLocal ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 173 174 175 176 def on_disableLocal ( self , option : bytes ) -> None : if option == CHARSET : return super () . on_disableLocal ( option ) Method on_disableRemote ( self , option ) inherited \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_do ( self , option ) inherited \u00b6 Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_dont ( self , option ) inherited \u00b6 Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 166 167 168 169 170 171 def on_enableLocal ( self , option : bytes ) -> bool : if option == CHARSET : logger . debug ( \"Peer acknowledges our request and tells us to begin charset sub-negotiation.\" ) self . negotiateCharset ( self . charset ) return True return super () . on_enableLocal ( option ) Method on_enableRemote ( self , option ) inherited \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_ga ( self , * args ) \u00b6 Called when a Go Ahead command is received. Source code in mapper\\protocols\\proxy.py 146 147 148 def on_ga ( self , * args ) -> None : \"\"\"Called when a Go Ahead command is received.\"\"\" self . proxy . player . write ( self . proxy . promptTerminator ) Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) Method on_unhandledCommand ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 157 158 159 160 161 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : if option is None : self . proxy . player . write ( IAC + command ) else : self . proxy . player . write ( IAC + command + option ) Method on_unhandledSubnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 163 164 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : self . proxy . player . write ( IAC + SB + option + data + IAC + SE ) Method on_will ( self , option ) inherited \u00b6 Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_wont ( self , option ) inherited \u00b6 Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) Method requestNegotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\proxy.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\proxy.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\proxy.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data ) Class Player \u00b6 Attribute state: str inherited property writable \u00b6 The state of the state machine. Valid values are in states . Attribute states: AbstractSet [ str ] inherited \u00b6 Valid states for the state machine. Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\proxy.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\proxy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) Method getOptionState ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\proxy.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] Method on_command ( self , command , option ) inherited \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 54 55 56 57 58 59 60 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in NEGOTIATION_BYTES and option not in self . subnegotiationMap : # Treat any unhandled negotiation options the same as unhandled commands, so # they are forwarded to the other end of the proxy. self . on_unhandledCommand ( command , option ) else : super () . on_command ( command , option ) Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\proxy.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\proxy.py 56 57 def on_connectionMade ( self ) -> None : pass Method on_dataReceived ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\proxy.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) Method on_disableLocal ( self , option ) inherited \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 622 623 def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_disableRemote ( self , option ) inherited \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_do ( self , option ) inherited \u00b6 Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_dont ( self , option ) inherited \u00b6 Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 76 77 78 79 def on_enableLocal ( self , option : bytes ) -> bool : if option in self . proxy . game . _handlers [ 0 ] . subnegotiationMap : return False return super () . on_enableLocal ( option ) Method on_enableRemote ( self , option ) inherited \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) Method on_unhandledCommand ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 67 68 69 70 71 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : if option is None : self . proxy . game . write ( IAC + command ) else : self . proxy . game . write ( IAC + command + option ) Method on_unhandledSubnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 73 74 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : self . proxy . game . write ( IAC + SB + option + data + IAC + SE ) Method on_will ( self , option ) inherited \u00b6 Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_wont ( self , option ) inherited \u00b6 Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) Method requestNegotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\proxy.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\proxy.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\proxy.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data ) Class Telnet \u00b6 Attributes: Name Type Description name str The name of this side of the connection. Can be 'game' or 'player'. proxy ProxyHandler The proxy that spawned this object. Attribute state: str inherited property writable \u00b6 The state of the state machine. Valid values are in states . Attribute states: AbstractSet [ str ] inherited \u00b6 Valid states for the state machine. Method do ( self , option ) inherited \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\proxy.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) Method dont ( self , option ) inherited \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\proxy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) Method getOptionState ( self , option ) inherited \u00b6 Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\proxy.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] Method on_command ( self , command , option ) \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 54 55 56 57 58 59 60 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in NEGOTIATION_BYTES and option not in self . subnegotiationMap : # Treat any unhandled negotiation options the same as unhandled commands, so # they are forwarded to the other end of the proxy. self . on_unhandledCommand ( command , option ) else : super () . on_command ( command , option ) Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\proxy.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\proxy.py 56 57 def on_connectionMade ( self ) -> None : pass Method on_dataReceived ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\proxy.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) Method on_disableLocal ( self , option ) inherited \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 622 623 def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_disableRemote ( self , option ) inherited \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_do ( self , option ) inherited \u00b6 Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_dont ( self , option ) inherited \u00b6 Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) Method on_enableLocal ( self , option ) inherited \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 616 617 def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_enableRemote ( self , option ) inherited \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_subnegotiation ( self , option , data ) inherited \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) Method on_unhandledCommand ( self , command , option ) inherited \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 610 611 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass Method on_unhandledSubnegotiation ( self , option , data ) inherited \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 613 614 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass Method on_will ( self , option ) inherited \u00b6 Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_wont ( self , option ) inherited \u00b6 Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) Method requestNegotiation ( self , option , data ) inherited \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) Method will ( self , option ) inherited \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\proxy.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) Method wont ( self , option ) inherited \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\proxy.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\proxy.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"proxy.py"},{"location":"api/protocols/proxy/#mapper.protocols.proxy","text":"","title":"proxy"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game","text":"","title":"Game"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.charset","text":"The character set to be used.","title":"charset"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.charsets","text":"Supported character sets.","title":"charsets"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.state","text":"The state of the state machine. Valid values are in states .","title":"state"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.states","text":"Valid states for the state machine.","title":"states"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\proxy.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option )","title":"do()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\proxy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option )","title":"dont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.getOptionState","text":"Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\proxy.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ]","title":"getOptionState()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.negotiateCharset","text":"Negotiates changing the character set. Parameters: Name Type Description Default name bytes The name of the character set to use. required Source code in mapper\\protocols\\proxy.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def negotiateCharset ( self , name : bytes ) -> None : \"\"\" Negotiates changing the character set. Args: name: The name of the character set to use. \"\"\" self . _oldCharset = self . charset try : self . charset = name except ValueError : logger . warning ( f \"Invalid charset { name !r} : falling back to { self . charset !r} .\" ) name = self . charset separator = b \";\" logger . debug ( f \"Tell peer we would like to use the { name !r} charset.\" ) self . requestNegotiation ( CHARSET , CHARSET_REQUEST + separator + name )","title":"negotiateCharset()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_charset","text":"Called when a charset subnegotiation is received. Parameters: Name Type Description Default data bytes The payload. required Source code in mapper\\protocols\\proxy.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def on_charset ( self , data : bytes ) -> None : \"\"\" Called when a charset subnegotiation is received. Args: data: The payload. \"\"\" status , response = data [: 1 ], data [ 1 :] if status == CHARSET_ACCEPTED : logger . debug ( f \"Peer responds: Charset { response !r} accepted.\" ) elif status == CHARSET_REJECTED : logger . warning ( \"Peer responds: Charset rejected.\" ) if self . charset == self . _oldCharset : logger . warning ( f \"Unable to fall back to { self . _oldCharset !r} . Old and new charsets match.\" ) else : logger . debug ( f \"Falling back to { self . _oldCharset !r} .\" ) self . charset = self . _oldCharset else : logger . warning ( f \"Unknown charset negotiation response from peer: { data !r} \" ) self . charset = self . _oldCharset self . wont ( CHARSET ) del self . _oldCharset","title":"on_charset()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 54 55 56 57 58 59 60 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in NEGOTIATION_BYTES and option not in self . subnegotiationMap : # Treat any unhandled negotiation options the same as unhandled commands, so # they are forwarded to the other end of the proxy. self . on_unhandledCommand ( command , option ) else : super () . on_command ( command , option )","title":"on_command()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\proxy.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\proxy.py 150 151 152 153 154 155 def on_connectionMade ( self ): super () . on_connectionMade () # Offer to handle charset. self . will ( CHARSET ) # Tell the Mume server to put IAC-GA at end of prompts. self . write ( MPI_INIT + b \"P2\" + LF + b \"G\" + LF )","title":"on_connectionMade()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\proxy.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 173 174 175 176 def on_disableLocal ( self , option : bytes ) -> None : if option == CHARSET : return super () . on_disableLocal ( option )","title":"on_disableLocal()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableRemote()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_do","text":"Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_do()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_dont","text":"Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option )","title":"on_dont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 166 167 168 169 170 171 def on_enableLocal ( self , option : bytes ) -> bool : if option == CHARSET : logger . debug ( \"Peer acknowledges our request and tells us to begin charset sub-negotiation.\" ) self . negotiateCharset ( self . charset ) return True return super () . on_enableLocal ( option )","title":"on_enableLocal()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableRemote()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_ga","text":"Called when a Go Ahead command is received. Source code in mapper\\protocols\\proxy.py 146 147 148 def on_ga ( self , * args ) -> None : \"\"\"Called when a Go Ahead command is received.\"\"\" self . proxy . player . write ( self . proxy . promptTerminator )","title":"on_ga()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data )","title":"on_subnegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 157 158 159 160 161 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : if option is None : self . proxy . player . write ( IAC + command ) else : self . proxy . player . write ( IAC + command + option )","title":"on_unhandledCommand()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 163 164 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : self . proxy . player . write ( IAC + SB + option + data + IAC + SE )","title":"on_unhandledSubnegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_will","text":"Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_will()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.on_wont","text":"Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option )","title":"on_wont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE )","title":"requestNegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\proxy.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option )","title":"will()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\proxy.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option )","title":"wont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Game.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\proxy.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player","text":"","title":"Player"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.state","text":"The state of the state machine. Valid values are in states .","title":"state"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.states","text":"Valid states for the state machine.","title":"states"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\proxy.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option )","title":"do()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\proxy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option )","title":"dont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.getOptionState","text":"Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\proxy.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ]","title":"getOptionState()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 54 55 56 57 58 59 60 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in NEGOTIATION_BYTES and option not in self . subnegotiationMap : # Treat any unhandled negotiation options the same as unhandled commands, so # they are forwarded to the other end of the proxy. self . on_unhandledCommand ( command , option ) else : super () . on_command ( command , option )","title":"on_command()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\proxy.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\proxy.py 56 57 def on_connectionMade ( self ) -> None : pass","title":"on_connectionMade()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\proxy.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 622 623 def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableLocal()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableRemote()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_do","text":"Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_do()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_dont","text":"Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option )","title":"on_dont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 76 77 78 79 def on_enableLocal ( self , option : bytes ) -> bool : if option in self . proxy . game . _handlers [ 0 ] . subnegotiationMap : return False return super () . on_enableLocal ( option )","title":"on_enableLocal()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableRemote()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data )","title":"on_subnegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 67 68 69 70 71 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : if option is None : self . proxy . game . write ( IAC + command ) else : self . proxy . game . write ( IAC + command + option )","title":"on_unhandledCommand()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 73 74 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : self . proxy . game . write ( IAC + SB + option + data + IAC + SE )","title":"on_unhandledSubnegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_will","text":"Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_will()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.on_wont","text":"Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option )","title":"on_wont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE )","title":"requestNegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\proxy.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option )","title":"will()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\proxy.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option )","title":"wont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Player.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\proxy.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet","text":"Attributes: Name Type Description name str The name of this side of the connection. Can be 'game' or 'player'. proxy ProxyHandler The proxy that spawned this object.","title":"Telnet"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.state","text":"The state of the state machine. Valid values are in states .","title":"state"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.states","text":"Valid states for the state machine.","title":"states"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\proxy.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option )","title":"do()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\proxy.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option )","title":"dont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.getOptionState","text":"Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\proxy.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ]","title":"getOptionState()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 54 55 56 57 58 59 60 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : if command in NEGOTIATION_BYTES and option not in self . subnegotiationMap : # Treat any unhandled negotiation options the same as unhandled commands, so # they are forwarded to the other end of the proxy. self . on_unhandledCommand ( command , option ) else : super () . on_command ( command , option )","title":"on_command()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\proxy.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\proxy.py 56 57 def on_connectionMade ( self ) -> None : pass","title":"on_connectionMade()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\proxy.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 622 623 def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableLocal()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\proxy.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableRemote()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_do","text":"Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_do()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_dont","text":"Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option )","title":"on_dont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 616 617 def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableLocal()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\proxy.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableRemote()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data )","title":"on_subnegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\proxy.py 610 611 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass","title":"on_unhandledCommand()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 613 614 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass","title":"on_unhandledSubnegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_will","text":"Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_will()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.on_wont","text":"Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\proxy.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option )","title":"on_wont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\proxy.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE )","title":"requestNegotiation()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\proxy.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option )","title":"will()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\proxy.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option )","title":"wont()"},{"location":"api/protocols/proxy/#mapper.protocols.proxy.Telnet.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\proxy.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/telnet/","text":"Module mapper.protocols.telnet \u00b6 Telnet protocol. Class BaseTelnetProtocol \u00b6 Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\telnet.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\telnet.py 56 57 def on_connectionMade ( self ) -> None : pass Method on_dataReceived ( self , data ) inherited \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\telnet.py 62 63 def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data ) Method on_disableLocal ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 150 151 152 153 154 155 156 157 158 159 160 161 162 @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" Method on_disableRemote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\" Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\" Method on_enableRemote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 138 139 140 141 142 143 144 145 146 147 148 @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\" Method on_unhandledCommand ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\telnet.py 106 107 108 109 110 111 112 113 114 @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" Method on_unhandledSubnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 116 117 118 119 120 121 122 123 124 @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\" Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\telnet.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data ) Class TelnetError \u00b6 Implements the base class for Telnet exceptions. Class TelnetProtocol \u00b6 Implements the Telnet protocol. Attributes: Name Type Description commandMap Mapping[bytes, Callable[]] A mapping of bytes to callables. When a Telnet command is received, the command byte (the first byte after IAC) is looked up in this dictionary. If a callable is found, it is invoked with the argument of the command, or None if the command takes no argument. Values should be added to this dictionary if commands wish to be handled. By default, only WILL, WONT, DO, and DONT are handled. These should not be overridden, as this class handles them correctly and provides an API for interacting with them. subnegotiationMap Mapping[bytes, Callable[]] A mapping of bytes to callables. When a subnegotiation command is received, the option byte (the first byte after SB) is looked up in this dictionary. If a callable is found, it is invoked with the argument of the subnegotiation. Values should be added to this dictionary if subnegotiations are to be handled. By default, no values are handled. Attribute state: str property writable \u00b6 The state of the state machine. Valid values are in states . Attribute states: AbstractSet [ str ] \u00b6 Valid states for the state machine. Method do ( self , option ) \u00b6 Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\telnet.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option ) Method dont ( self , option ) \u00b6 Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\telnet.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option ) Method getOptionState ( self , option ) \u00b6 Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\telnet.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ] Method on_command ( self , command , option ) \u00b6 Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\telnet.py 458 459 460 461 462 463 464 465 466 467 468 469 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" if command in self . commandMap : self . commandMap [ command ]( option ) else : self . on_unhandledCommand ( command , option ) Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\telnet.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) inherited \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\telnet.py 56 57 def on_connectionMade ( self ) -> None : pass Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\telnet.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) Method on_disableLocal ( self , option ) \u00b6 Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 622 623 def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_disableRemote ( self , option ) \u00b6 Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" ) Method on_do ( self , option ) \u00b6 Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_dont ( self , option ) \u00b6 Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option ) Method on_enableLocal ( self , option ) \u00b6 Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 616 617 def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_enableRemote ( self , option ) \u00b6 Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default. Method on_subnegotiation ( self , option , data ) \u00b6 Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data ) Method on_unhandledCommand ( self , command , option ) \u00b6 Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\telnet.py 610 611 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass Method on_unhandledSubnegotiation ( self , option , data ) \u00b6 Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 613 614 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass Method on_will ( self , option ) \u00b6 Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" ) Method on_wont ( self , option ) \u00b6 Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option ) Method requestNegotiation ( self , option , data ) \u00b6 Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE ) Method will ( self , option ) \u00b6 Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\telnet.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option ) Method wont ( self , option ) \u00b6 Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\telnet.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option ) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\telnet.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"telnet.py"},{"location":"api/protocols/telnet/#mapper.protocols.telnet","text":"Telnet protocol.","title":"telnet"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol","text":"","title":"BaseTelnetProtocol"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\telnet.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\telnet.py 56 57 def on_connectionMade ( self ) -> None : pass","title":"on_connectionMade()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\telnet.py 62 63 def on_dataReceived ( self , data : bytes ) -> None : self . _receiver ( data )","title":"on_dataReceived()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 150 151 152 153 154 155 156 157 158 159 160 161 162 @abstractmethod def on_disableLocal ( self , option : bytes ) -> None : \"\"\" Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note: If on_enableLocal is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\"","title":"on_disableLocal()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @abstractmethod def on_disableRemote ( self , option : bytes ) -> None : \"\"\" Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note: If on_enableRemote is overridden, this method must be overridden as well. Args: option: The option being disabled. \"\"\"","title":"on_disableRemote()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 126 127 128 129 130 131 132 133 134 135 136 @abstractmethod def on_enableLocal ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for us to manage the option. Args: option: The option that peer requests us to handle. Returns: True if we will handle the option, False otherwise. \"\"\"","title":"on_enableLocal()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 138 139 140 141 142 143 144 145 146 147 148 @abstractmethod def on_enableRemote ( self , option : bytes ) -> bool : \"\"\" Called to accept or reject the request for peer to manage the option. Args: option: The option that peer wants to handle. Returns: True if we will allow peer to handle the option, False otherwise. \"\"\"","title":"on_enableRemote()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\telnet.py 106 107 108 109 110 111 112 113 114 @abstractmethod def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called for commands for which no handler is installed. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\"","title":"on_unhandledCommand()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 116 117 118 119 120 121 122 123 124 @abstractmethod def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called for subnegotiations for which no handler is installed. Args: option: The subnegotiation option. data: The payload. \"\"\"","title":"on_unhandledSubnegotiation()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.BaseTelnetProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\telnet.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetError","text":"Implements the base class for Telnet exceptions.","title":"TelnetError"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol","text":"Implements the Telnet protocol. Attributes: Name Type Description commandMap Mapping[bytes, Callable[]] A mapping of bytes to callables. When a Telnet command is received, the command byte (the first byte after IAC) is looked up in this dictionary. If a callable is found, it is invoked with the argument of the command, or None if the command takes no argument. Values should be added to this dictionary if commands wish to be handled. By default, only WILL, WONT, DO, and DONT are handled. These should not be overridden, as this class handles them correctly and provides an API for interacting with them. subnegotiationMap Mapping[bytes, Callable[]] A mapping of bytes to callables. When a subnegotiation command is received, the option byte (the first byte after SB) is looked up in this dictionary. If a callable is found, it is invoked with the argument of the subnegotiation. Values should be added to this dictionary if subnegotiations are to be handled. By default, no values are handled.","title":"TelnetProtocol"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.state","text":"The state of the state machine. Valid values are in states .","title":"state"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.states","text":"Valid states for the state machine.","title":"states"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.do","text":"Requests that the peer enable an option. Parameters: Name Type Description Default option bytes The option to enable. required Source code in mapper\\protocols\\telnet.py 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def do ( self , option : bytes ) -> None : \"\"\" Requests that the peer enable an option. Args: option: The option to enable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . him . enabled : logger . warning ( f \"Requesting that peer enable an already enabled option { option !r} .\" ) else : state . him . negotiating = True self . _do ( option )","title":"do()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.dont","text":"Requests that the peer disable an option. Parameters: Name Type Description Default option bytes The option to disable. required Source code in mapper\\protocols\\telnet.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 def dont ( self , option : bytes ) -> None : \"\"\" Requests that the peer disable an option. Args: option: The option to disable. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are requesting that peer disable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . him . enabled : logger . warning ( f \"Requesting that peer disable an already disabled option { option !r} .\" ) else : state . him . negotiating = True self . _dont ( option )","title":"dont()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.getOptionState","text":"Gets the state of a Telnet option. Returns: Type Description _OptionState An object containing the option state. Source code in mapper\\protocols\\telnet.py 348 349 350 351 352 353 354 355 356 357 def getOptionState ( self , option : bytes ) -> _OptionState : \"\"\" Gets the state of a Telnet option. Returns: An object containing the option state. \"\"\" if option not in self . _options : self . _options [ option ] = _OptionState () return self . _options [ option ]","title":"getOptionState()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_command","text":"Called when a 1 or 2 byte command is received. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\telnet.py 458 459 460 461 462 463 464 465 466 467 468 469 def on_command ( self , command : bytes , option : Union [ bytes , None ]) -> None : \"\"\" Called when a 1 or 2 byte command is received. Args: command: The first byte in a 1 or 2 byte negotiation sequence. option: The second byte in a 2 byte negotiation sequence or None. \"\"\" if command in self . commandMap : self . commandMap [ command ]( option ) else : self . on_unhandledCommand ( command , option )","title":"on_command()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\telnet.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\telnet.py 56 57 def on_connectionMade ( self ) -> None : pass","title":"on_connectionMade()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\telnet.py 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( IAC ) if separator : self . state = \"command\" elif appData . endswith ( CR ): self . state = \"newline\" appData = appData [: - 1 ] appDataBuffer . append ( appData . replace ( CR_LF , LF ) . replace ( CR_NULL , CR )) continue byte , data = data [: 1 ], data [ 1 :] if self . state == \"command\" : if byte == IAC : # Escaped IAC. appDataBuffer . append ( byte ) self . state = \"data\" elif byte == SE : self . state = \"data\" logger . warning ( \"IAC SE received outside of subnegotiation.\" ) elif byte == SB : self . state = \"subnegotiation\" self . _commands = [] elif byte in COMMAND_BYTES : self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( byte , None ) elif byte in NEGOTIATION_BYTES : self . state = \"negotiation\" self . _command = byte else : self . state = \"data\" logger . warning ( f \"Unknown Telnet command received { byte !r} .\" ) elif self . state == \"negotiation\" : self . state = \"data\" command = self . _command del self . _command if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_command ( command , byte ) elif self . state == \"newline\" : self . state = \"data\" if byte == LF : appDataBuffer . append ( byte ) elif byte == NULL : appDataBuffer . append ( CR ) elif byte == IAC : # IAC isn't really allowed after CR, according to the # RFC, but handling it this way is less surprising than # delivering the IAC to the app as application data. # The purpose of the restriction is to allow terminals # to unambiguously interpret the behavior of the CR # after reading only one more byte. CR + LF is supposed # to mean one thing (cursor to next line, first column), # CR + NUL another (cursor to first column). Absent the # NUL, it still makes sense to interpret this as CR and # then apply all the usual interpretation to the IAC. appDataBuffer . append ( CR ) self . state = \"command\" else : appDataBuffer . append ( CR + byte ) elif self . state == \"subnegotiation\" : if byte == IAC : self . state = \"subnegotiation-escaped\" else : self . _commands . append ( byte ) elif self . state == \"subnegotiation-escaped\" : if byte == SE : self . state = \"data\" commands = b \"\" . join ( self . _commands ) del self . _commands if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) appDataBuffer . clear () self . on_subnegotiation ( commands [: 1 ], commands [ 1 :]) else : self . state = \"subnegotiation\" self . _commands . append ( byte ) else : logger . warning ( f \"Invalid Telnet state { self . state !r} . How'd you do this?\" ) appDataBuffer . append ( byte ) self . state = \"data\" if appDataBuffer : super () . on_dataReceived ( b \"\" . join ( appDataBuffer ))","title":"on_dataReceived()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_disableLocal","text":"Disables a locally managed option. This method is called before we disable a locally enabled option, in order to perform any necessary cleanup. Note If on_enableLocal is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 622 623 def on_disableLocal ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableLocal()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_disableRemote","text":"Disables a remotely managed option. This method is called when peer disables a remotely enabled option, in order to perform any necessary cleanup on our end. Note If on_enableRemote is overridden, this method must be overridden as well. Parameters: Name Type Description Default option bytes The option being disabled. required Source code in mapper\\protocols\\telnet.py 625 626 def on_disableRemote ( self , option : bytes ) -> None : raise NotImplementedError ( f \"Don't know how to disable local Telnet option { option !r} \" )","title":"on_disableRemote()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_do","text":"Called when an IAC + DO + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 def on_do ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DO + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting that we enable an option. if self . on_enableLocal ( option ): state . us . enabled = True self . _will ( option ) else : self . _wont ( option ) elif not state . us . enabled and state . us . negotiating : # Peer agreed to allow us to enable an option at our request. state . us . enabled = True state . us . negotiating = False self . on_enableLocal ( option ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally requesting us to enable an already-enabled option. # Ignore this. pass elif state . us . enabled and state . us . negotiating : # This is a bogus state. It is here for completeness. It will never be # entered. raise AssertionError ( f \"us.enabled and us.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_do()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_dont","text":"Called when an IAC + DONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 def on_dont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + DONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding us to disable an already-disabled option. # Ignore this. pass elif not state . us . enabled and state . us . negotiating : # Offered option was refused. state . us . negotiating = False logger . debug ( f \"Peer rejects our offer to enable option { option !r} .\" ) elif state . us . enabled and not state . us . negotiating : # Peer is unilaterally demanding we disable an option. state . us . enabled = False self . on_disableLocal ( option ) self . _wont ( option ) elif state . us . enabled and state . us . negotiating : # Peer acknowledged our notice that we will disable an option. state . us . enabled = False state . us . negotiating = False self . on_disableLocal ( option )","title":"on_dont()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_enableLocal","text":"Called to accept or reject the request for us to manage the option. Parameters: Name Type Description Default option bytes The option that peer requests us to handle. required Returns: Type Description bool True if we will handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 616 617 def on_enableLocal ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableLocal()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_enableRemote","text":"Called to accept or reject the request for peer to manage the option. Parameters: Name Type Description Default option bytes The option that peer wants to handle. required Returns: Type Description bool True if we will allow peer to handle the option, False otherwise. Source code in mapper\\protocols\\telnet.py 619 620 def on_enableRemote ( self , option : bytes ) -> bool : return False # Reject all options by default.","title":"on_enableRemote()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_subnegotiation","text":"Called when a subnegotiation is received. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 471 472 473 474 475 476 477 478 479 480 481 482 def on_subnegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Called when a subnegotiation is received. Args: option: The subnegotiation option. data: The payload. \"\"\" if option in self . subnegotiationMap : self . subnegotiationMap [ option ]( data ) else : self . on_unhandledSubnegotiation ( option , data )","title":"on_subnegotiation()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_unhandledCommand","text":"Called for commands for which no handler is installed. Parameters: Name Type Description Default command bytes The first byte in a 1 or 2 byte negotiation sequence. required option Union[bytes, None] The second byte in a 2 byte negotiation sequence or None. required Source code in mapper\\protocols\\telnet.py 610 611 def on_unhandledCommand ( self , command : bytes , option : Union [ bytes , None ]) -> None : pass","title":"on_unhandledCommand()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_unhandledSubnegotiation","text":"Called for subnegotiations for which no handler is installed. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 613 614 def on_unhandledSubnegotiation ( self , option : bytes , data : bytes ) -> None : pass","title":"on_unhandledSubnegotiation()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_will","text":"Called when an IAC + WILL + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 def on_will ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WILL + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an option. if self . on_enableRemote ( option ): state . him . enabled = True self . _do ( option ) else : self . _dont ( option ) elif not state . him . enabled and state . him . negotiating : # Peer agreed to enable an option in response to our request. state . him . enabled = True state . him . negotiating = False if not self . on_enableRemote ( option ): raise AssertionError ( f \"enableRemote must return True in this context (for option { option !r} )\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally offering to enable an already-enabled option. # Ignore this. pass elif state . him . enabled and state . him . negotiating : # This is a bogus state. It is here for completeness. It will # never be entered. raise AssertionError ( f \"him.enabled and him.negotiating cannot be True at the same time. state: { state !r} , option: { option !r} \" )","title":"on_will()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.on_wont","text":"Called when an IAC + WONT + option is received. Parameters: Name Type Description Default option Union[bytes, None] The received option. required Source code in mapper\\protocols\\telnet.py 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 def on_wont ( self , option : Union [ bytes , None ]) -> None : \"\"\" Called when an IAC + WONT + option is received. Args: option: The received option. \"\"\" if option is None : raise AssertionError ( \"Option must not be None in this context.\" ) state = self . getOptionState ( option ) if not state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an already-disabled option be/remain disabled. # Ignore this (although we could record it and refuse subsequent enable attempts # from our side, peer could refuse them again, so we won't). pass elif not state . him . enabled and state . him . negotiating : # Peer refused to enable an option in response to our request. state . him . negotiating = False logger . debug ( f \"Peer refuses to enable option { option !r} in response to our request.\" ) elif state . him . enabled and not state . him . negotiating : # Peer is unilaterally demanding that an option be disabled. state . him . enabled = False self . on_disableRemote ( option ) self . _dont ( option ) elif state . him . enabled and state . him . negotiating : # Peer agreed to disable an option at our request. state . him . enabled = False state . him . negotiating = False self . on_disableRemote ( option )","title":"on_wont()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.requestNegotiation","text":"Sends a subnegotiation message to the peer. Parameters: Name Type Description Default option bytes The subnegotiation option. required data bytes The payload. required Source code in mapper\\protocols\\telnet.py 359 360 361 362 363 364 365 366 367 def requestNegotiation ( self , option : bytes , data : bytes ) -> None : \"\"\" Sends a subnegotiation message to the peer. Args: option: The subnegotiation option. data: The payload. \"\"\" self . write ( IAC + SB + option + escapeIAC ( data ) + IAC + SE )","title":"requestNegotiation()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.will","text":"Indicates our willingness to enable an option. Parameters: Name Type Description Default option bytes The option to accept. required Source code in mapper\\protocols\\telnet.py 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 def will ( self , option : bytes ) -> None : \"\"\" Indicates our willingness to enable an option. Args: option: The option to accept. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are offering to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif state . us . enabled : logger . warning ( f \"Attempting to enable an already enabled option { option !r} .\" ) else : state . us . negotiating = True self . _will ( option )","title":"will()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.wont","text":"Indicates we are not willing to enable an option. Parameters: Name Type Description Default option bytes The option to reject. required Source code in mapper\\protocols\\telnet.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 def wont ( self , option : bytes ) -> None : \"\"\" Indicates we are not willing to enable an option. Args: option: The option to reject. \"\"\" state = self . getOptionState ( option ) if state . us . negotiating or state . him . negotiating : logger . warning ( f \"We are refusing to enable option { option !r} , but the option is \" + f \"already being negotiated by { 'us' if state . us . negotiating else 'peer' } .\" ) elif not state . us . enabled : logger . warning ( f \"Attempting to disable an already disabled option { option !r} .\" ) else : state . us . negotiating = True self . _wont ( option )","title":"wont()"},{"location":"api/protocols/telnet/#mapper.protocols.telnet.TelnetProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\telnet.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/protocols/telnet_constants/","text":"Module mapper.protocols.telnet_constants \u00b6 Telnet Constants. Definitions for various command and option negotiation bytes. ASCII Definitions Attributes: Name Type Description NULL bytes No operation. BEL bytes Produces an audible or visible signal (which does NOT move the print head). BS bytes Moves the print head one character position towards the left margin. HT bytes Moves the printer to the next horizontal tab stop. It remains unspecified how either party determines or establishes where such tab stops are located. LF bytes Moves the printer to the next print line, keeping the same horizontal position. VT bytes Moves the printer to the next vertical tab stop. It remains unspecified how either party determines or establishes where such tab stops are located. FF bytes Moves the printer to the top of the next page, keeping the same horizontal position. CR bytes Moves the printer to the left margin of the current line. Telnet Command Definitions Attributes: Name Type Description IAC bytes (Interpret As Command) Indicates the start of a Telnet command. NOP bytes No operation. DM bytes (Data Mark) The data stream portion of a Synch. This should always be accompanied by a TCP Urgent notification. BRK bytes NVT character Break. IP bytes The function Interrupt Process. AO bytes The function Abort Output AYT bytes The function Are You There. EC bytes The function Erase Character. EL bytes The function Erase Line GA bytes The Go Ahead signal. WILL bytes Indicates the desire to begin performing, or confirmation that you are now performing, the indicated option. WONT bytes Indicates the refusal to perform, or refusal to continue performing, the indicated option. DO bytes Indicates the request that the other party perform, or confirmation that you are expecting the other party to perform, the indicated option. DONT bytes Indicates the demand that the other party stop performing, or confirmation that you are no longer expecting the other party to perform, the indicated option. SB bytes Indicates what follows is a subnegotiation of the indicated option. SE bytes End of subnegotiation parameters. Telnet Option Definitions Attributes: Name Type Description ECHO bytes (User-to-Server) Asks the server to send Echos of the transmitted data. SGA bytes Suppress Go Ahead. Most modern servers should suppress it. TTYPE bytes Negotiate terminal type. NAWS bytes Negotiate About Window Size. LINEMODE bytes Allow line buffering to be negotiated. NEW_ENVIRON bytes Negotiate environment variables. CHARSET bytes Negotiate character set. Mud Specific Options Attributes: Name Type Description ATCP bytes Achaea Telnet Client Protocol. GMCP bytes Generic Mud Communication Protocol. MCCP1 bytes Mud Client Compression Protocol V1. MCCP2 bytes Mud Client Compression Protocol V2. MCCP3 bytes Mud Client Compression Protocol V3. MSDP bytes Mud Server Data Protocol. MSP bytes Mud Sound Protocol. MSSP bytes Mud Server Status Protocol. MXP bytes Mud Extention Protocol. ZMP bytes Zenith Mud Protocol.","title":"telnet_constants.py"},{"location":"api/protocols/telnet_constants/#mapper.protocols.telnet_constants","text":"Telnet Constants. Definitions for various command and option negotiation bytes. ASCII Definitions Attributes: Name Type Description NULL bytes No operation. BEL bytes Produces an audible or visible signal (which does NOT move the print head). BS bytes Moves the print head one character position towards the left margin. HT bytes Moves the printer to the next horizontal tab stop. It remains unspecified how either party determines or establishes where such tab stops are located. LF bytes Moves the printer to the next print line, keeping the same horizontal position. VT bytes Moves the printer to the next vertical tab stop. It remains unspecified how either party determines or establishes where such tab stops are located. FF bytes Moves the printer to the top of the next page, keeping the same horizontal position. CR bytes Moves the printer to the left margin of the current line. Telnet Command Definitions Attributes: Name Type Description IAC bytes (Interpret As Command) Indicates the start of a Telnet command. NOP bytes No operation. DM bytes (Data Mark) The data stream portion of a Synch. This should always be accompanied by a TCP Urgent notification. BRK bytes NVT character Break. IP bytes The function Interrupt Process. AO bytes The function Abort Output AYT bytes The function Are You There. EC bytes The function Erase Character. EL bytes The function Erase Line GA bytes The Go Ahead signal. WILL bytes Indicates the desire to begin performing, or confirmation that you are now performing, the indicated option. WONT bytes Indicates the refusal to perform, or refusal to continue performing, the indicated option. DO bytes Indicates the request that the other party perform, or confirmation that you are expecting the other party to perform, the indicated option. DONT bytes Indicates the demand that the other party stop performing, or confirmation that you are no longer expecting the other party to perform, the indicated option. SB bytes Indicates what follows is a subnegotiation of the indicated option. SE bytes End of subnegotiation parameters. Telnet Option Definitions Attributes: Name Type Description ECHO bytes (User-to-Server) Asks the server to send Echos of the transmitted data. SGA bytes Suppress Go Ahead. Most modern servers should suppress it. TTYPE bytes Negotiate terminal type. NAWS bytes Negotiate About Window Size. LINEMODE bytes Allow line buffering to be negotiated. NEW_ENVIRON bytes Negotiate environment variables. CHARSET bytes Negotiate character set. Mud Specific Options Attributes: Name Type Description ATCP bytes Achaea Telnet Client Protocol. GMCP bytes Generic Mud Communication Protocol. MCCP1 bytes Mud Client Compression Protocol V1. MCCP2 bytes Mud Client Compression Protocol V2. MCCP3 bytes Mud Client Compression Protocol V3. MSDP bytes Mud Server Data Protocol. MSP bytes Mud Sound Protocol. MSSP bytes Mud Server Status Protocol. MXP bytes Mud Extention Protocol. ZMP bytes Zenith Mud Protocol.","title":"telnet_constants"},{"location":"api/protocols/xml/","text":"Module mapper.protocols.xml \u00b6 Mume XML Protocol. Class XMLProtocol \u00b6 Implements the Mume XML protocol. Attribute modes: Mapping [ bytes , Optional [ bytes ]] \u00b6 A mapping of XML mode to new XML mode values. Attribute state: str property writable \u00b6 The state of the state machine. Valid values are in states . Attribute states: AbstractSet [ str ] \u00b6 Valid states for the state machine. Attribute tintinReplacements: Mapping [ bytes , bytes ] \u00b6 A mapping of tag to replacement values for Tintin. Method on_connectionLost ( self ) inherited \u00b6 Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\xml.py 59 60 def on_connectionLost ( self ) -> None : pass Method on_connectionMade ( self ) \u00b6 Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\xml.py 157 158 159 160 161 def on_connectionMade ( self ) -> None : # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF ) Method on_dataReceived ( self , data ) \u00b6 Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\xml.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 outputFormat = self . outputFormat appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( LT ) if outputFormat == \"raw\" or not self . _gratuitous : appDataBuffer . append ( appData ) if self . _mode is None : self . _lineBuffer . extend ( appData ) lines = self . _lineBuffer . splitlines ( True ) self . _lineBuffer . clear () if lines and not lines [ - 1 ] . endswith ( LF ): self . _lineBuffer . extend ( lines . pop ()) lines = [ line . rstrip ( CR_LF ) for line in lines if line . strip ()] for line in lines : self . on_mapperEvent ( \"line\" , unescapeXML ( line , True )) else : self . _textBuffer . extend ( appData ) if separator : self . state = \"tag\" elif self . state == \"tag\" : appData , separator , data = data . partition ( GT ) self . _tagBuffer . extend ( appData ) if not separator : # End of tag not reached yet. continue # End of tag reached. tag = bytes ( self . _tagBuffer ) self . _tagBuffer . clear () text = bytes ( self . _textBuffer ) self . _textBuffer . clear () if outputFormat == \"raw\" : appDataBuffer . append ( LT + tag + GT ) elif outputFormat == \"tintin\" and not self . _gratuitous : appDataBuffer . append ( self . tintinReplacements . get ( tag , b \"\" )) if self . _mode is None and tag . startswith ( b \"movement\" ): self . on_mapperEvent ( \"movement\" , unescapeXML ( tag [ 13 : - 1 ], True )) elif tag == b \"gratuitous\" : self . _gratuitous = True elif tag == b \"/gratuitous\" : self . _gratuitous = False elif tag in self . modes : self . _mode = self . modes [ tag ] if tag . startswith ( b \"/\" ): self . on_mapperEvent ( \"dynamic\" if tag == b \"/room\" else tag [ 1 :] . decode ( \"us-ascii\" ), unescapeXML ( text , True ), ) self . state = \"data\" if appDataBuffer : if outputFormat == \"raw\" : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) else : super () . on_dataReceived ( unescapeXML ( b \"\" . join ( appDataBuffer ), True )) Method on_mapperEvent ( self , name , data ) \u00b6 Sends an event to the mapper thread. Parameters: Name Type Description Default name str The event name. required data bytes The payload. required Source code in mapper\\protocols\\xml.py 163 164 165 166 167 168 169 170 171 def on_mapperEvent ( self , name : str , data : bytes ) -> None : \"\"\" Sends an event to the mapper thread. Args: name: The event name. data: The payload. \"\"\" self . eventCaller (( MUD_DATA , ( name , data ))) Method write ( self , data ) inherited \u00b6 Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\xml.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"xml.py"},{"location":"api/protocols/xml/#mapper.protocols.xml","text":"Mume XML Protocol.","title":"xml"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol","text":"Implements the Mume XML protocol.","title":"XMLProtocol"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.modes","text":"A mapping of XML mode to new XML mode values.","title":"modes"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.state","text":"The state of the state machine. Valid values are in states .","title":"state"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.states","text":"Valid states for the state machine.","title":"states"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.tintinReplacements","text":"A mapping of tag to replacement values for Tintin.","title":"tintinReplacements"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.on_connectionLost","text":"Called by disconnect when a connection to peer has been lost. Source code in mapper\\protocols\\xml.py 59 60 def on_connectionLost ( self ) -> None : pass","title":"on_connectionLost()"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.on_connectionMade","text":"Called by connect when a connection to peer has been established. Source code in mapper\\protocols\\xml.py 157 158 159 160 161 def on_connectionMade ( self ) -> None : # Turn on XML mode. # Mode \"3\" tells MUME to enable XML output without sending an initial \"<xml>\" tag. # Option \"G\" tells MUME to wrap room descriptions in gratuitous tags if they would otherwise be hidden. self . write ( MPI_INIT + b \"X2\" + LF + b \"3G\" + LF )","title":"on_connectionMade()"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.on_dataReceived","text":"Called by parse when data is received. Parameters: Name Type Description Default data bytes The received data. required Source code in mapper\\protocols\\xml.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def on_dataReceived ( self , data : bytes ) -> None : # NOQA: C901 outputFormat = self . outputFormat appDataBuffer = [] while data : if self . state == \"data\" : appData , separator , data = data . partition ( LT ) if outputFormat == \"raw\" or not self . _gratuitous : appDataBuffer . append ( appData ) if self . _mode is None : self . _lineBuffer . extend ( appData ) lines = self . _lineBuffer . splitlines ( True ) self . _lineBuffer . clear () if lines and not lines [ - 1 ] . endswith ( LF ): self . _lineBuffer . extend ( lines . pop ()) lines = [ line . rstrip ( CR_LF ) for line in lines if line . strip ()] for line in lines : self . on_mapperEvent ( \"line\" , unescapeXML ( line , True )) else : self . _textBuffer . extend ( appData ) if separator : self . state = \"tag\" elif self . state == \"tag\" : appData , separator , data = data . partition ( GT ) self . _tagBuffer . extend ( appData ) if not separator : # End of tag not reached yet. continue # End of tag reached. tag = bytes ( self . _tagBuffer ) self . _tagBuffer . clear () text = bytes ( self . _textBuffer ) self . _textBuffer . clear () if outputFormat == \"raw\" : appDataBuffer . append ( LT + tag + GT ) elif outputFormat == \"tintin\" and not self . _gratuitous : appDataBuffer . append ( self . tintinReplacements . get ( tag , b \"\" )) if self . _mode is None and tag . startswith ( b \"movement\" ): self . on_mapperEvent ( \"movement\" , unescapeXML ( tag [ 13 : - 1 ], True )) elif tag == b \"gratuitous\" : self . _gratuitous = True elif tag == b \"/gratuitous\" : self . _gratuitous = False elif tag in self . modes : self . _mode = self . modes [ tag ] if tag . startswith ( b \"/\" ): self . on_mapperEvent ( \"dynamic\" if tag == b \"/room\" else tag [ 1 :] . decode ( \"us-ascii\" ), unescapeXML ( text , True ), ) self . state = \"data\" if appDataBuffer : if outputFormat == \"raw\" : super () . on_dataReceived ( b \"\" . join ( appDataBuffer )) else : super () . on_dataReceived ( unescapeXML ( b \"\" . join ( appDataBuffer ), True ))","title":"on_dataReceived()"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.on_mapperEvent","text":"Sends an event to the mapper thread. Parameters: Name Type Description Default name str The event name. required data bytes The payload. required Source code in mapper\\protocols\\xml.py 163 164 165 166 167 168 169 170 171 def on_mapperEvent ( self , name : str , data : bytes ) -> None : \"\"\" Sends an event to the mapper thread. Args: name: The event name. data: The payload. \"\"\" self . eventCaller (( MUD_DATA , ( name , data )))","title":"on_mapperEvent()"},{"location":"api/protocols/xml/#mapper.protocols.xml.XMLProtocol.write","text":"Writes data to peer. Parameters: Name Type Description Default data bytes The bytes to be written. required Source code in mapper\\protocols\\xml.py 53 54 def write ( self , data : bytes ) -> None : self . _writer ( data )","title":"write()"},{"location":"api/roomdata/database/","text":"Module mapper.roomdata.database \u00b6","title":"database.py"},{"location":"api/roomdata/database/#mapper.roomdata.database","text":"","title":"database"},{"location":"api/roomdata/objects/","text":"Module mapper.roomdata.objects \u00b6","title":"objects.py"},{"location":"api/roomdata/objects/#mapper.roomdata.objects","text":"","title":"objects"}]}